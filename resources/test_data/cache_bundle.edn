{:version
 {:jar {},
  :scm
  {:files
   {"test/rewrite_clj/zip/walk_test.cljc"
    "dcef67608540146c0b7cd30735a65af4522f61e154a69896ddea70e5eb70d386",
    "CONTRIBUTING.md"
    "c1ba0d772dc03cb96ad39ff667a831f6df3188e92bf6e39526620c9f74a8d7f8",
    "src/rewrite_clj/node/coercer.cljc"
    "534e5c208840b20aa95dce924414c53edd5bc6ac2308c9f487385802832954f3",
    "test/rewrite_clj/node/generators.cljc"
    "b387a57f2fff32aa5deb8ff19da8d47b176b1d431d28e7daacb5f9fc261a53b8",
    "script/lint_eastwood.clj"
    "5db0cd8e2e738233cf0fa8a9f77e2bbbace7c30a169c6cc8a89bad8102167657",
    "src/rewrite_clj/zip/insert.cljc"
    "27264324674d6f40ebf4f9849ed17e1985f1cddb406daea79a74d0c8d752e868",
    "src/rewrite_clj/node/integer.cljc"
    "91c55b02e4b6c7699993f09e7f766665dcdee8ffab0a944cb47538e3fc2298ce",
    "CODE_OF_CONDUCT.md"
    "3741a4a060de0e15b467d8c839b46c0b3be7c266ca4e8ffc03c1e4ae5c53101f",
    "src/rewrite_clj/paredit.cljc"
    "35503de94151cedc50cb7e3736532056fe495d13ad065bc64ba21485af66362d",
    "doc/generated/contributors/AndreaCrotti.png"
    "60f14ec8641c573f8aa9d25c4682df4519c3e21ba7fb149b0e89f0dc76375431",
    "src/rewrite_clj/node/regex.cljc"
    "0bef5d34262200ab19dcd812e27118b026703d4f71a0b03ac8c12452abbbaea8",
    "src/rewrite_clj/custom_zipper/core.cljc"
    "cd66dcb71d0920ad084ad17293652cfb51fa854e760fd5bbae981c49630b7997",
    "src/rewrite_clj/node/comment.cljc"
    "da847e39540712c17ec20fb94658dc98291938de7f71494b8f94c05624f7c24f",
    "test/rewrite_clj/zip/editz_test.cljc"
    "6529c44713837953b4d61de5ad266d3839ddf148f1809cab3dd1400d60357aca",
    "src/rewrite_clj/zip/remove.clj"
    "5ee6203f623e92c9f78a3b27059d32cecf27d39c89e2b4c8b02f6cb68eaa1355",
    ".github/workflows/libs-test.yml"
    "5e9f2aca34fe7ee452faeee9ec838a8d16eceea5834c251569baaccedd0df73d",
    "pom.xml"
    "e2e6cb575e327ff7ca904e11b06b9a3d10730eb1c0a199b12f532cb5870a6290",
    "doc/design/01-merging-rewrite-clj-and-rewrite-cljs.adoc"
    "77a3986e1f4ffc7a6ad872edcdd5486e62ad97e8798591370e458feb713176e8",
    "README.adoc"
    "665e17770073d040323ea16d342ef3a0a6d0712cbb269f627e0669c4b707e870",
    "script/helper/deps_patcher.clj"
    "761bf6b7c29a96c797b3f1c47a461468803fdb5f35780f06ed74a25dd5f08313",
    "src/rewrite_clj/reader.cljc"
    "33c4be60942abb9f50ca1225d70f1cd89d4dd7d0eb4e59a1fe85dbe2c0930eef",
    "src/rewrite_clj/node/reader_macro.cljc"
    "72f0bdccb394ab2a3874d6c93874a111240170e0c2b964ba65972c348cbcdcb7",
    "script/ci_unit_tests.clj"
    "41fb53a0e2084ab7baa2bf72afb7cbc22f9693ae5dbbd60db49092a57931de09",
    "doc/map-nodes.drawio"
    "0fdcded35be5747234b218c9e3f30de8bab19b95cda408d7525b270df70c6932",
    "src/rewrite_clj/zip/walk.cljc"
    "3a2e2dc1fe6705196799f2d905af7a2a8f6e8da28e621e1e50eea98c169c146f",
    ".clj-kondo/babashka/fs/config.edn"
    "bb9605abdcb83246d268ca0d72a8e03cd4db000818b6411adaa13f723caa854a",
    "doc/03-faq.adoc"
    "12892c9b4753712428e13d48b17507f6af5447fbaa22a067b6d30e0888cab8cf",
    "src/rewrite_clj.cljc"
    "0edcd9a5cba8049f79ee5907662e30c766433ea7ad47f5e763f5b9b07e92a139",
    ".clj-kondo/config.edn"
    "0fd5e8413e226c3a58e34b29193bc81791d84b43540d0baa9b9346bc4798d78d",
    "test/rewrite_clj/zip/base_test.cljc"
    "1287ac90cbfb592f03db1012f56f8b813a9ef3cfcb49a3aabc4a885c99d9300a",
    "src/rewrite_clj/parser.cljc"
    "55810bcf487899f1798ae9afd93c63872983408473eec4a9036e4ef8b74005da",
    "script/test_jvm_sci.clj"
    "596bbf61d9ef2b23c63d1ba7d20e771ae0bad93cf52930b761555891b987d738",
    "doc/generated/contributors/jespera.png"
    "32a3160bb09c35f5fe4a6abad130eddfe36bf171bcab4fe05be56d0d5cec14ab",
    "test/rewrite_clj/node_test.cljc"
    "e6f7badd9037a5140a7067caae7a5872c01444ce63fa7411e4284dab84cdb22c",
    "doc/generated/contributors/brian-dawn.png"
    "e9ef714f0c39056788600b58e41a0e1c3b7109c402c09d00802b79366ef06355",
    "doc/generated/contributors/anmonteiro.png"
    "7d35f8b21e97e380368029a3f7cf3961c864ffc9f72d3e5b2643e01d71a955a0",
    "doc/generated/api-diffs/rewrite-cljs-lang-cljs-and-rewrite-clj-v1-lang-cljs.adoc"
    "50ce5b5668a8cbaccbe792ea11be8bc7d510fc2ca5bc6f7e60719c74f821000b",
    "script/doc_update_readme.clj"
    "51646ac3b2c7a86691fec128f6df0343143b19dd2da250a1e535700addfdaf18",
    "src/rewrite_clj/zip/subedit.cljc"
    "e0ba75fd0739fee7ec7fb96eb14d3552b95c73cbccaeef46b3cc1cfe888860f1",
    "doc/rewrite-clj-logo.svg"
    "37d9791266d808af03b4e42cab8f4d34b24868cdc192dad7b6707cbbd6ce8ba3",
    "doc/generated/api-diffs/rewrite-clj-v1-lang-cljs-and-rewrite-clj-v1-lang-clj-documented-only.adoc"
    "37d1d702c810a82339a310db9c75ab63e156665078eca3d39f7ef7bbcf25c0e7",
    "template/rewrite_clj/node/string.clj"
    "210bf0c80b7fe0881f809738b49f1d44f459fea6809c5c20abc04143553fa56e",
    "script/helper/main.clj"
    "6e14bc74ae8c93f8251ca3446305c965d6ceec510cb1e4989d288d774fcf995b",
    "doc/generated/api-diffs/rewrite-clj-v0-lang-clj-and-rewrite-cljs-lang-cljs.adoc"
    "1abc5fc3f40d91b578a80bada007e70d8b96ff5c75ad602a6b9b0f62f871d590",
    "src/rewrite_clj/node/quote.cljc"
    "54d5f045dabaa9455fa660f2b6c2a4df30a397d4eae44c16a0a443fa678c8d99",
    "doc/02-developer-guide.adoc"
    "7f52f0115742d9ccf1b5f33bd884cbd43dcf3771d5195efd9cffe4da5298f0ae",
    "doc/generated/contributors/eraserhd.png"
    "b1a3407b6a01b02ca70b4f7197ff51fccf5bccf66f038f2ab6e5a7acecb5be2d",
    ".github/workflows/unit-test.yml"
    "4cece97b89c0ef9ec8514443bb3a16e2a6525d9867e4a171ee2dea3caaa5d0fa",
    "LICENSE"
    "2af6e1b3dea429bf4fe2a33fb1c26c811bc160cf2b9272e7020c4dd0886e221c",
    "test/rewrite_clj/node/node_test.cljc"
    "ef5ab3b6af34cc470a131f47c3a36925aad23ce0b8f9832166de78a0e337cad6",
    "script/doc_api_diffs.clj"
    "395e1d75f2f30ffa402ff92e2d1f9650c5bbb6381e8b36a985137c81a21f95c3",
    "bb.edn"
    "fed29789a1f61769852e1d9460468c8af1ff1a213cc785c068217ebe3191f281",
    "script/sci_test_gen_publics.clj"
    "056e3ad27db3ea78115c8ce620934a1b49454b6cbc83779bbe5f59333f002220",
    "doc/diff-notes/rewrite-cljs-lang-cljs-and-rewrite-clj-v1-lang-cljs.adoc"
    "10613578ea60ecb06aa06d6fc67d429f6762c44cd98f9ff150686bac603750f0",
    ".codecov.yml"
    "be9d0cdfae15ef12ed98db71d57eac309a2075405973eafd2e82572843e9643c",
    "script/test_cljs_watch.clj"
    "90d9adcd10d0c7a566f4710c33a5afeba08197abaf88fa835afe9aabd1c252e5",
    "script/lread/apply_import_vars.clj"
    "5a72a6fca1650b3cfe09d6cea6cbdc779a25d5dde4b8f699e98622af47aeae89",
    "src/rewrite_clj/zip/base.cljc"
    "1b53cdb1b52cd7f1a28e9c3d233fc5b08572810d90082e7f7e869f4227bba2fb",
    "test/rewrite_clj/zip/findz_test.cljc"
    "e50f6e552ab99d397cc3e51163e5f3dc13876372475ca6e036e1a2af069096a9",
    "src/rewrite_clj/zip/seq.clj"
    "f4794a7c568872f1ea727f7c6c03d17f674ed2306b014d6590553c95ecf1fe68",
    "src/rewrite_clj/parser/keyword.cljc"
    "cf8beeaaefd54152d36eacbb8f29d4f5594a2d0117f487c31aa05aec22a2144d",
    "template/rewrite_clj/zip/edit.clj"
    "0ce8a30fcc1d998f7e7dd249c28e1a93261da70852f75a5a80e79c5857258224",
    "doc/generated/contributors/arrdem.png"
    "89193466778475f60c6d793e8d3263442b2cc2c2b7153ad16e7fb38c9117fb4e",
    "doc/generated/contributors/rundis.png"
    "d114eb70d3907544d01675d5accbde5c2938da4517d1a6c69370a6bbe83ffb3e",
    "script/lint.clj"
    "895527b2877cbd36019e20b65b3ffdf10e36f198d85bd673a1032b1d7cebec9b",
    "script/test_coverage.clj"
    "752558d72f90fe852d9e2cfa69a45721072e60bd2e8e7017b47b9ce1a7529895",
    "doc/diff-notes/rewrite-clj-v1-lang-cljs-and-rewrite-clj-v1-lang-clj.adoc"
    "7e86a41375236357156f34bd3496c1a53d09ae6b7269d6d11eb224921ef617cf",
    "script/test_native.clj"
    "8fbcba4d630ff7fc9e04ad1c8280fd5ea118bd6a41bf1674a1106d9b38df26c0",
    "test-isolated/rewrite_clj/zip_solo_test.cljc"
    "4edd081a78d2f07a231a08205f12bc8e8f3bdc657beef0bd50f80cc64c04a350",
    "doc/generated/contributors/xsc.png"
    "816b66820abe28ca1713a04b240e917cd74a72034a62141d8d9ad48d41345f56",
    "src/rewrite_clj/zip/context.cljc"
    "6e92dff3fc1a7d95af6f7244b1dc6b6a8293e6b55403b9251589235a43e23ea0",
    "script/test_shadow_cljs.clj"
    "7d9073a98cebd858e10cfc77b2023b88680cf18909ebaf181dabb76d372056c1",
    "test/rewrite_clj/zip/subedit_test.cljc"
    "348c85524a11e220dd6f84aba87210a8cad562c9fd36bfea0baccc764ba652ea",
    "script/helper/shell.clj"
    "ac92adc91cd571e525c66e938fbb17b2d67326fd0917da8c1c2ecba16289022b",
    "src/rewrite_clj/zip/options.cljc"
    "28206c2b396539bf8f8f2608b46fe21ec60eb95e64c98a3ca74e09c65b754add",
    "script/test_libs.clj"
    "dce2b2c2e09d962f390e9a5daf3c047dd95e76c8344cd5ddb9bb450e43328161",
    "doc/generated/contributors/green-coder.png"
    "a167cbbad623c264c979fde0670a1e1b41fdd1cfebaa0840915012e43c5d904d",
    "src/rewrite_clj/node/uneval.cljc"
    "2acb361bb075a239dc165e93bf85f4e2644da3694cc9c18db99fee49ab2c82c8",
    ".clj-kondo/lread/status-line/config.edn"
    "635ba1eab186088361bb7a9acc215e20f4ba65b4586d60423f5ff29082c76a39",
    "doc/generated/contributors/slipset.png"
    "f235bfa21ec159d267c695e6b0e1289b47f2406a25875de9cf8331365b1de162",
    "doc/generated/contributors/mainej.png"
    "269427ed900127fcc6652900f96f81f8b3d0408ce0cd552f54ddb67fb0ad1942",
    "script/cljdoc_preview.clj"
    "429fe616970c11f3a1dda30b72567d4a860fd16503f5686e2488fc00efd859e6",
    ".github/CODEOWNERS"
    "f3058f0223a67e2969f3b7daf11d862448fa055192fb777420b511d51beca0b1",
    "tests.edn"
    "3053a4649a5549322804c99060e71e959215eb8723c5a8009bbc5c021494d1ba",
    "script/helper/fs.clj"
    "881d0451d8d7606521a096fb9a26aa5f6df975f14b62a19bcaba9694e53b018d",
    "doc/generated/contributors/PEZ.png"
    "85c6aa15e969d79fa494c55e499dfae88379b6b2578b578429b2940db2786bd2",
    "script/ci_release.clj"
    "80b292c37d67f37af667e54de6c5b2943b6a3d6df60f49ab659da28595da4223",
    "src/rewrite_clj/custom_zipper/switchable.cljc"
    "040ead76fa333fe89a0dc7faaca0d900da47ade8f01c887f4744da269c67e795",
    "test/rewrite_clj/paredit_test.cljc"
    "44d6411369a6f97d04fc699002876e51e0e87759cf2e0d009dc26e8358c0b7c4",
    "script/clj_graal/gen_test_runner.clj"
    "ab9494de3f5d884fbda10daf67de70299efc86fa23d8fe7d526e42324da4fdd2",
    "version.edn"
    "87653c66305be846d77f1c2ab3064c345be33f75f55ee72691e916d3b30d92ac",
    "doc/generated/contributors/lread.png"
    "84235a10b49513901e957be694de9b057585edb9fa558481f2bdc4c58c11e7c9",
    ".github/workflows/release.yml"
    "d0ad02e3df002dbbc703eb54f70db60eabd977231185198d1e9da325647b1740",
    ".github/ISSUE_TEMPLATE/docs.md"
    "21d092d9accab405a1ea63cfc1a89919430ab68364f104ca6a043ce898b375a4",
    "src/rewrite_clj/zip/seqz.cljc"
    "14d2c51de19e0c6b7976e384e5cada56c62011a46348657527165b79d34654ee",
    "doc/diff-notes/rewrite-clj-v0-lang-clj-and-rewrite-clj-v1-lang-clj.adoc"
    "550ab0dc8a81781787eb4e06fb04698cd9c537a4bb790ada3fd95eb8c8dc9474",
    "src/rewrite_clj/zip/edit.clj"
    "4ad44322549012f9e892a59c0c8a5c81a7588c6fbbd2f510c6b22d80be00c99e",
    "template/rewrite_clj/node.cljc"
    "21d0970c43ee94014fb85e00592041ab5b0f4203646ad96ce951c23248c57ebe",
    "doc/introduction-parsed-nodes.png"
    "dc8d48855edd4aeb1ff905cadac77a021e3769735c08d14cb6a8d5c46e889515",
    "doc/generated/contributors/borkdude.png"
    "1f24c7de5b94fb48fc1f0e90e3db4153ed1e66f38c87a638fdd82963f43cc413",
    "script/gen-user-guide-reader-macro-table.clj"
    "116b5e1b6f4f1c1cd9433dfab5d44dcb1463061c34a00b49bcf2d10e693536ca",
    "script/clj_graal/template/by_ns_test_runner.clj.template"
    "542eb81272b768c5452f1232ef538121b8e2f720c1d0c60bd6d54c3e632042e0",
    "doc/generated/contributors/stathissideris.png"
    "e26962f59385061db0cb51cf0134d02a09a71527390b7687876563c74e7ba6d4",
    "src/rewrite_clj/node/string.clj"
    "38ca21cf7659e190504909df39f0658214d0984a3efff0498360efeb82febe1d",
    "script/helper/env.clj"
    "b98367f962988a2e5685b3653bb4bcbdd0d6c7640662aaca2161046dc1877a78",
    "doc/generated/contributors/vemv.png"
    "a9a941f378840b569d85efc32691a1e5ff60729bd6b8888e0f4763e328575322",
    "src/rewrite_clj/node/extras.cljc"
    "48e250789765dcb7d5c177fb30e3f8c758d439217641f08ef86d54ee1405cd73",
    "src/rewrite_clj/zip/removez.cljc"
    "7785a6ff473698dae1502eb07b85e208d34e3e53f816ef55a68f68154e9f94fd",
    "doc/generated/contributors/plexus.png"
    "489885e161160aa22b152efb84fbbc051dd242532f3b725ec0778ae549e013a3",
    "doc/generated/contributors/rgkirch.png"
    "e6d24dc1ce46f57c6b9500e344d95b8e54d2472f063fd741c04c11a37df15e07",
    "template/rewrite_clj/zip/seq.clj"
    "6dd6bb21229b54bcb820941b05c90fbedcc5442ba5845b523df90d9ef4ede3b3",
    "doc/diff-notes/rewrite-clj-v1-lang-cljs-and-rewrite-clj-v1-lang-clj-documented-only.adoc"
    "fd5702e0a2c6bd4e85ff8ec26e3e4cf93867ba34d1da3c9c5b962b9b5f2f5149",
    "src/rewrite_clj/parser/namespaced_map.cljc"
    "25ab6959ea6e5b92cefc18fc520c1506fe9c9f036bcc443ddf0591c35511634f",
    "test/rewrite_clj/examples/cljx_test.cljc"
    "fe7016a0d382c824afd9fd5812a1359f210b89263be011f8d9b2b778dbced1b0",
    "doc/diff-notes/rewrite-clj-v0-lang-clj-and-rewrite-cljs-lang-cljs.adoc"
    "8f302c6594727ed2565b9378822866c404b3a3d869a39f92013437e464d52931",
    "script/apply_import_vars.clj"
    "e19578c37aeb82391cc33c882721b31a4954880d8c7d8d079a5d9ca81a3f49c4",
    "script/resources/logback.xml"
    "ac58f67963a10ac0c2fa3dd8419b1e77230b1c21ec184781ec8e98bea5efdd40",
    "doc/contributors.edn"
    "5375b80b84cc9df50810467304669da636e49aeca41c3f86c4d4dd61a1894294",
    "doc/design/namespaced-elements.adoc"
    "85dea4046440dd3d1865647be4a6c196af622f532f602c644d35f9ed3c5c59d3",
    "doc/generated/contributors/sogaiu.png"
    "27110412836a3202aa385a46a0d8dbc381de258aa312202df799df09a48b4024",
    "src/rewrite_clj/zip/whitespace.cljc"
    "2dd74be55756ba99e5e2c1f5fa6419d957efa6a392830eb4c1ee189dcac34575",
    "src/rewrite_clj/zip/editz.cljc"
    "1cada0f9337a1631e1dba75477d17fd89e81b019518bc57769df0275bbdbc7c0",
    ".github/ISSUE_TEMPLATE/bug_report.md"
    "13f0e831c3ce3dedf7cb5b8b08ed7d850f4bc60fbf0f43ab3b03a69fe0045742",
    "script/helper/graal.clj"
    "b5e07d0aabb43a4920b8b37baadecab99e475a718455a34b05b0400b15149bfa",
    "doc/rewrite-clj-logo.png"
    "652ee1e42c562a53618c9511ba79a631b504968ce40ad84b74bd79afca79df0c",
    "CHANGELOG.adoc"
    "b2e5013bd48767610325cbe8261e69d7825ae9f6abe57873f8a5b7c15bd2816a",
    "template/rewrite_clj/zip/remove.clj"
    "cb8f55dcb73eec198cecc089239a8eceefcc12547c69d8e28156ae29b5100bbb",
    "test/rewrite_clj/zip/removez_test.cljc"
    "b8065d5ce3a6f126a0aee69de73264f09cbdf0f1862e8d637062081813e8c7ae",
    ".gitignore"
    "18a4f551ea9b403702203c179b7ce94ef0a5bc25bc46a6434993b0954306b19d",
    "src/rewrite_clj/node/forms.cljc"
    "34434fbe56c470e3dc19a2a8f682c24364c5dae82b8c277db8b8dc7f5b1b088b",
    "package.json"
    "d259c79b6ba01b0d0ff90044e1a6f00510031c9ac1486a0de9558eda7be48b3b",
    "script/code_info/ns_lister.clj"
    "1a1ec3d2a93324097763213dfaaa97b6375e01c49cb2951c8cab98ce9fdea87a",
    "template/rewrite_clj/zip/find.clj"
    "3f3526da407010e16bf8af7291cc66f2e2944f75679e62c0569fa8b6c1d8c974",
    "src/rewrite_clj/node/token.cljc"
    "03760a9b706385b984295cad98eab2a70517d1bfab47c43d878df38158beb50c",
    "build.clj"
    "7c943622790ec48fb26cf9b2c025f3780dee0e1d55b6b64d3ec62294aaa81329",
    "doc/01-user-guide.adoc"
    "3981ef998ca13c0928c1bef722093cfa318d1c919b000ce3513c22f1c368c80d",
    "doc/generated/contributors/martinklepsch.png"
    "4324033cd9484c1dc349f0dba01b139c68547269a67a3bb056b2584c36e60208",
    "doc/generated/contributors/danielcompton.png"
    "f9e78ae9dc8874a5918066f4fd4fc32ad3dece1dadf32d976a44e2e00e08fb0c",
    "src/rewrite_clj/node/protocols.cljc"
    "85a5abc184f723a32ba816b1951974cf3a1de28f0627b2323731ada45f8217ee",
    "src/rewrite_clj/parser/token.cljc"
    "f99d7fae05342b9bebcb446f9130140cd6d6855cfd7bd54115ac89380eb1ebd3",
    "fig.cljs.edn"
    "24f7a583b7ab0bd451df336830c3584ad88cbac7fcc166881171772cf846c966",
    "src/rewrite_clj/node.cljc"
    "4e490c45460d64cc972ab1060c747df13a6531b5ab63b0c19d9ecf91b698ecc3",
    "doc/generated/contributors/bbatsov.png"
    "85d394715b91de9cc25ed86b8d46697feceda914f6fbd064403bba11b2c81d90",
    "src/rewrite_clj/node/keyword.cljc"
    "0e85d0fae43222bfe39bf07a420bdebb72c99252fa4981aa9062e95449a65f90",
    "script/test_native_sci.clj"
    "4911425a8232d341e316cec65098500678de7f5b9b9141a3aec53ae7b8d620b6",
    "script/sci_test_runner.clj"
    "118681f56bbfb6cf79d6a424a15cc2ed559840c4dc301e886388f427a169976e",
    ".github/ISSUE_TEMPLATE/feature_request.md"
    "d1f032f3cc89b471e765a3d8c38700bfcf219a5226b11397ca02f31216220783",
    "src/rewrite_clj/custom_zipper/utils.cljc"
    "d0681d3de23f82f8e296914a740fa8718699d3a848d405045d4af12b613e6e75",
    "ORIGINATOR"
    "1bedd97507fbf33cb2b5d4b9a42de3cc519d7bb1ae3d342277b4e69826c8cb5b",
    "test/rewrite_clj/regression_test.cljc"
    "33a4f2847634f9a4ab5a777bd39931e041e04ea2d68bb929814fc73608a75d68",
    "script/lint_whitespace.clj"
    "98a89923a0cdb6e3ee150c93876889f7490aa58b1ee7045f4858e955bd67197e",
    "test/rewrite_clj/parser_test.cljc"
    "5b4f6561a3aac3c577eff9e63cbc53d0098dfeabe59a1e5c2621770b135d248d",
    "src/rewrite_clj/node/seq.cljc"
    "8ae694298efa57811b312bba484c643b4c790712e81dbe58dbc18bc5bcc1123e",
    "src/rewrite_clj/parser/string.cljc"
    "95cf1d792aca3f1cfcdbc618fdaac884ef2b116b4c9c814d09f0c3b5b0f98a75",
    "src/rewrite_clj/zip.cljc"
    "5f4816412065663dd447ba545c3f5ffc2737b8bc6e5226dac407a5d166ca14e5",
    "doc/generated/contributors/mhuebert.png"
    "367dd905978d4b19b086f79094a7fc43451dbc0144d13d5f809e638ef1aa0fdd",
    "doc/introduction-parsed-nodes.drawio"
    "144a6acd3a9c90fa06043ee989b23419699d33b59e3b1b63bd242569bcff09bf",
    "script/clj_graal/template/by_var_test_runner.clj.template"
    "f4b520d53027b14423870a0eab7eb5c28b88ca2edb8d94d91ea40f0277e0caf4",
    "doc/cljdoc.edn"
    "380605656deea0b2e162d6e379fd9dcf38db3fcc8095468dcc46fdbd4e00e091",
    "doc/generated/api-diffs/rewrite-clj-v1-lang-cljs-and-rewrite-clj-v1-lang-clj.adoc"
    "683e4a4b135efa6c61f5360a2b4cb4089c359ff6e7272447553fbaf609a99220",
    "test/rewrite_clj/custom_zipper/utils_test.cljc"
    "cde71b97284bf0fd7b1298590ed72dc63ee748f42b737c59f6caca777d478503",
    "resources/clj-kondo.exports/rewrite-clj/rewrite-clj/config.edn"
    "9ad24d29701957b934f64a85d52363b28c8b4bf023d8988d037e8c524b272a0c",
    "src/rewrite_clj/node/meta.cljc"
    "29d2d6f5acd49d21e6fc5c4310b21adeba56fa9a76e1112adc2bd2ce6204b078",
    "src/rewrite_clj/node/namespaced_map.cljc"
    "3da254df54bc293f90bc472fdc0c0572e9cb3789234b0fd1a621ee48458b1099",
    "src/rewrite_clj/node/whitespace.cljc"
    "6ecca067b3ca653a249300729e60b444fe2e4602b1ebc1988e98eab77d6b3564",
    "src/rewrite_clj/node/stringz.cljc"
    "8759fbbfcac8646e57021929f4deb601b6fa2fa2e1de8a16093ac852ea5c9837",
    "doc/generated/contributors/swannodette.png"
    "0c6123d3ad6137dbbd52cc7f55e3222bd3268655bde00754866ab1ed12b8c258",
    "src/rewrite_clj/interop.cljc"
    "4dbb30e604dc555c47dae0ced33e5eab88cf488278560a3a15a582ca26d24f6e",
    "test/rewrite_clj/hello_figwheel.cljs"
    "2a64a5dde326f2f32428945515ac4ea5f57b2242c9b3f2e18246be6baa92fa81",
    "test/rewrite_clj/zip/seqz_test.cljc"
    "cb41a4edac95b17a988d3d1b0679eb974d886cf7c6e0aea0a83bb0a45039f76e",
    ".github/workflows/code-coverage.yml"
    "f5853178c1cfd368db3aed0d58e6a0a40136f8be5588a4226aeaa05f1bc5122a",
    "deps.edn"
    "0cb7fe3a1b107b040dec82f3a5914aa7901c30b363f291e4b440d77cf44949e9",
    "doc/generated/api-diffs/rewrite-clj-v0-lang-clj-and-rewrite-clj-v1-lang-clj.adoc"
    "c301f95d7d87a7db8e8b8864d2d650c61f7876e3b9be8dddd486a8d61e7fd02d",
    "src/rewrite_clj/zip/move.cljc"
    "55369299b74e50a39a00689821daf8771574778e84e464a950c7f1cf2ceb1173",
    "script/test_clj_watch.clj"
    "23068c56761f1d9fd0cab5194e2ee08e23e3ecbcada7041da21c03dd1a6e2e60",
    "test/rewrite_clj/zip/whitespace_test.cljc"
    "0478cd8ed028fe91b74c7e496518de839a3649c78e5a81c5cb1ca68cb4d78b96",
    "doc/generated/contributors/kkinnear.png"
    "233d62089e43f4a9e87cdc5e0b9596864f015626257d0a635c87ad44f443949b",
    "doc/04-maintainer-guide.adoc"
    "309eed2618fe0cc66190ca18db783d711dbdede50c5d6a34503d6018176f3da3",
    "test/rewrite_clj/transform_test.cljc"
    "23781433fa3db77e7a6f4daf555e5b10cbc6fb4eae8755a53ffa6bd2a7a43813",
    "script/test_clj.clj"
    "dbbc3c83545ce39488e965ab515a166ccd56375cb0c9e15819aa23e6b350403a",
    "script/test_doc.clj"
    "9ecc08d6d06f801954818977fa3ccc702570fe8127c7f7c9c41face12f7181b3",
    "test/rewrite_clj/custom_zipper/core_test.cljc"
    "c029d9cc0e97e60d6f8f7fa95b9c69eb7740fdee9c01a7399ccfa03741d69534",
    "src/rewrite_clj/parser/whitespace.cljc"
    "d630af35342881653c1ac46ea03ca963ff18577dbc8f67c5d3096a62af460bc9",
    ".github/workflows/native-image-test.yml"
    "4112adc7715311d4b65d8177b2e192f9566dce6c5e8a58846a6ee98a569593e1",
    "test/rewrite_clj/zip/move_test.cljc"
    "cb8137be023a42c602112207b67e2aff9ef24b26b1858d3fcb44c2537235503f",
    "script/test_cljs.clj"
    "bd9393d27c0ac2dc363c50cb90e478908f4bea4a6b6310aab6975698f146dcca",
    "test/rewrite_clj/zip/insert_test.cljc"
    "1f6ba3282e31d3d95501bb1faedfa1e240659271ae8fdad688d02fc12fdf6f7d",
    "src/rewrite_clj/zip/findz.cljc"
    "794e7357307e8fdbcf0cf139e91f18049a4b99bc4953bc85b1ff0e233b3b1870",
    "src/rewrite_clj/parser/core.cljc"
    "419302bc03876a5fcf0a72f2a3e6cbb6508a2c65b5be8e6cc634c42bb9462782",
    "doc/generated/contributors/ericdallo.png"
    "fb3840fc746871a05f0885dcf21f7cb1ce35d7f995ba851a66930aa677ee12ea",
    "src/rewrite_clj/node/fn.cljc"
    "1cee3059887b29619584f86666db90feee7551769e59f46f2397b15fba0e834c",
    "package-lock.json"
    "3943ba9608f9a061dfe39aec0371664a250e74844bc0dcfa1046ed8485f5fcf9",
    "script/lint_kondo.clj"
    "c0d25d9b32ce519ed45ec186dafef5a3c527d4ab30b834bd887885612272cb78",
    "script/clj_graal/template/direct_runner.clj.template"
    "5546e8b1e043708b011563bf1cd6529783a2d5f872640ed7a0139ce308abe588",
    "template/rewrite_clj/zip.cljc"
    "b65f81be573cc6291ca58dd1b2716d3889acbbbea73589e907eee73ccd54305e",
    "doc/map-nodes.png"
    "4a5a13e1439ffa74f8ac423e7135d61fa574a0e4f6e3150a415595cbc9cee8b4",
    "test/rewrite_clj/node/coercer_test.cljc"
    "02349407a2584c7cea73b6d759daa2cdcc801d15b51388e36d0c746f5aace4bb",
    "test/rewrite_clj/node/integer_test.cljc"
    "9192a44bdc7fc847409d7b2819734671cc47a6920679792d3e8f7ba168b172cd",
    "test/rewrite_clj/zip_test.cljc"
    "3f0c2625854ba11a7cb3a8a189d7bad044707ec90ce6e1b0a1d2e75d5a20e0e0",
    "shadow-cljs.edn"
    "9f9e27884a3b95a6303987da53a3118692e0529c4a6548cc1da4c94605796356",
    "src/rewrite_clj/zip/find.clj"
    "2d27fad4919c9a28239f23eef9e506787c54f0f5cf8f2befc1a670a9c7f47622",
    "script/outdated.clj"
    "ad9ecd34e515ce74e37c330bc68c396450c498287fd3eb44a9ed7fb90dc14e81"},
   :rev "v1.0.767-alpha",
   :branch "main",
   :tag
   {:name "v1.0.767-alpha",
    :sha "3964e8543305f629ed9e25be9237b9d1f8fd6c9a",
    :commit "65280f792199dbbcc09328bda208dad77c5abf6d"},
   :url "https://github.com/clj-commons/rewrite-clj",
   :commit "v1.0.767-alpha"},
  :doc
  [{:title "Readme",
    :attrs
    {:cljdoc.doc/source-file "README.adoc",
     :cljdoc/asciidoc
     ":notitle:\n:figure-caption!:\n:imagesdir: ./doc\n:project-src-coords: clj-commons/rewrite-clj\n:project-mvn-coords: rewrite-clj/rewrite-clj\n:workflow-url: https://github.com/{project-src-coords}/actions/workflows\n:canary-tested: 🐥\n:canary-needed-patch: 🩹\n:not-canary-tested: 📍\n\nimage:rewrite-clj-logo.png[rewrite-clj,270,60]\n\nhttps://cljdoc.org/d/{project-mvn-coords}/CURRENT[image:https://cljdoc.org/badge/{project-mvn-coords}[cljdoc]]\n{workflow-url}/unit-test.yml[image:{workflow-url}/unit-test.yml/badge.svg[Unit Tests]]\n{workflow-url}/libs-test.yml[image:{workflow-url}/libs-test.yml/badge.svg[Libs Test]]\n{workflow-url}/native-image-test.yml[image:{workflow-url}/native-image-test.yml/badge.svg[Native Image Tests]]\nhttps://codecov.io/gh/{project-src-coords}[image:https://codecov.io/gh/{project-src-coords}/branch/main/graph/badge.svg[Code Coverage]]\nhttps://clojurians.slack.com/messages/CHB5Q2XUJ[image:https://img.shields.io/badge/slack-join_chat-brightgreen.svg[Join chat]]\nhttps://clojars.org/rewrite-clj[image:https://img.shields.io/clojars/v/rewrite-clj.svg[Clojars project]]\n\nA library that reads and writes Clojure, ClojureScript and https://github.com/edn-format/edn[EDN] from Clojure and ClojureScript in a whitespace and comment preserving way.\n\n== Status\n\n*Warning*: v1 Alpha Release\n\nOur first rewrite-clj v1 alpha release was in March of 2021. +\nSince then we have seen wide and successful adoption of rewrite-clj v1 with no show-stoppers. +\nI would drop the alpha status but have not yet seen the following features get a good shake yet in the wild:\n\n1. zippers with `:track-position?` enabled\n1. zippers using `:auto-resolve` support\n1. paredit API\n\nSee https://github.com/clj-commons/rewrite-clj/projects/1[project page for current priorities].\n\n== Docs\n\n* link:doc/01-user-guide.adoc[User Guide]\n* link:doc/02-developer-guide.adoc[Developer Guide]\n* Design\n** link:doc/design/01-merging-rewrite-clj-and-rewrite-cljs.adoc[Merging rewrite-clj and rewrite-cljs]\n* link:doc/03-faq.adoc[FAQ]\n\n[[used-in]]\n== Used In...\n\nSome projects using rewrite-clj v1\n\n* https://github.com/xsc/ancient-clj[ancient-clj] {canary-tested} - Version Metadata Retrieval for Maven Artifacts\n* https://github.com/liquidz/antq[antq] {canary-tested} - Point out your outdated dependencies\n* https://github.com/babashka/babashka[babashka] {not-canary-tested} - Native, fast starting Clojure interpreter for scripting\n* https://github.com/borkdude/carve[carve] {canary-tested} - Carve out the essentials of your Clojure app\n* https://github.com/nextjournal/clerk[clerk] {canary-tested} - Local-First Notebooks for Clojure\n* https://github.com/weavejester/cljfmt[cljfmt] {canary-tested} - A tool for formatting Clojure code\n* https://github.com/greglook/cljstyle[cljstyle] {canary-tested} - A tool for formatting Clojure code\n* https://github.com/clojure-lsp/clojure-lsp[clojure-lsp] {canary-tested} - Language Server (LSP) for Clojure\n* https://github.com/FiV0/kusonga[kusonga] {canary-tested} - Renaming and moving namespaces in Clojure(script)\n* https://github.com/clojure-emacs/refactor-nrepl[refactor-nrepl] {canary-tested} - nREPL middleware to support refactorings in an editor agnostic way\n* https://github.com/borkdude/rewrite-edn[rewrite-edn] {canary-tested} - Utility lib on top of rewrite-clj with common operations to update EDN while preserving whitespace and comments\n* https://github.com/lread/test-doc-blocks[test-doc-blocks] {canary-tested} - Test AsciiDoc and CommonMark code blocks found in articles and docstrings\n* https://github.com/nubank/umschreiben-clj[umschreiben-clj] {canary-tested} - Rewrite utilities for refactoring clojure files\n* https://github.com/kkinnear/zprint[zprint] {canary-tested} - Executables, uberjar, and library to beautifully format Clojure and Clojurescript source code and s-expressions\n\nSome projects using rewrite-clj v0 and/or rewrite-cljs\n\n* https://github.com/Olical/depot[depot] {canary-tested} {canary-needed-patch} - Find newer versions of your dependencies in your deps.edn file\n* https://github.com/jonase/kibit[kibit] {canary-tested} - There's a function for that!\n* https://github.com/xsc/lein-ancient[lein-ancient] {canary-tested} - Check your Projects for outdated Dependencies\n* https://github.com/benedekfazekas/mranderson[mranderson] {canary-tested} - Dependency inlining and shadowing\n* https://github.com/jstepien/mutant[mutant] {canary-tested} - Mutation testing for Clojure\n* https://github.com/mauricioszabo/repl-tooling[repl-tooling] {not-canary-tested} - a base package for Clojure's editor tooling\n* https://github.com/atomist-skills/update-leiningen-dependencies-skill[update-leiningen-dependencies-skill] {not-canary-tested} - Track project.clj dependencies across different projects\n\nHave an update? Let us know!\n\n{canary-tested} [.small]#canary tested against rewrite-clj v1 link:doc/02-developer-guide.adoc#libs-test[lib test suite]# +\n{canary-needed-patch} [.small]#source required minor change to work with rewrite-clj v1# +\n{not-canary-tested} [.small]#no easy-peasy way to run automated unit tests found for this project#\n\n== Versioning\n\nRewrite-clj versioning scheme is: `major`.`minor`.`patch`-`test-qualifier`\n\n* `major` increments when a non alpha release API has been broken - something, as a rule, we'd like to avoid.\n* `minor` increments to convey significant new features have been added.\n* `patch` indicates bug fixes - it is the total number of commits in the repo.\n* `test-qualifier` is absent for stable releases.\nCan be `alpha`, `beta`, `rc1`, etc.\n\n== People\n\n=== Contributors\n// Contributors updated by script, do not edit\n// AUTO-GENERATED:CONTRIBUTORS-START\n:imagesdir: ./doc/generated/contributors\n[.float-group]\n--\nimage:slipset.png[slipset,role=\"left\",width=310,link=\"https://github.com/slipset\"]\nimage:sogaiu.png[sogaiu,role=\"left\",width=310,link=\"https://github.com/sogaiu\"]\nimage:vemv.png[vemv,role=\"left\",width=310,link=\"https://github.com/vemv\"]\nimage:danielcompton.png[danielcompton,role=\"left\",width=310,link=\"https://github.com/danielcompton\"]\nimage:kkinnear.png[kkinnear,role=\"left\",width=310,link=\"https://github.com/kkinnear\"]\nimage:PEZ.png[PEZ,role=\"left\",width=310,link=\"https://github.com/PEZ\"]\nimage:plexus.png[plexus,role=\"left\",width=310,link=\"https://github.com/plexus\"]\nimage:AndreaCrotti.png[AndreaCrotti,role=\"left\",width=310,link=\"https://github.com/AndreaCrotti\"]\nimage:anmonteiro.png[anmonteiro,role=\"left\",width=310,link=\"https://github.com/anmonteiro\"]\nimage:arrdem.png[arrdem,role=\"left\",width=310,link=\"https://github.com/arrdem\"]\nimage:bbatsov.png[bbatsov,role=\"left\",width=310,link=\"https://github.com/bbatsov\"]\nimage:brian-dawn.png[brian-dawn,role=\"left\",width=310,link=\"https://github.com/brian-dawn\"]\nimage:eraserhd.png[eraserhd,role=\"left\",width=310,link=\"https://github.com/eraserhd\"]\nimage:ericdallo.png[ericdallo,role=\"left\",width=310,link=\"https://github.com/ericdallo\"]\nimage:green-coder.png[green-coder,role=\"left\",width=310,link=\"https://github.com/green-coder\"]\nimage:jespera.png[jespera,role=\"left\",width=310,link=\"https://github.com/jespera\"]\nimage:mainej.png[mainej,role=\"left\",width=310,link=\"https://github.com/mainej\"]\nimage:martinklepsch.png[martinklepsch,role=\"left\",width=310,link=\"https://github.com/martinklepsch\"]\nimage:mhuebert.png[mhuebert,role=\"left\",width=310,link=\"https://github.com/mhuebert\"]\nimage:rgkirch.png[rgkirch,role=\"left\",width=310,link=\"https://github.com/rgkirch\"]\nimage:stathissideris.png[stathissideris,role=\"left\",width=310,link=\"https://github.com/stathissideris\"]\nimage:swannodette.png[swannodette,role=\"left\",width=310,link=\"https://github.com/swannodette\"]\n--\n// AUTO-GENERATED:CONTRIBUTORS-END\n\n=== Founders\n// Founders updated by script, do not edit\n// AUTO-GENERATED:FOUNDERS-START\n:imagesdir: ./doc/generated/contributors\n[.float-group]\n--\nimage:rundis.png[rundis,role=\"left\",width=310,link=\"https://github.com/rundis\"]\nimage:xsc.png[xsc,role=\"left\",width=310,link=\"https://github.com/xsc\"]\n--\n// AUTO-GENERATED:FOUNDERS-END\n\n=== Current maintainers\n// Maintainers updated by script, do not edit\n// AUTO-GENERATED:MAINTAINERS-START\n:imagesdir: ./doc/generated/contributors\n[.float-group]\n--\nimage:borkdude.png[borkdude,role=\"left\",width=310,link=\"https://github.com/borkdude\"]\nimage:lread.png[lread,role=\"left\",width=310,link=\"https://github.com/lread\"]\n--\n// AUTO-GENERATED:MAINTAINERS-END\n\n== link:CHANGELOG.adoc[Changes]\n\n== Licences\nWe honor the original MIT license from link:LICENSE[rewrite-clj v0].\n\nCode has been merged/adapted from:\n\n* https://github.com/clj-commons/rewrite-cljs/blob/master/LICENSE[rewrite-cljs which has an MIT license]\n* https://github.com/clojure/clojure/blob/master/src/clj/clojure/zip.clj[clojure zip] which is covered by https://clojure.org/community/license[Eclipse Public License 1.0]\n",
     :cljdoc.doc/type :cljdoc/asciidoc,
     :slug "readme",
     :cljdoc.doc/contributors ("lread" "Lee Read")}}
   {:title "Changelog",
    :attrs
    {:cljdoc.doc/source-file "CHANGELOG.adoc",
     :cljdoc/asciidoc
     "// NOTE: release workflow automatically updates \"unreleased\" headers in this file\n= Changelog\n:toc:\n:toclevels: 1\n\n== rewrite-clj v1\n\nFor a list of breaking changes see link:#v1-breaking[breaking changes].\n\n// Release workflow will:\n// - Fail when:\n//   - there is no \"== Unreleased\" section header\n//   - or the section contains no descriptive text\n// - Replace the Unreleased section header with actual release version\n// - Prepend a new Unreleased section header\n\n=== Unreleased\n\n=== v1.0.767-alpha\n\n* fix `:end-row` `:end-col` metadata for root node https://github.com/clj-commons/rewrite-clj/issues/173[#173] - thanks @mainej!\n* docs:\n** user guide correction, thanks @rgkirch!\n** zip API docstrings now clearer about coercion https://github.com/clj-commons/rewrite-clj/issues/168[#168]\n\nhttps://github.com/clj-commons/rewrite-clj/compare/v1.0.699-alpha\\...v1.0.767-alpha[Gritty details of changes for this release]\n\n=== v1.0.699-alpha\n\n* team update: @borkdude is now officially a co-maintainer of rewrite-clj! Woot woot!\n* rewrite-clj v1 minimum Clojure version is now v1.8.0 (was formerly v1.9.0) https://github.com/clj-commons/rewrite-clj/issues/164[#164]\n* internal rewrite-clj developer facing:\n** Migrate from `depstar` to `tools.build`\n\nhttps://github.com/clj-commons/rewrite-clj/compare/v1.0.682-alpha\\...v1.0.699-alpha[Gritty details of changes for this release]\n\n=== v1.0.682-alpha\n\n* update clojure tools.reader dependency to v1.3.6\n* a zipper created with both a custom `:auto-resolve` option and the `:track-position?` `true` option will now acknowledge and use the custom `:auto-resolve` https://github.com/clj-commons/rewrite-clj/issues/159[#159]\n* a Cons now coerces to a rewrite-clj list node https://github.com/clj-commons/rewrite-clj/issues/160[#160] https://github.com/clj-commons/rewrite-clj/issues/161[#161] (thanks @borkdude!)\n* internal rewrite-clj developer facing:\n** Now also linting rewrite-clj sources with Eastwood https://github.com/clj-commons/rewrite-clj/pull/158[#158] (thanks @vemv!)\n\nhttps://github.com/clj-commons/rewrite-clj/compare/v1.0.644-alpha\\...v1.0.682-alpha[Gritty details of changes for this release]\n\n=== v1.0.644-alpha\n\n* user guide and docstrings better explain `sexpr-able?` and what invalid code elements rewrite-clj parses https://github.com/clj-commons/rewrite-clj/issues/150[#150] https://github.com/clj-commons/rewrite-clj/issues/151[#151]\n* rewrite-clj now exports clj-kondo config for its public API https://github.com/clj-commons/rewrite-clj/issues/146[#146]\n* ClojureScript compiler should no longer emit invalid deprecated warnings https://github.com/clj-commons/rewrite-clj/issues/153[#153]\n* Internal rewrite-clj developer facing:\n** Switched from babashka scripts to babashka tasks, developer guide updated accordingly\n\nhttps://github.com/clj-commons/rewrite-clj/compare/v1.0.605-alpha\\...v1.0.644-alpha[Gritty details of changes for this release]\n\n=== v1.0.605-alpha\n\n* rewrite-clj now understands the `#!` comment, a construct often used in scripts https://github.com/clj-commons/rewrite-clj/issues/145[#145]\n\nhttps://github.com/clj-commons/rewrite-clj/compare/v1.0.594-alpha\\...v1.0.605-alpha[Gritty details of changes for this release]\n\n=== v1.0.594-alpha\n\n* rewrite-clj now explicitly depends on the minimum version of Clojure required, v1.9.0, rather than v1.10.3 https://github.com/clj-commons/rewrite-clj/issues/142[#142]\n\nhttps://github.com/clj-commons/rewrite-clj/compare/v1.0.591-alpha\\...v1.0.594-alpha[Gritty details of changes for this release]\n\n=== v1.0.591-alpha\n\n* namespaced map should allow all Clojure whitespace between prefix and map https://github.com/clj-commons/rewrite-clj/issues/140[#140]\n* Beef up docs on node creation https://github.com/clj-commons/rewrite-clj/issues/97[#97]\n* Describe subedit in docs https://github.com/clj-commons/rewrite-clj/issues/111[#111]\n\nhttps://github.com/clj-commons/rewrite-clj/compare/v1.0.579-alpha\\...v1.0.591-alpha[Gritty details of changes for this release]\n\n=== v1.0.579-alpha\n\n* Release workflow now creates a GitHub release\n\nhttps://github.com/clj-commons/rewrite-clj/compare/v1.0.574-alpha\\...v1.0.579-alpha[Gritty details of changes for this release]\n\n=== v1.0.574-alpha\n\n* Docs now render on cljdoc https://github.com/clj-commons/rewrite-clj/issues/138[#138]\n\nhttps://github.com/clj-commons/rewrite-clj/compare/v1.0.572-alpha\\...v1.0.574-alpha[Gritty details of changes for this release]\n\n=== v1.0.572-alpha\n\nIf you wish, you can read nitty gritty details on link:doc/design/01-merging-rewrite-clj-and-rewrite-cljs.adoc[merging rewrite clj v0 and rewrite cljs].\nWhat follows is a summary of changes.\n\nhttps://github.com/clj-commons/rewrite-clj/compare/v0.6.1\\...v1.0.572-alpha[Gritty details of changes for this release]\n\n==== New\n* A new home under clj-commons.\nThanks to @xsc, rewrite-clj will also retain its same maven coordinates on Clojars making for a seamless upgrade path for rewrite-clj v0 users.\n* Now supports ClojureScript, merging in rewrite-cljs specific functionality.\nFrustrations like not having namespace map support and differences from rewrite-clj, like whitespace parsing, should now be things of the past.\nRewrite-cljs users migrating to rewrite-clj v1 are now at, and will remain at, feature parity with rewrite-clj.\n* Additions to the public API:\n** `rewrite-clj.paredit` - carried over from rewrite-cljs, an API for structured editing of Clojure forms\n** `rewrite-clj.zip`\n*** Exposes the following (accidentally?) omitted functions:\n**** `append-child*`\n**** `insert-newline-left`\n**** `insert-newline-right`\n**** `insert-space-left`\n**** `insert-space-right`\n**** `subzip`\n*** Adds functions from rewrite-cljs\n**** `find-last-by-pos` - navigate to node at row/col\n**** `find-tag-by-pos` - navigate to node with tag at row/col\n**** `position-span` - returns start and end row/col for a form\n**** `remove-preserve-newline` - same as remove but preserves newlines\n*** Adds namespaced element support functions\n**** `reapply-context` - reapplies (or removes) map qualifier node context from keywords and symbols\n**** zipper creation functions now optionally accept an auto-resolve function to support sexpr on namespaced element nodes\n*** Other additions\n**** `sexpr-able?` - return true if `sexpr` is supported for current node\n** `rewrite-clj.node`\n*** Additions:\n**** `keyword-node?` - returns true if form is a rewrite-clj keyword node\n**** `map-qualifier-node` - to create a namespaced map's map qualifier node manually\n**** `map-context-apply` - apply map qualifier to keyword or symbol\n**** `map-context-clear` - remove map qualifier from keyword or symbol\n**** `node?` - returns true if a form is a rewrite-clj created node\n**** `sexpr-able?` - return true if `sexpr` is supported for node\n**** `symbol-node?` - return true if node is a rewrite-clj symbol node\n*** Updates:\n**** `sexpr`, `sepxrs` and `child-sexprs` - now optionally take an options argument to specify an auto-resolve function\n* Many updates to docs and docstrings\n\n==== Fixes\n* OS specific end of line variants in source now normalized consistently to `\\newline` https://github.com/clj-commons/rewrite-clj/issues/93[#93]\n* Postwalk on larger source file no longer throws StackOverflow https://github.com/clj-commons/rewrite-clj/issues/69[#69]\n* Postwalk now walks in post order https://github.com/clj-commons/rewrite-clj/issues/123[#123]\n* We now preserve newline at end of file https://github.com/clj-commons/rewrite-clj/issues/121[#121]\n* Support for garden style selectors https://github.com/clj-commons/rewrite-clj/issues/92[#92]\n* Correct and document prefix and suffix functions https://github.com/clj-commons/rewrite-clj/issues/91[#91]\n* Positional metadata added by the reader is elided on coercion https://github.com/clj-commons/rewrite-clj/issues/90[#90]\n* Can now read `\\\\##Inf`, `##-Inf` and `##Nan` https://github.com/clj-commons/rewrite-clj/issues/75[#75]\n* Ensure that all rewrite-clj nodes coerce to themselves\n* Strings now coerce to string nodes (instead of to token nodes) https://github.com/clj-commons/rewrite-clj/issues/126[#126]\n* Regexes now coerce to regex nodes https://github.com/clj-commons/rewrite-clj/issues/128[#128]\n* Regex node now:\n** converts correctly to string https://github.com/clj-commons/rewrite-clj/issues/127[#127]\n** reports correct length https://github.com/clj-commons/rewrite-clj/issues/130[#130]\n* Moved from potemkin import-vars to static template based version https://github.com/clj-commons/rewrite-clj/issues/98[#98]:\n** Avoids frustration/mysteries of dynamic import-vars for users and maintainers\n** Argument names now correct in API docs (some were gensymed previously)\n** Also turfed use of custom version of potemkin defprotocol+ in favor of plain old defprotocol.\nPerhaps I missed something, but I did not see the benefit of defprotocol+ for rewrite-clj v1.\n\n==== Internal changes (developer facing)\n* Tests updated to hit public APIs https://github.com/clj-commons/rewrite-clj/issues/106[#106]\n* ClojureScript tests, in addition to being run under node, are now also run under chrome-headless, shadow-cljs, and for self-hosted ClojureScript, under planck.\n* Now testing rewrite-clj compiled under GraalVM native-image in two variants:\n** In a pure form where library and tests are compiled\n** Via sci where a sci exposed rewrite-clj is compiled, then tests are interpreted.\n* Now automatically testing rewrite-clj against popular libs https://github.com/clj-commons/rewrite-clj/issues/124[#124]\n* Now linting source with clj-kondo\n* Code coverage reports now generated for Clojure unit test run and sent to codecov.io\n* Can now preview for cljdoc locally via `script/cljdoc_preview.clj`\n* API diffs for rewrite-clj v1 vs rewrite-clj v0 vs rewrite-cljs can be generated by `script/gen_api_diffs.clj`\n* Contributors are acknowledged in README and updated via `script/update_readme.clj`\n* Doc code blocks are automatically tested via `script/doc_tests.clj` https://github.com/clj-commons/rewrite-clj/issues/100[#100]\n* Some tooling and tech replaced:\n** All scripts are written in Clojure and run via Babashka or Clojure.\n** Switched from leiningen `project.clj` to Clojure tools CLI `deps.edn`\n** Moved from CommonMark to AsciiDoc for docs\n** Moved from publishing docs locally via codox to publishing to cljdoc\n** Now using CommonMark in docstrings (they render nicely in cljdoc)\n** Moved from TravisCI to GitHub Actions where, in addition to Linux, we also test under macOS and Windows\n** Adopted kaocha for Clojure testing, stuck with doo for regular ClojureScript testing, and added support for ClojureScript watch testing with figwheel main.\n** Potemkin dynamic import-vars replaced with static code generation solution\n* Added GitHub issue templates\n* Fixed a generative test sporadic failure https://github.com/clj-commons/rewrite-clj/issues/88[#88]\n\n[#v1-breaking]\n=== v1 Breaking Changes\n\n// Release workflow will:\n// - If an \"=== Unreleased Breaking Changes\" section header exists here:\n//   - Fail when the section contains no descriptive text\n//   - Else replace the Unreleased Breaking Changes section header with actual release version\n// If you have no breaking changes, don't include an Unreleased Breaking Changes header\n\n==== v1.0.572-alpha\n\n* Minimum Clojure version bumped from v1.5.1 to v1.9\n* Minimum ClojureScript version (from whatever is was for rewrite-cljs) bumped to v1.10\n* Minimum Java version bumped from v7 to v8\n* Keyword node field `namespaced?` renamed to `auto-resolved?`\n* Now using `ex-info` for explicitly raised exceptions\n* Rewrite-cljs positional support migrated to rewrite-clj's positional support\n* Namespaced element support reworked\n** v1 changes do not affect node traversal of the namespaced map, number and order of children remain the same.\n** Namespace map prefix, is now stored in a namespaced map qualifier node.\n*** Prior to v1, the prefix was parsed to a keyword-node.\n*** Let's look at what interesting node API functions will return for the prefix node in the following namespaced maps.\nAssume we have parsed the example and traversed down to the prefix node. +\nFor example via: `(-> \"#:prefix{:a 1}\" z/of-string z/down z/node)`. +\n+\n|===\n| node API call | rewrite-clj | `#:prefix{:a 1}` |  `#::alias{:a 1}` | `#::{:a 1}`\n\n.2+| `string` +\nis unchanged\n| v1\n.2+| `\":prefix\"`\n.2+| `\"::alias\"`\n| `\"::\"`\n| v0\na| * throws on parse\n\n.2+| `tag` +\nis different\n\n| v1\n3+| `:map-qualifier`\n\n| v0\n2+| `:token`\na| * throws on parse\n\n.2+| `inner?` +\nstill indicates that the node is a leaf node and has no children\n\n| v1\n3+| `false`\n| v0\n2+| `false`\na| * throws on parse\n\n| `sexpr`\n4+| <read on below for discussion on sexpr>\n\n|===\n** Namespaced element `sexpr` support now relies on user specifiable auto-resolve function to resolve qualifiers\n*** Unlike rewrite-clj v0, the default auto-resolve behaviour never consults `\\*ns*`\n*** An sexpr for keyword node `::alias/foo` no longer returns `:alias/foo` (this could be considered a bug fix, but if your code is expecting this, then you'll need to make changes)\n** The following namespaced element `sexpr` examples assume:\n*** `\\*ns*` is bound to `user` namespace (important only for rewrite-clj v0):\n*** We are using the default auto-resolve function for rewrite-clj v1\n*** That you will refer to the link:doc/01-user-guide.adoc#namespaced-elements[User Guide] for more detailed examples of v1 behaviour\n+\n[%header,cols=\"19,27,27,27\"]\n|===\n| source\n| sexpr rewrite-clj v1\n| sexpr rewrite-clj v0\n| sexpr rewrite-cljs\n\n| qualified keyword +\n`:prefix/foo`\n3+| no change\n\n| current-ns qualified keyword +\n`::foo`\n| `:?\\_current-ns_?/foo`\n| `:user/foo`\na| * throws on sexpr\n\n| ns-alias qualified keyword +\n`::alias/foo`\n| `:??\\_alias_??/foo`\n| `:alias/foo`\n| `:alias/foo`\n\n| qualified map +\n`#:prefix{:a 1}`\n| `#:prefix{:a 1}`\n| `#:prefix{:a 1}`\n| `(read-string \"#:prefix{:a 1}\")`\n\n| current-ns qualified map +\n`#::{:b 2}`\n| `#:?\\_current-ns_?{:b 2}`\na| * throws on parse\na| * throws on parse\n\n| ns-alias qualified map +\n`#::alias{:c 3}`\n| `#:??\\_alias_??{:c 3}`\na| * throws unless namespace alias `alias` has been loaded in `\\*ns*`\n* if `alias` in `*ns*` resolves to `my.ns1`: +\n`#:my.ns1{:c 3}`\n| `(read-string \"#::alias{:c 3}\")`\n\n|===\n\n*** Let's dig into prefix and key sub-nodes of a namespaced map to explore v1 differences:\n+\n[cols=\"40,30,30\"]\n|===\n| Description | rewrite-clj v1 | rewrite-clj v0 and rewrite-cljs\n\n3+a| prefix (aka qualifier)\n\na|qualified\n[source,clojure]\n----\n(-> \"#:prefix{:a 1}\"\n    z/of-string\n    z/down z/sexpr)\n----\n| `prefix`\n| `:prefix`\n\na| current-ns qualified\n[source,clojure]\n----\n(-> \"#::{:b 2}\"\n    z/of-string\n    z/down z/sexpr)\n----\n| `?\\_current-ns_?`\na| * throws on parse\n\na| ns-alias qualified\n[source,clojure]\n----\n(-> \"#::alias{:c 2}\"\n     z/of-string\n     z/down z/sexpr)\n----\na| `??\\_alias_??`\na| `:user/alias`\n\n* rewrite-cljs throws\n\n3+a| key\na| qualified\n[source,clojure]\n----\n(-> \"#:prefix{:a 1}\"\n    z/of-string\n    z/down z/right z/down z/sexpr)\n----\n| `:prefix/a`\n| `:a`\n\na| current-ns qualified\n[source,clojure]\n----\n(-> \"#::{:b 2}\"\n    z/of-string\n    z/down z/right z/down z/sexpr)\n----\n|`:?_current-ns_?/b`\na| * throws on parse\n\na| ns-alias qualified\n[source,clojure]\n----\n(-> \"#::alias{:c 3}\"\n    z/of-string\n    z/down z/right z/down z/sexpr)\n----\n|`:??\\_alias_??/c`\n|`:c`\n\n|===\n* Potentially breaking\n** Some http://rundis.github.io/blog/2015/clojurescript_performance_tuning.html[rewrite-cljs optimizations] were dropped in favor of a single code base.\nIf performance for rewrite-clj v1 for ClojureScript users is poor with today's ClojureScript, we shall adapt.\n** Deleted unused `rewrite-clj.node.indent` https://github.com/clj-commons/rewrite-clj/issues/116[#116]\n** Deleted redundant `rewrite-clj.parser.util` as part of https://github.com/clj-commons/rewrite-clj/issues/93[#93].\nIf you were using this internal namespace you can opt to switch to, the also internal, `rewrite-clj.reader` namespace.\n\n== rewrite-clj v0\n\n=== 0.6.0\n\n* **BREAKING**: uses a dedicated node type for regular expressions. (see #49 –\n  thanks @ChrisBlom!)\n* implement `NodeCoercable` for `nil`. (set #53 – thanks @jespera!)\n\n=== 0.5.2\n\n* fixes parsing of splicing reader conditionals `#?@...`. (see #48)\n\n=== 0.5.1\n\n* fixes parsing of multi-line regular expressions. (see #51)\n\n=== 0.5.0\n\n* **BREAKING**: commas will no longer be parsed into `:whitespace` nodes but\n  `:comma`. (see #44 - thanks @arrdem!)\n* **BREAKING**: `position` will throw exception if not used on rewrite-clj\n  custom zipper. (see #45)\n* **BREAKING**: drops testing against JDK6.\n* **DEPRECATED**:\n** `append-space` in favour of `insert-space-right`\n** `prepend-space` in favour of `insert-space-left`\n** `append-newline` in favour of `insert-newline-right`\n** `prepend-newline` in favour of `insert-newline-left`\n* fix insertion of nodes in the presence of existing whitespace. (see #33, #34 -\n  thanks @eraserhd!)\n* `edn` and `edn*` now take a `:track-position?` option that activates a custom\n  zipper implementation allowing `position` to be called on. (see #41, #45 -\n  thanks @eraserhd!)\n* fix parsing of whitespace, e.g. `<U+2028>`. (see #43)\n* fix serialization of `integer-node`s. (see #37 - thanks @eraserhd!)\n* adds `insert-left*` and `insert-right*` to facade.\n* generative tests. (see #41 - thanks @eraserhd!)\n\n=== 0.4.13\n\n_Development has branched off, using the `0.4.x` branch_\n\n* upgrades dependencies.\n* fixes a compatibility issue when running 'benedekfazekas/mranderson' on\n  a project with both 'rewrite-clj' and 'potemkin'.\n* switch to Clojure 1.8.0 as base Clojure dependency; mark as \"provided\".\n* switch to MIT License.\n* drop support for JDK6.\n\n=== 0.4.12\n\n* drop `fast-zip` and `potemkin` dependencies. (see #26)\n\n=== 0.4.11\n\n* fix handling of symbols with boundary character inside. (see #25)\n\n=== 0.4.10\n\n* fix handling of symbols with trailing quote, e.g. `x'`. (see #24)\n\n=== 0.4.9\n\n* fix `replace-children` for `:uneval` nodes. (see #23)\n* add `rewrite-clj.zip/postwalk`. (see #22)\n\n=== 0.4.8\n\n* allow parsing of aliased keywords, e.g. `::ns/foo`. (see #21)\n\n=== 0.4.7\n\n* fixes zipper creation over whitespace-/comment-only data. (see #20)\n\n=== 0.4.6\n\n* fixes parsing of empty comments. (see #19)\n\n=== 0.4.5\n\n* fixes parsing of comments that are at the end of a file without linebreak. (see #18)\n\n=== 0.4.4\n\n* upgrades dependencies.\n* add `rewrite-clj.zip/child-sexprs` to public API.\n\n=== 0.4.3\n\n* fix parsing of backslash `\\\\` character. (see #17)\n\n=== 0.4.2\n\n* fix `:fn` nodes (were `printable-only?` but should actually create an s-sexpression).\n* fix `assert-sexpr-count` to not actually create the s-expressions.\n\n=== 0.4.1\n\n* fixes infinite loop when trying to read a character.\n\n=== 0.4.0\n\n* **BREAKING** `rewrite-clj.zip.indent` no longer usable.\n* **BREAKING** node creation/edit has stricter preconditions (e.g. `:meta` has to\n  contain exactly two non-whitespace forms).\n* **BREAKING** moved to a type/protocol based implementation of nodes.\n* fix radix support. (see #13)\n* fix handling of spaces between certain forms. (see #7)\n* add node constructor functions.\n* add `child-sexprs` function.\n\n=== 0.3.12\n\n* fix `assoc` on empty map. (see #16)\n\n=== 0.3.11\n\n* drop tests for Clojure 1.4.0.\n* fix behaviour of `leftmost`.\n* upgrade to fast-zip 0.5.2.\n\n=== 0.3.10\n\n- fix behaviour of `next` and `end?`.\n- fix prewalk.\n- add row/column metadata.\n\n=== 0.3.9\n\n* add `end?`.\n* allow access to children of quoted forms. (see #6)\n* fix children lookup for zipper (return `nil` on missing children). (see #5)\n\n=== 0.3.8\n\n* add `:uneval` element type (for `#_form` elements).\n* fix `estimate-length` for multi-line strings.\n\n=== 0.3.7\n\n* fix zipper creation from file.\n\n=== 0.3.6\n\n* upgrade dependencies.\n* fix file parser (UTF-8 characters were not parsed correctly, see #24@xsc/lein-ancient).\n\n=== 0.3.5\n\n* upgrade dependencies.\n* cleanup dependency chain.\n\n=== 0.3.4\n\n* upgrade dependencies.\n\n=== 0.3.3\n\n* Bugfix: parsing of a variety of keywords threw an exception.\n\n=== 0.3.2\n\n* Bugfix: `:1.4` and others threw an exception.\n\n=== 0.3.1\n\n* added namespaced keywords.\n\n=== 0.3.0\n\n* added token type `:newline` to handle linebreak characters.\n* `rewrite-clj.zip/edn` wraps everything into `[:forms ...]` node, but the initial location\n  is the node passed to it.\n* new functions in `rewrite-clj.zip.core`:\n** `length`\n** `move-to-node`\n** `edit->>`, `edit-node`\n** `subedit->`, `subedit->>`, `edit-children`\n** `leftmost?`, `rightmost?`\n* new functions in `rewrite-clj.zip.edit`:\n** `splice-or-remove`\n** `prefix`, `suffix` (formerly `rewrite-clj.zip.utils`)\n* `rewrite-clj.zip.edit/remove` now handles whitespace appropriately.\n* indentation-aware modification functions in `rewrite-clj.zip.indent`:\n** `indent`\n** `indent-children`\n** `replace`\n** `edit`\n** `insert-left`\n** `insert-right`\n** `remove`\n** `splice`\n* fast-zip utility functions in `rewrite-clj.zip.utils`\n\n=== 0.2.0\n\n* added more expressive error handling to parser.\n* added multi-line string handling (node type: `:multi-line`)\n* new functions in `rewrite-clj.printer`:\n** `->string`\n** `estimate-length`\n* new functions in `rewrite-clj.zip`:\n** `of-string`, `of-file`\n** `print`, `print-root`\n** `->string`, `->root-string`\n** `append-space`, `prepend-space`\n** `append-newline`, `prepend-newline`\n** `right*`, `left*`, ... (delegating to `fast-zip.core/right`, ...)\n* new token type `:forms`\n* new functions in `rewrite-clj.parser`:\n** `parse-all`\n** `parse-string-all`\n** `parse-file-all`\n* zipper utility functions in `rewrite-clj.zip.utils` (able to handle multi-line strings):\n** `prefix`\n** `suffix`\n\n=== 0.1.0\n\n* Initial Release\n",
     :cljdoc.doc/type :cljdoc/asciidoc,
     :slug "changelog",
     :cljdoc.doc/contributors
     ("lread" "GitHub Actions" "github-actions[bot]" "Lee Read")}}
   {:title "User Guide",
    :attrs
    {:cljdoc.doc/source-file "doc/01-user-guide.adoc",
     :cljdoc/asciidoc
     "// NOTE: release workflow automatically updates rewrite-clj versions in this file\n= User Guide\n:cljdoc-host: https://cljdoc.org\n:cljdoc-api-url: {cljdoc-host}/d/rewrite-clj/rewrite-clj/CURRENT/api\n:toclevels: 5\n:toc:\n\n== Introduction\nRewrite-clj is a library that can read, update and write Clojure, ClojureScript and https://github.com/edn-format/edn[EDN] source code while preserving whitespace and comments.\n\n=== Interesting Alternatives\nIf rewrite-clj is not your cup of tea, consider following alternatives:\n\n|===\n| Project | Parsing? | Writing? | Whitespace Preserving? | Includes Element Row/Col?\n\n| https://github.com/carocad/parcera[parcera]\n| yes\n| yes\n| yes\n| yes\n\n| https://github.com/borkdude/edamame[edamame]\n| yes\n| no\n| no\n| yes\n\n|===\n\n=== History\nhttps://github.com/xsc[@xsc] created https://github.com/xsc/rewrite-clj[rewrite-clj] in 2013.\nIts original use was to upgrade dependencies in https://leiningen.org[lein] project.clj files.\nThe library quickly took off in popularity and is the default choice for modifying Clojure/EDN from Clojure.\n\nhttps://github.com/rundis[@rundis] created rewrite-cljs in 2015 to match the features of rewrite-clj for ClojureScript developers.\nIt was originally used for refactoring support in https://github.com/LightTable/LightTable[Light Table].\nIn January of 2019, @rundis graciously https://github.com/clj-commons/rewrite-cljs[transferred rewrite-cljs to clj-commons].\n\nSeeing an opportunity to give back to the Clojure community, in 2019 https://github.com/lread[@lread], with guidance and help from many friendly Clojurians, started work on rewrite-cljc.\nIn December of 2020, @xsc graciously https://github.com/clj-commons/rewrite-clj[tranferred rewrite-clj to clj-commons].\nSo rewrite-cljc is now dead, long live rewrite-clj!\n\n[NOTE]\n====\nTo distinguish the the versions of rewrite-clj, I'll use:\n\n* rewrite-clj v0 to refer to the classic\n* rewrite-clj v1 to refer to the reboot\n\nWhen the distinction is unimportant, I'll simply use rewrite-clj.\n====\n\nThe goal of rewrite-clj v1 is to provide a thoughtfully maintained feature-complete library that can be used from either Clojure or ClojureScript.\nWhile merging rewrite-clj v0 and rewrite-cljs to create rewrite-clj v1 was not trivial, the real hard work was done over many years in rewrite-clj v0 and rewrite-cljs under the leadership of @xsc and @rundis (thanks guys!).\nRead link:design/01-merging-rewrite-clj-and-rewrite-cljs.adoc[Merging rewrite-clj and rewrite-cljs] for details on the merge.\n\n=== Upgrading from rewrite-clj v0 and/or rewrite-cljs\nThanks to @xsc's transfer of rewrite-clj to clj-commons we'll continue on with the rewrite-clj namespace and clojars deploy target.\n\nTo upgrade to rewrite-clj v1, update your project dependencies.\nIf you were using both rewrite-cljs and rewrite-clj v0 in your project you can now drop the rewrite-cljs dependency.\n\nRewrite-clj unit tests are run against the current version of ClojureScript and Clojure versions >= v1.8.0.\nWe recommend that while bumping your rewrite-clj dependency to v1, that you also bump your Clojure and ClojureScript dependencies to current official releases.\n\nThe most notable breaking changes from rewrite-clj v0 relate to handling of namespaced elements:\n\n* Namespaced map handling was incomplete in rewrite-clj, has been reworked a bit and now supports namespaced symbols\n* An `sexpr` on a namespaced key or symbol should now work even when navigating down to the key node\n* An `sexpr` that involves auto resolve never consults `\\*ns*` you can plugin your own auto-resolve behavior, see link:#namespaced-elements[namespaced elements]\n\nNeed to know more? link:../CHANGELOG.adoc[See the change log].\n\n=== Conventions\nAs is a common convention, example code shows results of expression evaluation like so:\n\n[source, clojure]\n----\n(+ 1 2 3)\n;; => 6\n----\n\nWe show distinctions between Clojure and Clojurescript results like so:\n[source, clojure]\n----\n\\c\n;; =clj=> \\c\n;; =cljs=> \"c\"\n----\n\nAnd we show output like so:\n[source, clojure]\n----\n(println \"hello there\")\n;; =stdout=>\n; hello there\n----\n\n=== Terminology\n\nRewrite-clj has an `sexpr` function that returns Clojure forms.\nOur usage of the terms \"s-expression\" and \"forms\" might be less nuanced than some formal definitions.\nI think we are in line with https://www.braveclojure.com/do-things/#Forms[Clojure for the Brave and True's description of forms].\nTo us, a Clojure form is any parsed (but not evaluated) Clojure as it would be returned by the Clojure reader.\n\n[#nodes]\n=== Rewrite-clj Nodes\n\nRewrite-clj parses Clojure source into rewrite-clj nodes.\n\nWhile reviewing the following example, it helps to remember that Clojure source is data.\n\nimage::introduction-parsed-nodes.png[introduction parsed nodes]\n\nEach node carries the positional metadata `:row`, `:col`, `:end-row` and `:end-col`.\nThe positional data is 1-based and `:end-col` is exclusive.\n\nYou can link:#parser-api[parse] and work with link:#node-api[nodes] directly or take advantage of the power of the link:#zip-api[zip API].\n\nRewrite-clj offers easy conversion from rewrite-clj nodes to Clojure forms and back.\nThis is convenient but does come with some caveats.\nAs you get more experienced with rewrite-clj, you will want to review link:#sexpr-nuances[sexpr nuances].\n\n== Project Setup\n\n=== Tools Deps\nInclude the following dependency in your `deps.edn` file:\n//:test-doc-blocks/skip\n// NOTE: the version in this snippit is automatically updated by our release workflow\n[source,clojure]\n----\nrewrite-clj/rewrite-clj {:mvn/version \"1.0.767-alpha\"}\n----\n\n=== Leiningen\nInclude the following dependency in your `project.clj` file:\n//:test-doc-blocks/skip\n// NOTE: the version in this snippit is automatically update by our release workflow\n[source,clojure]\n----\n[rewrite-clj/rewrite-clj \"1.0.767-alpha\"]\n----\n\n== Rewrite-clj APIs\nThere are 4 public API namespaces:\n\n. `rewrite-clj.zip`\n. `rewrite-clj.parser`\n. `rewrite-clj.node`\n. `rewrite-clj.paredit`\n\n[#zip-api]\n=== Zip API\nTraverse and modify Clojure/ClojureScript/EDN.\nThis is considered the main rewrite-clj API and might very well be all you need.\n\nYou'll optionally use the link:#node-api[node API] on the rewrite-clj nodes in the zipper.\n\n==== A Brief Introduction to Zippers\n\n[TIP]\n====\nRewrite-clj uses a customized version of\nhttps://clojure.github.io/clojure/clojure.zip-api.html[Clojure's clojure.zip].\nIf you are not familiar with zippers, you may find the following resources helpful:\n\n* https://clojure.org/reference/other_libraries#_zippers_functional_tree_editing_clojure_zip[Clojure overview of zippers]\n* https://lambdaisland.com/blog/2018-11-26-art-tree-shaping-clojure-zip[Arne Brasseur - The Art of Tree Shaping with Clojure Zippers]\n* https://tbaldridge.pivotshare.com/media/zippers-episode-1/11348/feature?t=0[Tim Baldrige - PivotShare - Series of 7 Videos on Clojure Zippers]\n====\n\nAt a conceptual level, the rewrite-clj zipper holds:\n\n* a tree of rewrite-clj nodes representing your parsed Clojure source\n* your current location within the zipper\n\nBecause the zipper holds both the tree and your location within the tree, its variable is commonly named `zloc`.\nThe zipper is immutable, as such, location changes and node modifications are always returned in a new zipper.\n\nYou may want to refer to link:#nodes[rewrite-clj nodes] while reviewing this introductory example:\n\n[source,clojure]\n----\n(require '[rewrite-clj.zip :as z])\n\n;; define some test data\n(def data-string\n\"(defn my-function [a]\n  ;; a comment\n  (* a 3))\")\n\n;; parse code to nodes, create a zipper, and navigate to the first non-whitespace node\n(def zloc (z/of-string data-string))\n\n;; explore what we've parsed\n(z/sexpr zloc)\n;; => (defn my-function [a] (* a 3))\n(-> zloc z/down z/right z/node pr)\n;; =stdout=>\n; <token: my-function>\n(-> zloc z/down z/right z/sexpr)\n;; => my-function\n\n;; rename my-function to my-function2 and return resulting s-expression\n(-> zloc\n    z/down\n    z/right\n    (z/edit (comp symbol str) \"2\")\n    z/up\n    z/sexpr)\n;; => (defn my-function2 [a] (* a 3))\n\n;; rename my-function to my-function2 and return updated string from root node\n(-> zloc\n    z/down\n    z/right\n    (z/edit (comp symbol str) \"2\")\n    z/root-string\n    println)\n;; =stdout=>\n; (defn my-function2 [a]\n;   ;; a comment\n;   (* a 3))\n\n----\n\n[TIP]\n====\nThe zip location movement functions (`right`, `left`, `up`, `down`, etc) skip over Clojure whitespace nodes and comment nodes.\nRemember that Clojure whitespace includes commas.\n\nIf you want to navigate over all nodes, use the `+*+` counterparts (`right*`, `left*`, `up*`, `down*`, etc).\n====\n\nSee link:{cljdoc-api-url}/rewrite-clj.zip[zip API docs].\n\n==== Finding Elements with the Zip API\n\nThe `rewrite-clj.zip` namespace includes find operations to navigate to locations of interest in your zipper.\nLet's assume you want to modify the following minimal `project.clj` by replacing the `:description` placeholder text with something more meaningful:\n\n//:test-doc-blocks/skip\n.project.clj snippet\n[source, clojure]\n----\n(defproject my-project \"0.1.0-SNAPSHOT\"\n  :description \"Enter description\")\n----\n\nMost find functions accept an optional location movement function.\nUse:\n\n* `rewrite-clj.zip/right` (the default) - to search sibling nodes to the right\n* `rewrite-clj.zip/left` to search siblings to left\n* `rewrite-clj.zip/next` for a depth-first tree search\n\n[source,clojure]\n----\n(require '[rewrite-clj.zip :as z])\n\n;; for sake of a runnable example we'll load from a string:\n(def zloc (z/of-string\n\"(defproject my-project \\\"0.1.0-SNAPSHOT\\\"\n  :description \\\"Enter description\\\")\"))\n\n;; loading from a file, looks like so:\n;; (def zloc (z/of-file \"project.clj\")) ;; <1>\n\n;; find defproject by navigating depth-first\n(def zloc-defproject (z/find-value zloc z/next 'defproject))\n;; verify that we are where we think we are\n(z/sexpr zloc-defproject)\n;; => defproject\n\n;; search right for :description and then move one node to the right ;; <2>\n(def zloc-desc (-> zloc-defproject (z/find-value :description) z/right))\n;; check that this worked\n(z/sexpr zloc-desc)\n;; => \"Enter description\"\n\n;; replace node at current location and return the result\n(-> zloc-desc (z/replace \"My first Project.\") z/root-string println)\n;; =stdout=>\n; (defproject my-project \"0.1.0-SNAPSHOT\"\n;   :description \"My first Project.\")\n----\n<1> reading from a file is only available from Clojure\n<2> Remember that while whitespace is preserved, it is automatically skipped during navigation.\n\n==== Familiar Functions for Updating Nodes with the Zip API\n\nThe zip API provides familiar ways to work with parsed Clojure data structures.\nIt offers some functions that correspond to the standard Clojure `seq` functions, for example:\n\n[source, clojure]\n----\n(require '[rewrite-clj.zip :as z])\n\n(def zloc (z/of-string \"[1\\n2\\n3]\"))\n(z/vector? zloc)\n;; => true\n(z/sexpr zloc)\n;; => [1 2 3]\n(-> zloc (z/get 1) z/node pr)\n;; =stdout=>\n; <token: 2>\n(-> zloc (z/assoc 1 5) z/sexpr)\n;; => [1 5 3]\n(->> zloc (z/map #(z/edit % + 4)) z/root-string)\n;; => \"[5\\n6\\n7]\"\n\n(def zloc (z/of-string \"{:a 10 :b 20}\"))\n(z/map? zloc)\n;; => true\n(-> zloc (z/get :b) z/node pr)\n;; =stdout=>\n; <token: 20>\n(-> zloc (z/assoc :b 42) z/sexpr)\n;; => {:b 42, :a 10}\n(->> zloc (z/map-vals #(z/edit % inc)) z/root-string)\n;; => \"{:a 11 :b 21}\"\n(->> zloc\n     (z/map-keys #(z/edit %\n                          (fn [v] (keyword \"prefix\" (name v))) ))\n     z/root-string)\n;; => \"{:prefix/a 10 :prefix/b 20}\"\n----\n\n// Targeted from docstrings\n[#sub-editing]\n==== Sub Editing with the Zip API\n\nSub editing allows you to effect changes to an isolated subtree (actually a sub zipper) while preserving your original location in the zipper\n\nWhen sub editing, your sub zipper is isolated to the current node and its children.\nThe sub zipper acts like, and is, a full zipper; `rewrite-clj.zip/end?` will return `true` when you have navigated to the end of the sub zipper.\n\nThis can be useful when you:\n\n* Are interested in restoring your location after digging down deep to make a change\n* Want to restrict your changes to a node and its children.\nIt can be helpful to bound your movement when using functions that also affect current location such as `rewrite-clj.zip/remove`.\n\n[source,Clojure]\n----\n(require '[rewrite-clj.zip :as z])\n\n;; A sample to illustrate\n(def zloc (z/of-string \"[a [b [c [d [e [f]]]]] g h]\"))\n\n;; ... and a little helper that navigates our location to the end node:\n(defn to-end [zloc]\n  (->> zloc\n       (iterate z/next)\n       (drop-while (complement z/end?))\n       first))\n\n;; ... and a little editor to show which node was hit:\n(defn update-at-loc [zloc]\n  (z/edit zloc #(symbol \"UPDATED\" (str %))))\n\n;; If we don't use a sub zipper our end node is h:\n(-> zloc\n    to-end\n    update-at-loc\n    z/root-string)\n;; => \"[a [b [c [d [e [f]]]]] g UPDATED/h]\"\n\n;; If we subedit on the first node in the vector, we are restricted to that node.\n;; In our case that node is a:\n(-> zloc\n    z/down\n    (z/subedit->\n     to-end\n     update-at-loc)\n    z/root-string)\n;; => \"[UPDATED/a [b [c [d [e [f]]]]] g h]\"\n\n;; If we subedit on the second node in the vector, we are restricted to that node.\n;; In our case that node is [b [c [d [f]]]] with subedit end node f\n(-> zloc\n    z/down\n    z/right\n    (z/subedit->\n     to-end\n     update-at-loc)\n    z/root-string)\n;; => \"[a [b [c [d [e [UPDATED/f]]]]] g h]\"\n\n;; To show our original location was preserved,\n;; after a subedit of the last node within the 2nd node in the vector,\n;; a movement right brings us to node g\n(-> zloc\n    z/down\n    z/right\n    (z/subedit->\n     to-end\n     (z/edit #(symbol \"UPDATED\" (str %))))\n    z/right\n    z/string)\n;; => \"g\"\n----\n\nThe zip API walk functions also isolate your work to the current node.\nLet's explore:\n\n[source,Clojure]\n----\n(require '[rewrite-clj.zip :as z])\n\n;; Let's contrive an example with multiple top level forms:\n(def zloc (z/of-string \"(def x 1) (def y [2 3 [4 [5]]])\"))\n\n;; Now let's add 100 to all numbers:\n(-> zloc\n    (z/postwalk (fn select [zloc] (number? (z/sexpr zloc)))\n                (fn visit [zloc] (z/edit zloc + 100)))\n    z/root-string)\n;; => \"(def x 101) (def y [2 3 [4 [5]]])\"\n\n;; Hmmm... what happened? Only the first number was affected.\n;; A new zipper automaticaly navigates to the first non-whitespace/non-comment node.\n;; In our example, this is node (def x 1).\n;; Our walk was isolated to current node (def x 1) so that's all that got updated\n\n;; We can adapt to walk all nodes with a movement up to the top level prior to our walk\n(-> zloc\n    z/up\n    (z/postwalk (fn select [zloc] (number? (z/sexpr zloc)))\n                (fn visit [zloc] (z/edit zloc + 100)))\n    z/root-string)\n;; => \"(def x 101) (def y [102 103 [104 [105]]])\"\n----\n\n// Targeted from docstrings\n[#position-tracking]\n==== Tracking Position with the Zip API\n\nIf you need to track the source row and column while reading and updating your zipper, create your zipper with `:track-position true` option.\nNote that the row and column are 1-based.\n\n[TIP]\n====\nIf you have no interest in the zipper updating positions when the zipper changes, but are still interested in node positions, you can use a zipper without `:track-positon true` option.\n\nRead up on positional metadata under link:#nodes[rewrite-clj nodes].\n====\n\n[source,clojure]\n----\n(require '[rewrite-clj.zip :as z])\n\n;; parse some Clojure into a position tracking zipper\n(def zloc (z/of-string\n           \"(defn sum-me\\n  \\\"Add 'em up!\\\"\\n  [a b c]\\n  (+ a\\n     c))\"\n           {:track-position? true}))\n\n;; let's see what that looks like printed out\n(println (z/root-string zloc))\n;; =stdout=>\n; (defn sum-me\n;   \"Add 'em up!\"\n;   [a b c]\n;   (+ a\n;      c))\n\n;; navigate to second z in zipper\n(def zloc-c (-> zloc\n            (z/find-value z/next '+)\n            (z/find-value z/next 'c)))\n\n;; check if current node is as expected\n(z/string zloc-c)\n;; => \"c\"\n\n;; examine position of second z, it is on 6th column of the 5th row\n(z/position zloc-c)\n;; => [5 6]\n\n;; insert new element b with indentation and alignment\n(def zloc-c2 (-> zloc-c\n                 (z/insert-left 'b)        ;; insert b to the left of c\n                 (z/left)                  ;; move to b\n                 (z/insert-newline-right)  ;; insert a newline after b\n                 (z/right)                 ;; move to c\n                 (z/insert-space-left 4))) ;; c has 1 space before it, add 4 more to line it up\n\n;; we should still be at c\n(z/string zloc-c2)\n\"c\"\n\n;; output our updated Clojure\n(println (z/root-string zloc-c2))\n;; =stdout=>\n; (defn sum-me\n;   \"Add 'em up!\"\n;   [a b c]\n;   (+ a\n;      b\n;      c))\n\n;; and check that location of c has been updated, it should now be on the 6th column of the 6th row\n(z/position zloc-c2)\n;; => [6 6]\n----\n\n==== Zipper Options\nWhen creating a new zipper you may optionally include an options map.\nThese options will be carried by the zipper and live for the life of the zipper.\nCurrent options are:\n\n* `:track-position` - see <<position-tracking>>\n* `:auto-resolve` - see <<custom-auto-resolve>>\n\nAfter making changes via a zipper, the final step is typically to call `root-string` or `print-root`.\n\nLess frequently, one might call `root` which affects changes and returns the root rewrite-clj node.\nThis node might be fed back into a new zipper.\nThe options passed into the original zipper on creation will not be automatically applied to the new zipper and must be respecified:\n\n[source, clojure]\n----\n(require '[rewrite-clj.zip :as z])\n\n;; some contrived options to demonstrate:\n(def zip-opts {:track-position true\n               :auto-resolve (fn [_alias] 'custom-resolved)})\n\n\n(-> \"(+ 10 20 30)\"         ;; <- something more complicated would be here, of course\n    (z/of-string zip-opts) ;; <- our opts are passed in on creation\n    z/down z/right z/right\n    (z/edit inc)\n    z/root                 ;; <- applying changes and getting root node\n    (z/edn zip-opts)       ;; <- pass the original zip-opts on creation of new zipper\n    z/down z/right z/right\n    (z/edit inc)\n    (z/root-string))\n;; => \"(+ 10 22 30)\"\n----\n\n[#parser-api]\n=== Parser API\nParses Clojure/ClojureScript/EDN to rewrite-clj nodes.\nThe link:#zip-api[zip API] makes use of the parser API to parse Clojure into zippers.\n\nIf your focus is parsing instead of rewriting, you might find this lower level API useful.\nKeep in mind that if you forgo the zip API, you forgo niceties such as the automatic handling of whitespace.\n\nYou can choose to parse the first, or all forms from a string or a file.footnote:file[]\n\nHere we parse a single form from a string:\n\n[source, clojure]\n----\n(require '[rewrite-clj.parser :as p])\n\n(def form-nodes (p/parse-string \"(defn my-function [a]\\n  (* a 3))\"))\n----\n\nYou'll likely use the link:#node-api[node API] on the returned nodes.\n\nSee link:{cljdoc-api-url}/rewrite-clj.parser[parser API docs].\n\n[#node-api]\n=== Node API\nInspect, analyze, create and render rewrite-clj nodes.\n\n[source, clojure]\n----\n(require '[rewrite-clj.parser :as p]\n         '[rewrite-clj.node :as n])\n\n(def nodes (p/parse-string \"(defn my-function [a]\\n  (* a 3))\"))\n\n;; Explore what we've parsed\n(n/tag nodes)\n;; => :list\n\n(pr (n/children nodes))\n;; =stdout=>\n; (<token: defn> <whitespace: \" \"> <token: my-function> <whitespace: \" \"> <vector: [a]> <newline: \"\\n\"> <whitespace: \"  \"> <list: (* a 3)>)\n\n(n/sexpr nodes)\n;; => (defn my-function [a] (* a 3))\n\n(n/child-sexprs nodes)\n;; => (defn my-function [a] (* a 3))\n\n;; convert the nodes back to a printable string\n(n/string nodes)\n;; => \"(defn my-function [a]\\n  (* a 3))\"\n\n;; coerce clojure forms to rewrite-clj nodes\n(pr (n/coerce '[a b c]))\n;; =stdout=>\n; <vector: [a b c]>\n\n;; create rewrite-clj nodes by hand\n(pr (n/meta-node\n      (n/token-node :private)\n      (n/token-node 'sym)))\n;; =stdout=>\n; <meta: ^:private sym>\n----\n\nSee link:{cljdoc-api-url}/rewrite-clj.node[node API docs].\n\n==== Creating Nodes\n\nRewrite-clj nodes can be created in a number of ways:\n\n1. Indirectly via the parser API:\n+\n[source,Clojure]\n----\n(-> (p/parse-string \"[1 2 3]\")\n    n/string)\n;; => \"[1 2 3]\"\n----\n2. Indirectly via the zip API (which uses the parser API):\n+\n[source,Clojure]\n----\n(-> (z/of-string \"[1 2 3]\")\n    z/node\n    n/string)\n;; => \"[1 2 3]\"\n----\n3. Via coercion from Clojure forms:\n+\n[source,Clojure]\n----\n(-> (n/coerce '[1 2 3])\n     n/string)\n;; => \"[1 2 3]\"\n----\n4. By explicitly calling node creation functions.\n+\n[source,Clojure]\n----\n(-> (n/vector-node [(n/token-node 1)\n                    (n/whitespace-node \" \")\n                    (n/token-node 2)\n                    (n/whitespace-node \" \")\n                    (n/token-node 3)])\n    n/string)\n;; => \"[1 2 3]\"\n----\n+\nThe node creation function are what the parser API uses to create nodes.\n\nWhich technique you use depends on our needs.\n\nCoercion is convenient, but doesn't offer control over whitespace. In some cases coercion might not give you the result you expect:\n\n//:test-doc-blocks/skip\n[source,Clojure]\n----\n(-> (n/coerce '#(+ %1 %2))\n    n/string)\n;; => \"(fn* [p1__10532# p2__10533#] (+ p1__10532# p2__10533#))\"\n----\n\nBe aware that node creation functions do not force you to use rewrite-clj nodes (notice the raw `1` `2` and `3`):\n\n[source,Clojure]\n----\n(-> (n/vector-node [1 (n/spaces 1) 2 (n/spaces 1) 3])\n    n/string)\n;; => \"[1 2 3]\"\n----\n\n...but no automatic coercion will be done on non rewrite-clj elements and their `tag` will return unknown.\n\n[source,Clojure]\n----\n(n/tag 1)\n;; :unknown\n----\n\nFinally, there are a handful of node whitespace creation convenience functions such as `spaces`, `newlines`, `line-separated` and `comma-separated`, see link:{cljdoc-api-url}/rewrite-clj.node[the node API docs for details].\n\n=== Paredit API\nStructured editing was introduce by rewrite-cljs and carried over to rewrite-clj v1.\n\nWe might expand this section if there is interest, but the docstrings should get you started.\n\nSee link:{cljdoc-api-url}/rewrite-clj.paredit[current paredit API docs].\n\n== Map Nodes\nRewrite-clj parses two types of maps.\n\n1. unqualified `{:a 1 :b 2}`\n2. namespaced `#:prefix {:x 1 :y 2}`\n\nRewrite-clj models nodes as they appear in the original source.\n\nimage::map-nodes.png[map nodes]\n\nThis is convenient when navigating through the source, but when we want to logically treat any map as a map the difference is admittedly bit awkward.\n\n== Parsing Peculiarities\n\nRewrite-clj can, in some specific cases, parse technically invalid Clojure.\nSome folks have come to rely on this over the years, so these are behaviours we will preserve.\n\n[[unbalanced-maps]]\n=== Unbalanced Maps\nAn unbalanced map is one where there is a key with no value.\n\nRewrite-clj can parse and emit unbalanced maps:\n[source,clojure]\n----\n(require '[rewrite-clj.zip :as z])\n\n(-> \"{:a 1 :b 2 :c}\"\n    z/of-string\n    z/root-string)\n;; => \"{:a 1 :b 2 :c}\"\n----\n\nAn attempt to convert an unbalanced map to a Clojure form will throw:\n//#:test-doc-blocks {:reader-cond :clj}\n[source,clojure]\n----\n(try\n  (-> \"{:a 1 :b 2 :c}\"\n      z/of-string\n      z/sexpr)\n  (catch Throwable e\n    (.getMessage e)))\n;; => \"No value supplied for key: :c\"\n----\n\nNOTE: `sexpr-able?` considers the current node element type only and will return `true` for all maps, balanced or not.\n\n[[maps-with-duplicate-keys]]\n=== Maps with Duplicate keys\nRewrite-clj can parse and emit maps with duplicate keys:\n\n[source,clojure]\n----\n(-> \"{:a 1 :b 2 :a 3 :a 4 :a 5 :a 6}\"\n    z/of-string\n    z/root-string)\n;; => \"{:a 1 :b 2 :a 3 :a 4 :a 5 :a 6}\"\n----\n\nBut when converting to a Clojure form, duplicate keys are not valid in a map, so only the last key/value pair for duplicate keys will be included:\n[source,clojure]\n----\n(-> \"{:a 1 :b 2 :a 3 :a 4 :a 5 :a 6}\"\n    z/of-string\n    z/sexpr)\n;; => {:b 2, :a 6}\n----\n\n[[sets-with-duplicate-values]]\n=== Sets with Duplicate values\n\nRewrite-clj can parse and emit sets with duplicate values:\n\n[source,clojure]\n----\n(-> \"#{:a :b :a :a :a}\"\n    z/of-string\n    z/root-string)\n;; => \"#{:a :b :a :a :a}\"\n----\n\nBut when converting to a Clojure form, duplicate values in a set are not valid Clojure, so the duplicates are omitted:\n\n[source,clojure]\n----\n(-> \"#{:a :b :a :a :a}\"\n    z/of-string\n    z/sexpr)\n;; => #{:b :a}\n----\n\n[#sexpr-nuances]\n== Sexpr Nuances\n\nRewrite-clj parses arbitrary Clojure/ClojureScript source code into rewrite-clj nodes.\nConverting rewrite-clj nodes to Clojure forms via `sexpr` is convenient, but it does come with some caveats.\n\nWithin reason, Clojure's `read-string` and rewrite-clj's `sexpr` functions should return equivalent Clojure forms.\nTo illustrate, some code:\n\n[source, clojure]\n----\n(require '[rewrite-clj.zip :as z]\n         '[rewrite-clj.parser :as p]\n         '[rewrite-clj.node :as n]\n         #?(:cljs '[cljs.reader :refer [read-string]]))\n\n(defn form-test [s]\n  (let [forms [(-> s read-string)\n               (-> s z/of-string z/sexpr)\n               (-> s p/parse-string n/sexpr)]]\n    (if (apply = forms)\n      (first forms)\n      [:not-equal forms])))\n\n(form-test \"a\")\n;; => a\n(form-test \"[1 2 3]\")\n;; => [1 2 3]\n(form-test \"(defn hello [name] (println \\\"Hello\\\" name))\")\n;; => (defn hello [name] (println \"Hello\" name))\n----\n\n=== Whitespace\nThe whitespace that a rewrite-clj so carefully preserves is lost when converting to a Clojure form.\n\n[source,clojure]\n----\n(require '[rewrite-clj.parser :as p]\n         '[rewrite-clj.node :as n])\n\n;; parse some Clojure source\n(def nodes (p/parse-string \"{  :a 1\\n\\n   :b 2}\"))\n\n;; print it out to show the whitespace\n(println (n/string nodes))\n;; =stdout=>\n; {  :a 1\n;\n;    :b 2}\n\n;; print out Clojure forms and notice the loss of the specifics of whitespace and element ordering\n(pr (n/sexpr nodes))\n;; =stdout=>\n; {:b 2, :a 1}\n----\n\n[[not-all-clojure-is-sexpr-able]]\n=== Not all Clojure Elements are Sexpr-able\n\nSome source code element types are not sexpr-able:\n\n* Reader ignore/discard `#_` (also known as \"uneval\" in rewrite-clj)\n* Comments\n* Clojure whitespace (which includes commas)\n\nBoth the zip and node APIs include `sexpr-able?` to check if sexpr is supported for the current node element type.\n\n[NOTE]\n====\n`sexpr-able?` only looks at the current node element type. This means that `sexpr` will still throw when:\n\n1. called on a node with an element type that is `sepxr-able?` but, for whatever reason, has a child node that fails to `sexpr`, see link:#unbalanced-maps[unbalanced maps].\n2. called directly on an link:#unbalanced-maps[unbalanced maps].\n====\n\n[source, clojure]\n----\n(require '[rewrite-clj.node :as n]\n         '[rewrite-clj.parser :as p]\n         '[rewrite-clj.zip :as z])\n\n#?(:clj (import clojure.lang.ExceptionInfo))\n\n;;\n;; Most nodes are sexpr-able\n;;\n\n;; we can check sexpr-ability through the node API\n(-> \"hello\" p/parse-string n/sexpr-able?)\n;; => true\n\n;; or through the zip API\n(-> \"hello\" z/of-string z/sexpr-able?)\n;; => true\n\n;;\n;; But some nodes are not sexpr-able\n;;\n\n;; the discard #_ node is not sexpr-able\n(-> \"#_42\" z/of-string z/sexpr-able?)\n;; => false\n\n;; and will throw if an attempt is made to sexpr\n(try\n  (-> \"#_42\" z/of-string z/sexpr)\n  (catch ExceptionInfo e\n    (ex-message e)))\n;; => \"unsupported operation\"\n\n;; comments nodes are not sexpr-able\n(-> \";; can’t sexpr me!\" z/of-string z/next* z/sexpr-able?) ;; <1>\n;; => false\n\n;; and will throw\n(try\n  (-> \";; can’t sexpr me!\" z/of-string z/next* z/sexpr) ;; <1>\n  (catch ExceptionInfo e\n    (ex-message e)))\n;; => \"unsupported operation\"\n\n;; and finally, Clojure whitespace nodes are not sexpr-able\n(-> \" \" z/of-string z/next* z/sexpr-able?) ;; <1>\n;; => false\n\n;; and will throw\n(try\n  (-> \" \" z/of-string z/next* z/sexpr) ;; <1>\n  (catch ExceptionInfo e\n    (ex-message e)))\n;; => \"unsupported operation\"\n----\n<1> Notice the use of `next*` to include normally skipped nodes.\n\nRemember that child nodes with element types that are not `sexpr-able?` are skipped for `sexpr`:\n\n[source,clojure]\n----\n(-> (str \"[1 #_:child-discard-will-be-skipped\\n\"\n         \" ;; comment will be skipped\\n\"\n         \" ,,, ,,, ,,, \\n\"\n         \" 2]\")\n    z/of-string\n    z/sexpr)\n;; => [1 2]\n----\n\n=== Differences in Clojure Platforms\n\nClojure and ClojureScript have differences.\nSome examples of what you might run into when using `sexpr` are:\n\n[source, clojure]\n----\n(require '[rewrite-clj.zip :as z])\n\n;; ClojureScript has no Ratio type\n(-> (z/of-string \"3/4\") z/sexpr)\n;; =clj=> 3/4\n;; =cljs=> 0.75\n\n;; Integral type and behaviour is defined by host platforms\n(+ 10 (-> (z/of-string \"9007199254740991\") z/sexpr))\n;; =clj=> 9007199254741001\n;; =cljs=> 9007199254741000\n\n;; ClojureScript has no character type, characters are expressed as strings\n(-> (z/of-string \"\\\\a\") z/sexpr)\n;; =clj=> \\a\n;; =cljs=> \"a\"\n----\n\nNote that these differences affect `sexpr` only.\nRewrite-clj should be able to parse and rewrite all valid Clojure/ClojureScript code.\n\n=== Reader Macro Chars\n\nRewrite-clj can parse and write all reader macro chars.\nBe aware though, that it does have limitations when calling `sexpr` on rewrite-clj nodes representing some of these constructs.\n\nLet's take a look, using https://clojure.org/reference/reader#macrochars[Clojure's reader docs on macro characters] as our reference.\n\n(headers are *description* followed by rewrite-clj parsed node `tag`)\n\n[cols=\"25,75\"]\n// Table generated via:\n//  clojure -M script/gen-user-guide-reader-macro-table.clj\n// update via updating and rerunning script and pasting result here:\n|===\n| Parsed input | Node sexpr\n\n2+a|*Quote* `:quote`\na|`'form`\na|`(quote form)`\n\n2+a|*Character* `:token`\na|`\\newline`\na|`\\newline`\na|`\\space`\na|`\\space`\na|`\\tab`\na|`\\tab`\n\n2+a|*Comment* `:comment`\na|`; comment`\na|<unsupported operation>\n\n2+a|*Deref* `:deref`\na|`@form`\na|`(deref form)`\n\n2+a|*Metadata* `:meta`\na|`^{:a 1 :b 2} [1 2 3]`\na|`^{:b 2, :a 1} [1 2 3]`\na|`^String x`\na|`^{String true} x`\na|`^:dynamic x`\na|`^{:dynamic true} x`\n\n2+a|*Set* `:set`\na|`#{1 2 3}`\na|`#{1 3 2}`\n\n2+a|*Regex* `:regex`\na|`#\"reg.*ex\"`\na|`(re-pattern \"reg.*ex\")`\n\n2+a|*Var-quote* `:var`\na|`#'x`\na|`(var x)`\n\n2+a|*Anonymous function* `:fn`\na|`#(println %)`\na|`(fn* [p1__2976#] (println p1__2976#))`\n\n2+a|*Ignore next form* `:uneval`\na|`#_ :ignore-me`\na|<unsupported operation>\n\n2+a|*Syntax quote* `:syntax-quote`\na|``symbol`\na|`(quote symbol)`\n\n2+a|*Syntax unquote* `:unquote`\na|`~symbol`\na|`(unquote symbol)`\n\n2+a|*Tagged literal* `:reader-macro`\na|`#foo/bar [1 2 3]`\na|`(read-string \"#foo/bar [1 2 3]\")`\na|`#inst \"2018-03-28T10:48:00.000\"`\na|`(read-string \"#inst \\\"2018-03-28T10:48:00.000\\\"\")`\na|`#uuid \"3b8a31ed-fd89-4f1b-a00f-42e3d60cf5ce\"`\na|`(read-string \"#uuid \\\"3b8a31ed-fd89-4f1b-a00f-42e3d60cf5ce\\\"\")`\n\n2+a|*Reader conditional* `:reader-macro`\na|`#?(:clj x :cljs y)`\na|`(read-string \"#?(:clj x :cljs y)\")`\na|`#@?(:clj [x] :cljs [y])`\na|`(read-string \"#@?(:clj [x] :cljs [y])\")`\n\n|===\n\nObservations:\n\n1. I think it was a design decision of rewrite-clj v0 to return `(read-string ...)` for reader macros it did not want to deal with (or deal with yet).\nRewrite-clj v1 will carry on.\n** It seems the idea might have been that the caller could eval the sexpr result if they wanted to?\n** Note for ClojureScript users, `read-string` is not available under `cljs.core`, but a version is available under `cljs.tools.reader`.\n2. Tag metadata is returned as boolean metadata.\nA user could infer the intent through inspection though.\n\n// NOTE: target of some docstrings\n[#namespaced-elements]\n=== Namespaced Elements\n\nIf the code you are parsing doesn't use namespaced maps or you have no interest in using `sexpr` on the keys in those maps, the details in this section probably won't be of concern to you.\n\n==== Recap\nIn Clojure keywords and symbols can be qualified.\nA recap via examples:\n\n* Stand-alone keyword and symbols:\n+\n|===\n| |keyword|symbol\n\n|unqualified\na|`:my-kw`\na|`'my-symbol`\n\n|qualified\na|`:prefix/my-kw`\na|`'prefix/my-symbol`\n\n|auto-resolved current namespace\na|`::my-kw`\na|n/a\n\n|auto-resolved namespaced alias\na|`::my-ns-alias/my-kw`\na|n/a\n\n|===\n\n* Namespaced keyword and symbols:\n+\n|===\n| |keyword|symbol\n\na|unqualified (via `_` prefix)\na|`#:prefix{:_/my-kw 1}`\na|`'#:prefix{_/my-symbol}`\n\n|qualified\na|`#:prefix{:my-kw 1}`\na|`'#:prefix{my-symbol 1}`\n\n|auto-resolved current namespace\na|`#::{:my-kw 1}`\na|`'#::{my-symbol 1}`\n\n|auto-resolved namespaced alias\na|`#::my-ns-alias{:my-kw 1}`\na|`'#::my-ns-alias{my-symbol 1}`\n\n|===\n\n==== Rewrite-clj Default Auto-Resolve Handling\n\nWhen calling `sepxr` on an auto-resolved keyword or symbol node, rewrite-clj will resolve:\n\n* the current namespace to `?\\_current-ns_?`\n* namespaced alias `x` to `??\\_x_??`\n\nTo illustrate:\n[source, clojure]\n----\n(require '[rewrite-clj.parser :as p]\n         '[rewrite-clj.node :as n])\n\n(-> (p/parse-string \"::kw\") n/sexpr)\n;; => :?_current-ns_?/kw\n(-> (p/parse-string \"#::{:a 1 :b 2 s1 3}\") n/sexpr)\n;; => #:?_current-ns_?{s1 3, :b 2, :a 1}\n(-> (p/parse-string \"::my-alias/kw\") n/sexpr)\n;; => :??_my-alias_??/kw\n(-> (p/parse-string \"#::my-alias{:a 1 :b 2 s1 3}\") n/sexpr)\n;; => #:??_my-alias_??{s1 3, :b 2, :a 1}\n----\n\n[#custom-auto-resolve]\n==== Custom Auto-Resolve Handling\n\nRewrite-clj will not attempt to determine the current namespace and alias namespace mappings of the code it is parsing.\nIt does, though, allow you to specify your own auto-resolve behavior.\n\nThe `:auto-resolve` function takes a single arg `alias` for lookup and must return symbol.\nThe `alias` will be:\n\n* `:current` for a request for the current namespace\n* otherwise it will be a symbol for the namespace alias to lookup\n\nFor example, if you know namespace and alias info for the code rewrite-clj is operating on, you can specify it:\n\n[source, clojure]\n----\n(require '[rewrite-clj.parser :as p]\n         '[rewrite-clj.node :as n])\n\n(defn resolver [alias]\n  (or (get {:current 'my.current.ns\n            'my-alias 'my.aliased.ns} alias)\n      (symbol (str alias \"-unresolved\"))))\n\n(-> (p/parse-string \"::kw\") (n/sexpr {:auto-resolve resolver}))\n;; => :my.current.ns/kw\n(-> (p/parse-string \"#::{:a 1 :b 2 s1 3}\") (n/sexpr {:auto-resolve resolver}))\n;; => #:my.current.ns{s1 3, :b 2, :a 1}\n(-> (p/parse-string \"::my-alias/kw\") (n/sexpr {:auto-resolve resolver}))\n;; => :my.aliased.ns/kw\n(-> (p/parse-string \"#::my-alias{:a 1 :b 2 s1 3}\") (n/sexpr {:auto-resolve resolver}))\n;; => #:my.aliased.ns{s1 3, :b 2, :a 1}\n----\n\nThe `:auto-resolve` option is accepted in the `opts` map arg for:\n\n* The `rewrite-clj.node` namespace functions `sexpr` and `child-sexpr`.\n* The `rewrite-clj.zip` namespace zipper creation functions `edn*`, `edn`, `of-string` and `of-file`.\nThe resulting zipper will then automatically apply your `:auto-resolve` within any zip operation that makes use of sexpr, namely:\n** `sexpr`\n** `find-value` and `find-next-value` - sexpr is applied to each node to get the \"value\" for comparison\n** `edit` - the current node is sexpr-ed\n** `get` and `assoc` - sexpr is applied to the map key\n\n// NOTE: targeted from docstrings\n[#impact-of-auto-resolve]\n==== Impact of Auto-Resolve\n\nLet's illustrate how functions that use `sexpr` internally are affected by exploring `rewrite-clj.zip/get`:\n\n[source,clojure]\n----\n(require '[rewrite-clj.zip :as z])\n\n;; get on unqualified keys is straightforward:\n(-> \"{:a 1 :b 2 c 3}\" z/of-string (z/get :b) z/node pr)\n;; =stdout=>\n; <token: 2>\n\n;; get on qualified keys is also easy to grok\n(-> \"{:a 1 :prefix/b 2 c 3}\" z/of-string (z/get :prefix/b) z/node pr)\n;; =stdout=>\n; <token: 2>\n(-> \"#:prefix{:a 1 :b 2 c 3}\" z/of-string (z/get :prefix/b) z/node pr)\n;; =stdout=>\n; <token: 2>\n(-> \"#:prefix{:a 1 :b 2 c 3}\" z/of-string (z/get 'prefix/c) z/node pr)\n;; =stdout=>\n; <token: 3>\n\n;; but when we introduce auto-resolved elements, the default resolver comes into play\n;; and must be considered\n(-> \"{::ns-alias/a 1 ::b 2 c 3}\" z/of-string (z/get :?_current-ns_?/b) z/node pr)\n;; =stdout=>\n; <token: 2>\n(-> \"{::ns-alias/a 1 ::b 2 c 3}\" z/of-string (z/get :??_ns-alias_??/a) z/node pr)\n;; =stdout=>\n; <token: 1>\n(-> \"#::{:a 1 :b 2 c 3}\" z/of-string (z/get :?_current-ns_?/b) z/node pr)\n;; =stdout=>\n; <token: 2>\n(-> \"#::{:a 1 :b 2 c 3}\" z/of-string (z/get '?_current-ns_?/c) z/node pr)\n;; =stdout=>\n; <token: 3>\n----\n\n==== Impact of Namespaced Map Context on Keywords and Symbols\n\nNamespaced map context is automatically applied to symbols and keywords in namespaced maps.\n\nTo illustrate with the zip API:\n\n[source,clojure]\n----\n(require '[rewrite-clj.zip :as z])\n\n(def zloc (z/of-string \"#:my-prefix {:a 1 :b 2 c 3}\"))\n\n;; An sexpr on the namespaced map returns the expected Clojure form\n( -> zloc z/sexpr)\n;; => #:my-prefix{:b 2, c 3, :a 1}\n\n;; An sepxr on the an individual key in the namespaced map returns the expected Clojure form\n(-> zloc z/down z/rightmost z/down z/sexpr)\n;; => :my-prefix/a\n----\n\nRewrite-clj applies the namespaced map context the namespaced map node children:\n\n* at create time (which is also parse time)\n* when the node's children are replaced\n\nThis works well with the mechanics of the zipper.\nUpdates are automatically applied when moving `up` through the zipper:\n\n[source,clojure]\n----\n(require '[rewrite-clj.zip :as z])\n\n(def s \"#:prefix {:a 1 :b 2 c 3}\")\n\n;; sexpr works fine on unchanged zipper\n(-> s z/of-string z/sexpr)\n;; => #:prefix{:b 2, c 3, :a 1}\n\n;; changing the namespaced map prefix reapplies the context to the children\n(-> s\n    z/of-string\n    z/down\n    (z/replace (n/map-qualifier-node false \"my-new-prefix\"))\n    z/up\n    z/sexpr)\n;; => #:my-new-prefix{:b 2, c 3, :a 1}\n\n;; a new key/val gets the namespaced map context\n(-> s\n    z/of-string\n    z/down z/rightmost\n    (z/append-child :d)\n    (z/append-child 33)\n    z/up\n    z/sexpr)\n;; => #:prefix{:b 2, c 3, :d 33, :a 1}\n\n;; a replaced key gets namespaced map context\n(-> s\n    z/of-string\n    z/down z/rightmost z/down\n    (z/replace :a2)\n    z/up z/up\n    z/sexpr)\n;; => #:prefix{:a2 1, :b 2, c 3}\n\n;; but... be aware that the context is not applied...\n(-> s\n    z/of-string\n    z/down z/rightmost z/down\n    (z/replace :a2)\n    z/sexpr)\n;; => :a2\n\n;; ... until we move up to the namespaced map node:\n(-> s\n    z/of-string\n    z/down z/rightmost z/down\n    (z/replace :a2)\n    z/up z/up\n    z/down z/rightmost z/down\n    z/sexpr)\n;; => :prefix/a2\n----\n\nSome limitations:\n\n* Keyword and symbol nodes will continue to hold their namespaced map context even when moved outside a namespaced map.\nShould you need to, you can use the zip API's `reapply-context` to manually apply context from the current node downward.\n* The context auto-update is a feature of the zip API, when working with link:#node-api[nodes directly] the context will be applied at parse time, and when namespaced map node children are replaced only.\n\n== Dealing with Reader Generated Metadata\nRewrite-clj offers, where it can, transparent coercion from Clojure forms to rewrite-clj nodes.\n\nClojure will, in some cases, add location metadata that is not in the original source code, as illustrated here:\n\n//:test-doc-blocks/skip\n.REPL session\n[source,clojure]\n----\n(meta '(1 2 3))\n;; => {:line 1, :column 8}\n----\n\nRewrite-clj will, on coercion from Clojure forms to rewrite-clj nodes, omit location metadata.\nNo rewrite-clj metadata node will will be created if resulting metadata is empty.\n\nOn conversion from rewrite-clj nodes to Clojure forms via `sexpr`, I don't see a way to omit the location metadata.\nWith the assumption that you will generally coerce Clojure forms back to rewrite-clj nodes, this should not cause an issue.\n\nTo support those using rewrite-clj under sci, in addition to `:line` and `:column` rewrite-clj also removes `:end-line` and `:end-column` metadata.\nNote that while Clojure only adds location metadata to quoted lists, sci adds it to all forms that accept metadata.\n",
     :cljdoc.doc/type :cljdoc/asciidoc,
     :slug "user-guide",
     :cljdoc.doc/contributors
     ("lread" "GitHub Actions" "github-actions[bot]" "rgkirch")}}
   {:title "Developer Guide",
    :attrs
    {:cljdoc.doc/source-file "doc/02-developer-guide.adoc",
     :cljdoc/asciidoc
     "= Developer Guide\n:toclevels: 6\n:toc:\n\n== Supported Environments\nRewrite-clj is verified on each push on macOS, Ubuntu and Windows via GitHub Actions.\n\nAll scripts are written in Clojure and most invoked via https://github.com/borkdude/babashka[babashka] tasks.\nThis gives us a cross platform scripting language that is familiar, fun and consistent.\n\nWe make use of planck for cljs bootstrap (aka cljs self-hosted) testing.\nPlanck is currently not available for Windows.\n\nWe test that rewrite-clj operates as expected when natively compile via GraalVM.\nAutomated testing is setup using GraalVM v22 JDK11.\n\n== Prerequisites\n* Java JDK 1.8 or above\n* NodeJs v12 or above\n* Clojure v1.10.1.697 or above for `clojure` command\n** Note that rewrite-clj v1 itself supports Clojure v1.8 and above\n* Babashka v0.3.7 or above\n* GraalVM v22.0.0.2 JDK 11 (if you want to run GraalVM native image tests)\n\n=== Windows Notes\n\n==== Git and newlines\nThe primary development OSes for rewrite-clj are macOS and Linux.\nOur line endings are LF only.\n\nI'm not sure what Windows developers typically want for line endings while working on source.\nI expect, but don't know, that most Windows editors automatically handle LF as line ending.\nSomeone let me know if I am wrong.\n\nNote that I do explicitly set git's config `core.autocrlf` to `false` on our Windows CI unit test environment.\nOur import vars code generation checks currently rely on line endings remaining unconverted.\n\n==== Babashka\nThe Clojure story on Windows is still in the early chapters.\nhttps://scoop.sh/[Scoop] offers an easy way to install tools.\n@littleli is doing a great job  w/maintaining https://github.com/littleli/scoop-clojure[scoop apps for Clojure, Babashka and other tools] and this is how I installed Babashka.\n\n==== Clojure\nWe all choose our own paths, but for me, using https://github.com/borkdude/deps.clj[deps.clj] instead of https://github.com/clojure/tools.deps.alpha/wiki/clj-on-Windows[Clojure's PowerShell Module] offered me no fuss no muss Clojure on Windows and GitHub Actions on Windows.\nI decided to install deps.clj not through scoop but through https://github.com/borkdude/deps.clj#windows[the deps.clj `install.ps1` script].\nThis makes it simple to treat `deps.exe` as if it were the official `clojure` via a simple rename:\n\n----\nRename-Item $HOME\\deps.clj\\deps.exe clojure.exe\n----\n\n==== GraalVM\nYou'll have your own preference, but I find it convenient to install GraalVM on Windows via scoop.\n\nYou'll need to load the appropriate Visual C++ environment variables for GraalVM's native-image to do its work.\nI found it oddly cumbersome to load them from PowerShell, so I work from a cmd shell instead.\nHere's what works on my Windows dev environment:\n\n[source,shell]\n----\ncall \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat\"\n----\n\n== Setup\nAfter checking out this project from GitHub,\n\n1. Install JavaScript libraries and tools required by https://github.com/bensu/doo[doo] and https://github.com/thheller/shadow-cljs[shadow-cljs]:\n+\n----\nsudo npm install karma-cli -g\nnpm install\n----\n\n2. If you are on macOS or linux, https://github.com/planck-repl/planck#installing[install planck].\n\n3. Initialize cache for clj-kondo so it can lint against your dependencies\n+\n----\nbb lint\n----\n\n== Babashka Tasks\n\nWe make use of babashka tasks for development related commands.\n\nTo see all available tasks with a short description run:\n----\nbb tasks\n----\n\nTo run a task, for example, the `lint` task:\n----\nbb lint\n----\n\nUsage help for a task is requested via `--help`, for example:\n----\nbb lint --help\n----\n\nTasks are described throughout this document.\n\n== Code Generation\nRewrite-clj v0 used a version of potemkin import-vars.\nPotemkin import-vars copies specified vars from a specified namespace to the current namespace at load time.\nDue to often mysterious issues related to import-vars, a general dislike for import-vars in the Clojure community, and associated maintenance costs, we've opted to instead generate code for rewrite-clj v1.\n\nFor any source that used potemkin import-vars, we now have a separate template clj (or cljc) file.\nFor example `src/rewrite_clj/zip.cljc` is generated by template `template/rewrite_clj/zip.cljc`.\n\nThe syntax of import-vars in the template remains familiar.\nThe following old potemkin import-vars syntax:\n\n//:test-doc-blocks/skip\n[source,clojure]\n----\n(import-vars\n  [[my.ns1 my-var1 my-var2 my-var3]\n   [my.ns2 my-var4 my-var5]])\n----\n\nIs expressed in our templates as:\n\n//:test-doc-blocks/skip\n[source,clojure]\n----\n#_{:import-vars/import\n   {:from [[my.ns1 my-var1 my-var2 my-var3]\n           [my.ns2 my-var4 my-var5]]}}\n----\n\nAny `:added` and `:deprecated` metadata should be defined in the template and not on the reference var.\nThis keeps the metadata on the public API vars only and avoids having the ClojureScript compiler warn about deprecated calls on internal sources within rewrite-clj:\n\n//:test-doc-blocks/skip\n[source,clojure]\n----\n#_{:import-vars/import\n   {:from [[my.ns1\n            ^{:deprecated \"1.2.3\"} obsolete-fn\n            ^{:added \"1.2.4\"} new-fn]]}}\n----\n\nWe also carry over rewrite-cljc support for `:import-vars/import-with-mods`, via an optional `:opts`.\nSee `template/rewrite_clj/zip.cljc` for example usage.\n\nImporting will generate delegates.\nAn import of `(defn foo [a b] (+ a b))` from namespace `my.ns1` will generate `(defn foo [a b] (my.ns1/foo a b))`.\nNo generation of requires is done, your template will have to require `my.ns1` in normal Clojure code.\n\nAt this time, we don't handle destructuring in arglists, and will throw unless args are all symbols.\n\nTo generate target source from templates run:\n[source,shell]\n----\nbb apply-import-vars gen-code\n----\nYou are expected to review the generated changes and commit the generated source to version control.\nWe don't link:#linting[lint] templates, but we do lint the generated code.\n\nTo perform a read-only check, run:\n[source,shell]\n----\nbb apply-import-vars check\n----\nThe check command will exit with 0 if no changes are required, otherwise it will exit with 1.\nOur build script will run the check command and fail the build if there are any pending changes that have not been applied.\n\n== Testing During Development\nYour personal preference will likely be different, but during maintenance and refactoring, I found running tests continuously for Clojure and ClojureScript helpful.\n\n=== Clojure\nFor Clojure, I open a shell terminal window and run:\n\n----\nbb test-clj-watch\n----\n\nThis launches https://github.com/lambdaisland/kaocha[kaocha] in watch mode.\n\n=== ClojureScript\nFor ClojureScript, I open a shell terminal window and run:\n\n----\nbb test-cljs-watch\n----\n\nThis launches https://figwheel.org/[fighweel main].\nAfter initialization, your default web browser will automatically be opened with the figwheel auto-testing page.\n\n== Docs\n\nAll documentation is written in AsciiDoc.\nWe follow https://asciidoctor.org/docs/asciidoc-recommended-practices/#one-sentence-per-line[AsciiDoc best practice of one sentence per line].\n\nImages are created and edited with https://github.com/jgraph/drawio-desktop/releases[draw.io desktop].\nWe export to .png with a border of 10 and a transparent background.\nAt the time of this writing draw.io does not remember export settings, so you'll have to enter them in each time.\n\n== Testing Doc Code Blocks\nWe use https://github.com/lread/test-doc-blocks[test-doc-blocks] to verify that code blocks in our documentation are in good working order.\n\n----\nbb test-doc\n----\n\nThis generates tests for doc code blocks and then runs them under Clojure and ClojureScript.\n\n== Testing Before a Push\nBefore pushing, you likely want to mimic what is run on each push via GitHub Actions.\n\n=== Unit tests\nUnit tests are run via:\n----\nbb ci-unit-tests\n----\n\n=== Native image tests\nWe also verify that rewrite-clj functions as expected when compiled via Graal's `native-image`.\n\n1. Tests and library natively compiled:\n+\n----\nbb test-native\n----\n2. Library natively compiled and tests interpreted via sci\n+\n----\nbb test-native-sci\n----\n\n[#libs-test]\n=== Libs test\nTo try to ensure our changes to rewrite-clj do not inadvertently break existing popular libraries, we run their tests, or a portion thereof, against rewrite-clj.\n----\nbb test-libs run\n----\n\nSee link:../README.adoc#used-in[README] for current libs we test against.\n\nAdditional libs are welcome.\n\nTo see a list of available libs we currently test against:\n----\nbb test-libs list\n----\n\nIf you are troubleshooting locally, and want to only run specific tests, you can specify which ones you'd like to run.\nFor example:\n\n----\nbb test-libs run cljfmt zprint\n----\n\nUpdating the test-libs script to run against current versions of libs is recommended, but care must be taken when updating.\nWe want to make sure we are patching correctly to use rewrite-clj v1 and running a lib's tests as intended.\n\nTo check for outdated libs:\n\n----\nbb test-libs outdated\n----\n\nNotes:\n\n* The `test-libs` task was developed on macOS and is run on CI under Linux only under JDK 11 only.\nWe can expand variations at some later date if there is any value to it.\n* We test the current HEAD of rewrite-clj v1 against specific versions (latest at the time of this writing) of libs.\n* We patch lib deps and sometimes code (ex. `require` for `rewrite-cljc` becomes `rewrite-clj`).\n* As folks migrate to rewrite-clj v1, the need for current patches will lessen.\n* Updating what versions we test against is currently a manual, but not an overly burdensome, task.\n\n== Checking for Outdated Dependencies\n\nTo see what new dependencies are available, run:\n----\nbb outdated\n----\n\nThis task uses:\n\n* https://github.com/liquidz/antq[antq] for Clojure.\n* npm for JavaScript.\nIt only checks against installed `./node_modules`, so you may want to run `npm install` first.\n\n[#linting]\n== Linting\nWe use https://github.com/borkdude/clj-kondo[clj-kondo] and https://github.com/jonase/eastwood[eastwood] to lint rewrite-clj source code.\nWe apply https://github.com/camsaul/whitespace-linter[whitespace-linter] to docs, config, and source code to avoid some annoying whitespace diffs.\n\nWe fail the build on any lint violations.\nThe CI server runs:\n----\nbb lint\n----\nand you can too. The lint script will build the clj-kondo cache when it is missing or stale.\nIf you want to force a rebuild of the cache run:\n----\nbb lint --rebuild-cache\n----\n\nhttps://github.com/borkdude/clj-kondo/blob/master/doc/editor-integration.md[Integrate clj-kondo into your editor] to catch mistakes as they happen.\n\nYou can optionally:\n\n* `bb -lint-whitespace` to run only whitespace linting\n* `bb -lint-kondo` to run only clj-kondo linting\n* `bb -lint-eastwood` to run only the eastwood linting\n\n== API diffs\nRewrite-clj v1's primary goals include remaining compatible with rewrite-clj v0 and rewrite-cljs and avoiding breaking changes.\n\nTo generate reports on differences between rewrite-clj v0, rewrite-cljs and\nrewrite-clj v1 APIs, run:\n\n----\nbb doc-api-diffs\n----\n\nWARNING: This task currently needs love, see https://github.com/clj-commons/rewrite-clj/issues/132[#132].\n\nRun this script manually on an as-needed basis, and certainly before any official release.\nGenerated reports are to be checked in to version control.\n\nReports are generated to `doc/generated/api-diffs/` and include manually written notes from `doc/diff-notes/`.\n\nThese reports are referenced from other docs, so if you rename files, be sure to search for links.\n\nMakes use of https://github.com/lread/diff-apis[diff-apis].\nDelete `.diff-apis/.cache` if you need a clean run.\n\n\n== Cljdoc Preview\nBefore a release, it can be comforting to preview what docs will look like on https://cljdoc.org/[cljdoc].\n\nLimitations\n\n* This task should be considered experimental, I have only tested running on macOS, but am fairly confident it will work on Linux.\nNot sure about Windows at this time.\n* You have to push your changes to GitHub to preview them.\nThis allows for a full preview that includes any links (source, images, etc) to GitHub.\nThis works fine from branches and forks - in case you don't want to affect your main development branch for a preview.\n\n**Start Local Services**\n\nTo start the local cljdoc docker container:\n----\nbb cljdoc-preview start\n----\n\nThe local cljdoc server allows your ingested docs to be viewed in your web browser.\n\nThe start command also automatically checks docker hub for any updates so that our cljdoc preview matches the current production version of cljdoc.\n\n**Ingest Docs**\n\nTo ingest rewrite-clj API and docs into the local cljdoc database:\n----\nbb cljdoc-preview ingest\n----\n\nThe ingest command automatically publishes rewrite-clj to your local maven repository (cljdoc only works with published jars).\n\nThe locally published version will include a `-cljdoc-preview` suffix.\nI find this distinction helps to reduce confusion around locally vs remotely installed artifacts.\n\nYou'll have to remember to git commit and git push your changes before ingesting.\n\nRepeat these steps any time you want to preview changes.\n\n**Preview Docs**\n\nTo open a view to the ingested docs in your default web browser:\n----\nbb cljdoc-preview view\n----\n\nIf you have just run the start command, be a bit patient, the cljdoc server can take a few moments to start up - especially on macOS due to poor file sharing performance.\n\n**Stop Local Services**\n\nWhen you are done, you'll want to stop your docker container:\n----\nbb cljdoc-preview stop\n----\n\nThis will also delete temporary files created to support your preview session, most notably the local cljdoc database.\n\nNote that NO cleanup is done for any rewrite-clj artifacts published to your local maven repository.\n\n**Container Status**\n\nIf you forget where you are at with your docker containers, run:\n----\nbb cljdoc-preview status\n----\n\n== Code Coverage\n\nWe use https://github.com/cloverage/cloverage[cloverage] via https://github.com/lambdaisland/kaocha[kaocha] to generate code coverage reports via:\n----\nbb test-coverage\n----\n\nOur CI service is setup to automatically generate then upload reports to https://codecov.io[CodeCov].\n\nWe have no specific goals for code coverage, but new code is generally expected to have tests.\n\nSo why measure coverage? It simply offers us some idea of what code our test suite hits.\n\n== Contributors\nWe honor current and past contributors to rewrite-clj in our README file.\n\nTo update contributors, update `doc/contributors.edn` then run:\n\n----\nbb doc-update-readme\n----\n",
     :cljdoc.doc/type :cljdoc/asciidoc,
     :slug "developer-guide",
     :cljdoc.doc/contributors ("lread" "Vincent Cantin")}}
   {:title "Design",
    :attrs {:slug "design"},
    :children
    [{:title "Merging rewrite-clj and rewrite-cljs",
      :attrs
      {:cljdoc.doc/source-file
       "doc/design/01-merging-rewrite-clj-and-rewrite-cljs.adoc",
       :cljdoc/asciidoc
       "= Merging rewrite-clj and rewrite-cljs\n:toc:\n:toclevels: 6\n\n== Introduction\nRewrite-clj v1 is a merge of https://github.com/clj-commons/rewrite-clj/tree/f515767e4f07f27389ee2885cb459bd87d903887[rewrite-clj v0] and https://github.com/clj-commons/rewrite-cljs[rewrite-cljs] giving us a one stop rewrite-clj shop for Clojure and ClojureScript developers.\n\n== Goals\n1. *Minimize API breakage*.\nWithin reason, maintain API compatibility with both rewrite-clj v0 and rewrite-cljs.\nI'd like rewrite-clj v1 to be an low friction replacement for `rundis/rewrite-cljs` (actually now living at `clj-commons/rewrite-cljs`) and `xsc/rewrite-clj` v0 (now living a clj-commons/rewrite-clj).\n2. *Feature parity*.\nRewrite-cljs has lagged behind rewrite-clj v0.\nBring rewrite-cljs up to parity with rewrite-clj v0.\nBring any rewrite-cljs specific features over to rewrite-clj v1.\n3. *Preserve type hints*.\nI will respect and carry over existing type hinting in rewrite-clj v0 and rewrite-cljs.\nI will not, at this time, evaluate if existing type hinting has value.\n4. *Improve documentation*.\nI think that rewrite-clj v0 documentation is good, but as I dig deeper into using the library and get feedback on Slack, I see places where guidance could be improved.\n5. *Document design decisions*.\nI'm not sure what form this will take, but I do like projects that include histories of architectural and design decisions.\nPerhaps I'll adopt https://github.com/cljdoc/cljdoc/tree/master/doc/adr[ADR ala cljdoc].\nFor now you can think of this document as I kind of sloppy-mega ADR for my merge work.\n6. *Modernize/update test/build*.\nLook at what is available today and make a choice.\n7. *Define library version scheme*.\nEvaluate options, pick one and document.\n8. *Find home for this work*.\nWe have achieved the ideal here.\nRewrite-clj v1 will continue from the same source repo as rewrite-clj v0.\nWe will also continue to deploy to clojars rewrite-clj/rewrite-clj.\n\n== Strategic Compromises\n1. *Favor single code base*.\nI will favor a single code base over maintaining  http://rundis.github.io/blog/2015/clojurescript_performance_tuning.html[ClojureScript specific optimizations from rewrite-cljs].\nThese can be brought in at a later date if needed.\n2. *Use generic exceptions*.\nThis is technically an API breakage, but I will switch to using the Clojure/ClojureScript agnostic `ex-info` for exceptions.\n3. *Favor rewrite-clj features when there is overlap*.\nI currently only see one feature that overlaps between the two projects.\nRewrite-clj v0 and rewrite-cljs both have positional (row/col) support.\nBase positional support in rewrite-clj v0 is full featured and updates with any changes made, so we'll use it instead of rewrite-cljs's more primitive tools reader based positional support.\nThis technically constitutes an API breakage for rewrite-cljs.\nWe will, though, carry over rewrite-cljs's higher level positional functions.\n\n== Changes\nSee link:../../CHANGELOG.adoc[change log].\n\n=== Detailed API diffs\n\nI've used https://github.com/lread/diff-apis[diff-apis] to compare apis.\nNormally I would have excluded any apis tagged with `:no-doc` metadata, but because many folks used undocumented features in rewrite-clj v0 and rewrite-cljs, I have done a complete comparison of all publics - except where noted.\nEach report contains some observations under the \"Notes\" header.\n\n* link:../generated/api-diffs/rewrite-clj-v0-lang-clj-and-rewrite-cljs-lang-cljs.adoc[rewrite-clj v0 vs rewrite-cljs] API differences between the projects on which rewrite-clj v1 is based.\n* link:../generated/api-diffs/rewrite-clj-v0-lang-clj-and-rewrite-clj-v1-lang-clj.adoc[rewrite-clj v0 vs rewrite-clj v1] how different is rewrite-clj v1 from rewrite-clj v0?\n* link:../generated/api-diffs/rewrite-cljs-lang-cljs-and-rewrite-clj-v1-lang-cljs.adoc[rewrite-cljs vs rewrite-clj v1] how different is rewrite-clj v1 from rewrite-cljs?\n* link:../generated/api-diffs/rewrite-clj-v1-lang-cljs-and-rewrite-clj-v1-lang-clj.adoc[rewrite-clj v1] a look at how cljs and clj sides of rewrite-clj v1 differ\n* link:../generated/api-diffs/rewrite-clj-v1-lang-cljs-and-rewrite-clj-v1-lang-clj-documented-only.adoc[rewrite-clj v1 documented apis only] a look at how cljs and clj sides of rewrite-clj v1 differ for documented apis.\n\n=== Feature Differences\nNo ability to read from files when using rewrite-clj v1 from ClojureScript.\n\n== Root namespace of `rewrite-clj`\n\nBoth rewrite-clj v0 and rewrite-cljs share the same root namespace of `rewrite-clj`.\n\nWe'll happily continue with `rewrite-clj` for rewrite-clj v1 work:\n\n. rewrite-clj v0 was transferred to clj-commons/rewrite-clj\n. rewrite-clj v1 will carry on in clj-commons/rewrite-clj\n. we'll continue to use the existing rewrite-clj v0 clojars maven coordinates `xsc/rewrite-clj` for rewrite-clj v1\n\n[#rewrite-clj-legacy-libs]\n== Projects Using rewrite-clj v0 and/or rewrite-cljs\nI've tried to make note of popular/active projects that make use of rewrite-clj v0 and rewrite-cljs.\nI've linked where I've explicitly verified a migration to rewrite-clj v1.\n\nSee README for up to date list of which libraries directly use so form of rewrite-clj and which ones we are currently link:#canary-testing[canary testing].\n\n[cols=\"15%,20%,20%,55%\"]\n|===\n| Project | rewrite&#8209;clj? | rewrite&#8209;cljs? | Notes\n\n| https://github.com/mauricioszabo/atom-chlorine[chlorine]\n|\n| yes\n| REPL support for Atom editor. +\nI do not see easy to run unit tests for this project.\n\n| https://github.com/borkdude/clj-kondo[clj-kondo]\n| custom version\n|\n| uses an internal custom version of rewrite-clj\n\n| https://github.com/weavejester/cljfmt[cljfmt]\n| yes\n| yes\n| source code formatter\n\n| https://github.com/greglook/cljstyle[cljstyle]\n| yes\n|\n| source code formatter based on cljfmt\n\n| https://github.com/snoe/clojure-lsp[clojure-lsp]\n| yes\n|\n| language server for Clojure\n\n| https://github.com/Olical/depot[depot]\n| yes\n|\n| find newer versions of your deps.edn dependencies\n\n| https://github.com/jonase/kibit[kibit]\n| yes\n|\n| Finds non-idiomatic Clojure code\n\n| https://github.com/xsc/lein-ancient[lein-ancient]\n| yes\n|\n| find newer versions of your lein dependencies\n\n| https://github.com/benedekfazekas/mranderson[MrAnderson]\n| yes\n|\n| Dependency inliner\n\n| https://github.com/jstepien/mutant[mutant]\n| yes\n|\n| Source code mutator\n\n| https://github.com/juxt/pack.alpha[pack (alpha)]\n| yes\n|\n| Clojure project packager\n\n| https://github.com/bhauman/rebel-readline[rebel-readline]\n| indirectly via cljfmt\n|\n| smart editing at at the REPL terminal, optionally used in conjunction with https://github.com/bhauman/figwheel-main[figwheel-main]\n\n| https://github.com/cognitect-labs/REBL-distro[REBL]\n| indirectly via cljfmt\n|\n| graphical interactive tool for browsing Clojure data\n\n| https://github.com/clojure-emacs/refactor-nrepl[refactor-nrepl]\n| yes\n|\n| refactoring support used in conjunction with https://github.com/clojure-emacs/cider[cider]\n\n| https://github.com/mauricioszabo/repl-tooling[repl-tooling]\n|\n| yes\n| base package for Clojure editor tooling. Interesting: uses rewrite-clj.reader directly. +\nI do not see easy to run unit tests for this project.\n\n| https://github.com/atomist-skills/update-leiningen-dependencies-skill[update-leiningen-dependencies-skill]\n|\n| yes\n| dependency version tracker, great for a migration test of a project that uses shadow-cljs\n\n| https://github.com/kkinnear/zprint[zprint]\n| yes\n| yes\n| source code formatter\n\n|===\n\n[#rewrite-clj-v1-libs]\n== Projects Using rewrite-clj v1\n\nSee README for up to date list.\n\n[#canary-testing]\n== Canary Testing\nI'm not sure if canary testing is exactly the right term here.\nMy goal is to know when changes to rewrite-clj v1 break popular libraries.\n\nThis would mean running these libraries' tests against rewrite-clj v1 master.\n\nAfter some experimentation, my general strategy is to:\n\n. Install rewrite-clj HEAD to the local maven repository under a \"canary\" version\n. For each library we want to test:\n.. Grab the a specified release of a project from GitHub via zip download\n.. Patch deps to\n... Point to rewrite-clj canary release\n... Adjust Clojure version if necessary (we are 1.8 and above)\n.. Adjust sources as necessary\n... Ex. rewrite-cljc -> rewrite-clj namespace\n... At the time of the writing only zprint v1.1.1. needed a src code hack to get its tests passing.\nIt is the only lib that digs into namespaced maps, and things changed a tad here for rewrite-clj v1\n.. Run any necessary library test prep steps\n.. Run libraries tests (or a subset of them)\n\n== Tooling\n\n=== Build tools\nI have moved from leiningen to tools cli and `deps.edn`.\nLike everything, this change has pros and cons.\nOverall, I like the simplicity and control it brings.\nBabashka scripts take the place of lein aliases where I can have the build do exactly what I want it to.\n\n=== Continuous integration\nThe future of https://travis-ci.org/[Travis CI] looked a bit tenuous when I started work on rewrite-clj v1.\nI initially switched over to https://circleci.com/[CircleCI], but then when GitHub Actions became available decided it was a better fit:\n\n* in addition to Linux, offers macOS and Windows testing in its free tier\n* 7gb of RAM satisfies GraalVM's memory hungry `native-image`\n\n=== Testing and linting tools\nAfter looking around, I settled on the following for continuous integration:\n\n. https://github.com/lambdaisland/kaocha[Kaocha] for running Clojure unit tests.\n. moved from lein-doo to https://github.com/Olical/cljs-test-runner[cljs-test-runner] (which still uses https://github.com/bensu/doo[doo] under the hood) for running ClojureScript unit tests under node and chrome headless.\nI considered Kaocha's cljs support and will reconsider when it matures a bit.\n. I fail the build when a lint with https://github.com/borkdude/clj-kondo[clj-kondo] produces any warnings and/or errors.\n\nDuring development, I found the following helpful:\n\n. kaocha in watch mode for Clojure\n. figwheel main for ClojureScript\n\n== General Decisions\n\n=== Library version scheme\nI see plenty of version scheme variations out there these days.\nHere are a few examples I find interesting:\n\n[cols=\"10,40,20,~\",options=\"header\"]\n|====\n|Project\n|Scheme\n|Example\n|Observation\n\n|https://github.com/clojure/clojurescript/releases[ClojureScript]\n|major.minor.<commit count since major.minor>\n|`1.10.520`\n|Tracks Clojure version.\n\n|https://github.com/borkdude/clj-kondo/releases[clj-kondo]\n|yyyy-mm-dd-qualifier\n|`2019.07.05-alpha`\n|Freshness built into version.\n\n|https://github.com/cljdoc/cljdoc[cljdoc]\n|major.minor.<commit count>-<short git sha>\n|`0.0.1315-c9e9a73`\n|The short-sha safeguards against any potential confusion with duplicate commit counts for builds on different machines.\n\n|https://github.com/noprompt/meander[meander]\n|meander/<release> 0.0.<commit count>\n|`meander/delta` `0.0.137`\n|This scheme changes the artifact-id (for example gamma to delta) every time a potentially breaking change is introduced effectively releasing a new product for every breaking change.\n\n|https://github.com/clojure/spec.alpha[spec.alpha]\n|unimportant\n|unimportant\n|The alpha state is burnt into the project name and library namespace.\n|====\n\nRewrite-clj v1 is not a new project.\nI feel the version should reflect at least some familiarity with its v0 scheme.\n\nAs of this writing the current version of rewrite-clj is `0.6.1`.\nI am guessing that the 0 is an unused version element, and we have a `0.major.minor` scheme.\n\nRewrite-clj v1 is going to switch to a `major.minor.<commit count>-<qualifier>` scheme. +\nOur first version will be `1.0.451-alpha` where `451` is just a wild guess right now.\n\nAn small awkwardness with this scheme is the change log.\nThe change log should be part of the release but it does reference a git commit count.\nThis will be addressed by automatically updating the change log doc with the release version as part of the release process.\n\n=== Release Strategy\n\nWe'll opt not to make SNAPSHOT releases and assume the community is good with testing pre-releases via GitHub coordinates.\nWe can adapt if there is a real need for SNAPSHOT releases.\n\nWe'll keep a CHANGELOG.adoc carried on from rewrite-clj v0's CHANGES.md.\n\nRelease cadence will be as needed.\nI don't want us to feel precious about releases.\nIf there is a benefit to cutting a new release with a small change or fix, even just to docs, we'll go ahead and do it.\n\n\n=== Source directory layout\nWhen I first started to experiment with a cljc version of rewrite-clj, my directory layout looked like:\n\n----\nsrc/\n  clj/\n    rewrite-clj/\n  cljs/\n    rewrite-clj/\n  cljc/\n    rewrite-clj/\ntest/\n  clj/\n    rewrite-clj/\n  cljs/\n    rewrite-clj/\n  cljc/\n    rewrite-clj/\n----\n\nAfter a certain amount of work, I realized the majority of the code was cljc so opted for the much simpler:\n\n----\nsrc/\n  rewrite-clj/\ntest/\n  rewrite-clj/\n----\n\n===  GraalVM Support\n\nSome command line tools written in Clojure are using Graal to compile to native executables for fast startup times.\n\nOthers have done the work to test that rewrite-clj v0 can be compiled with Graal.\nThere is benefit to the community to test that rewrite-clj v1 can also be compiled to native code with Graal.\n\nNoticing that there were differing approaches Graalifying Clojure, none of them centrally documented, @borkdude and I created https://github.com/lread/clj-graal-docs[clj-graal-docs] to develop and share scripts and tips.\n\nMy goal is to run the rewrite-clj v1 test suite from a GraalVM native image to give some confidence that rewrite-clj v1 works after compiled with Graal.\n\n==== Technical Issues\n\n. Windows tooling requirements.\nSetup for running GraalVM JDK8 on Windows relies on old Microsoft tooling making setup challenging.\n. RAM requirements.\nGraalVM's `native-image` which creates the target executable, can consume a significant amount of RAM.\n\n==== Windows Tooling Requirements\nI've decided that, for now, figuring out how to setup the proper tooling for Windows for GraalVM JDK8 is not worth my effort.\nWe'll continue to test on Windows but only for GraalVM JDK11.\n\n==== Ram Requirements\nI spent quite a bit of time trying to figure out how to overcome the RAM limitations of free tiers of continuous integration services.\nDrone Cloud is the most generous with 64gb of RAM available but only supports Linux.\nCircleCI offers 3.5gb of RAM and is also Linux only in its free tier.\nGitHub Actions, offers 7gb of RAM and offers macOS, Linux and Windows.\n\nI seriously explored two approaches:\n\n. natively compile tests and library\n. interpret tests via sci over natively compile library\n\nIf I had applied https://github.com/lread/clj-graal-docs#native-image-compilation-time[Clojure direct linking] earlier in my tests, I might have stopped at the first approach.\nFor me, direct linking made approach 1 viable.\n\nFor now, I am testing using both approaches.\nOverviews can be found at https://github.com/lread/clj-graal-docs/blob/master/doc/testing-strategies.md[clj-graal-doc's testing strategies page].\n\n== Questionable Decisions\n\n=== Allowing garden style keywords\n\nBorkdude is kind enough to ping me when there are issues with the internally forked version of rewrite-clj he uses for clj-kondo.\nIt turns out that clojure.tools.reader.edn does not parse https://github.com/noprompt/garden[garden-style] keywords such as `:&::before`.\nThe reader sees a double colon as illegal if it is anywhere in the keyword.\nBorkdude overcame this limitation by allowing a keyword to contain embedded double colons via a customized version of ``clojure.tools.reader.edn``'s `read-keyword` function.\n\nI transcribed his work to rewrite-clj v1.\n\nThe maintenance cost to hacking a 3rd party lib is that upgrades will have to be carefully tracked.\nThat said, we do have a good suite of tests that should uncover any issues.\n\n=== Not allowing symbols with multiple slashes\n\nWhile Clojure reads `'org/clojure/math.numeric-tower`, `clojure.tools.reader.edn` barfs on this and therefore rewrite-clj does as well.\n\nIt has been documented as illegal for a symbol to have more than one `/`.\n\nI have opted to not, at this time, adapt rewrite-clj v1 to allow parsing of this illegal syntax.\nThis might seem a bit hypocritical because I did, some time ago, innocently https://github.com/borkdude/clj-kondo/issues/378[raise an issue on clj-kondo for this].\n\n== Clojure/ClojureScript Issues\n\n=== ClojureScript namespace clashes\nClojureScript uses Google Closure under the hood.\nBecause of the way Google Closure handles namespaces, some namespaces that work fine on Clojure clash under ClojureScript.\nSome rewrite-clj v0 namespaces clash for ClojureScript, for example:\n\n* `rewrite-clj.zip/find`\n* `rewrite-clj.zip.find`\n\nThe original rewrite-cljs author worked around this problem by renaming namespaces to avoid the clashes.\n\n[%autowidth]\n|===\n\n.2+h|library .2+h|namespace 3+h|in rewrite-clj v1\nh|namespace h|clj? h|cljs?\n\n|rewrite-clj\n|rewrite-clj.node.coerce\n|rewrite-clj.node.coerce\n|yes\n|no\n\n|rewrite-cljs\n|rewrite-clj.node.coerce[yellow-background]**r**\n|rewrite-clj.node.coercer\n|yes\n|yes\n\n|rewrite-clj\n|rewrite-clj.node.string\n|rewrite-clj.node.string\n|yes\n|no\n\n|rewrite-cljs\n|rewrite-clj.node.string[yellow-background]**z**\n|rewrite-clj.node.stringz\n|yes\n|yes\n\n|rewrite-clj\n|rewrite-clj.zip.edit\n|rewrite-clj.zip.edit\n|yes\n|no\n\n|rewrite-cljs\n|rewrite-clj.zip.edit[yellow-background]**z**\n|rewrite-clj.zip.editz\n|yes\n|yes\n\n|rewrite-clj\n|rewrite-clj.zip.find\n|rewrite-clj.zip.find\n|yes\n|no\n\n|rewrite-cljs\n|rewrite-clj.zip.find[yellow-background]**z**\n|rewrite-clj.zip.findz\n|yes\n|yes\n\n|rewrite-clj\n|rewrite-clj.zip.remove\n|rewrite-clj.zip.remove\n|yes\n|no\n\n|rewrite-cljs\n|rewrite-clj.zip.remove[yellow-background]**z**\n|rewrite-clj.zip.removez\n|yes\n|yes\n\n|rewrite-clj\n|rewrite-clj.zip.seq\n|rewrite-clj.zip.seq\n|yes\n|no\n\n|rewrite-cljs\n|rewrite-clj.zip.seq[yellow-background]**z**\n|rewrite-clj.zip.seqz\n|yes\n|yes\n|===\n\nNone of these namespaces are part of public APIs, but because I see a lot of code that uses these internal namespaces, I decided to preserve the existing rewrite-clj v0 and rewrite-cljs naming for rewrite-clj v1.\n\n=== Clojure/ClojureScript Interop\n\n* Where I felt I could get away with it, I localized Clojure/ClojureScript differences in the new `rewrite-clj.interop` namespace.\n* Although technically an API breakage, I made a choice to switch all rewrite-clj v0 thrown exceptions to the Clojure/ClojureScript compatible ex-info for rewrite-clj v1.\n* Some notes on differences between Clojure and ClojureScript\n** throws and catches, if not using ex-info are different\n** namespace requires cannot use shorthand syntax in cljs\n** macros must (sometimes) be included differently\n** IMetaData and other base types differ (this comes into play for us in coercion support)\n** format not part of cljs standard lib\n** no Character in cljs\n** no ratios in cljs\n** testing for NaN is different\n** different max numerics\n\n== Rewrite-clj/cljs Analysis\n\n=== What is the public API?\nrewrite-clj v0 purposefully only generated documentation for specific namespaces.\nIt is reasonable to assume that these namespaces represent the public API:\n\n* `rewrite-clj.parse`\n* `rewrite-clj.node`\n* `rewrite-clj.zip`\n\nI am not sure why `rewrite-clj.custom-zipper` is included in the documented public API, because its functionality is exposed through `rewrite-clj.zip`, I expect this was perhaps an oversight, but might be wrong.\n\nBecause what is public versus what is private was not stressed strongly in the rewrite-clj v0 README, I frequently see private APIs used in code.\nFor this reason, I've worked, within reason, not to break what I understand to be private APIs.\n\n=== S-expressions\nrewrite-clj allows parsed Clojure/ClojureScript/EDN to be converted back and forth to s-expressions.\nExample from a REPL session:\n\n[source,clojure]\n----\n(require '[rewrite-clj.zip :as z])\n\n(def zipper (z/of-string \"[1 2 3]\"))  ;; <1>\n(pr zipper)\n=stdout=> [<vector: [1 2 3]> {:l [], :pnodes [<forms: [1 2 3]>], :ppath nil, :r nil}]\n\n(def s (z/sexpr zipper)) ;; <2>\ns\n=> [1 2 3]\n\n(require '[rewrite-clj.node :as n])\n(pr (n/coerce s)) ;; <3>\n=stdout=> <vector: [1 2 3]>\n----\n<1> parse string to rewrite-clj nodes and create zipper\n<2> convert rewrite-clj node at current location in zipper to s-expression\n<3> convert s-expression to rewrite-clj node\n\nWhile I expect this can be quite convenient, it does come with caveats:\n\n1. What happens when we try to `sexpr` Clojure specific features from ClojureScript?\nFor example, ratios are available in Clojure but not ClojureScript.\n2. If you try to `sexpr` something that cannot be converted into an s-expression an exception will be thrown.\n\nMy guidance is use `sexpr` in only in specific cases, where you know ahead of time what you are parsing.\nGeneral blind use of `sexpr` is not recommended.\n\nFor rewrite-clj v1 itself, I have removed internal problematic uses of `sepxr` and documented some of its nuances.\n\n=== Which reader?\nRewrite-clj makes use of Clojure's reader.\nThere are a few choices though:\n\n1. `clojure.tools.reader`\n2. `clojure.tools.reader.edn`\n3. `clojure.reader`\n4. `clojure/reader-string`\n\nAs I understand it, `clojure.tools.reader.edn` is the safest choice and rewrite-clj v1 uses it in all cases.\n\n=== Potemkin import-vars\nRewrite-clj v0 makes use of a slightly modified version of https://github.com/ztellman/potemkin#import-vars[Potemkin import-vars].\nThe intent of import-vars is to make it easy to expose a public API from a set of internal namespaces.\n\nWhen I first reviewed its usage in rewrite-clj, I found import-vars to be quite elegant.\nI have since learned that there is quite a bit of strong opinion in the Clojure community surrounding import-vars.\nNot all of it is rosy.\n\nAlso, there is no ClojureScript version of import-vars.\n\n==== What I started with\nThat said, I decided, in the beginning, to honor the original rewrite-clj codebase and carry on with it.\nTo be honest, this gave me the (the apparently too tempting to resist) opportunity to learn how to write a version of import-vars for ClojureScript.\n\nThis led me to discover that while cljdoc did cope fine with import-vars trickery for Clojure code, it did not have any support for it for ClojureScript code.\nI made the necessary changes to cljdoc's fork of codox and subsequently cljdoc-analyzer.\n\nI also extended import-vars to rewrite-clj's purposes by adding a facility to rename imported vars and adapt docstrings.\n\nAll was not rainbows and unicorns, after yet another issue with some Clojure tooling, I decided to drop import-vars.\n\n==== What I ended up with\nI still like the concept of import-vars.\nIt automatically exposes an API and helps me to avoid silly human errors that would occur should I do this manually for rewrite-clj's wide APIs.\n\nThe issues with potemkin import-vars happen because vars are imported at load-time.\nI have moved to handling import-vars at build time.\nA build step reads reads an import-vars definition and generates appropriate source.\nThis moves the burden from rewrite-clj users to rewrite-clj developers, which seems appropriate.\n\nFirst stab:\n\n* Stick with an import-vars-ish syntax.\nMaybe a clj-kondo-ish style syntax `#_{:import-vars/import {:from [[my.ns1 var1 var2 var3] [my.ns2 var4 var5])}}`.\nPerhaps we can tease out a tool someday that is generally useful.\n* Was thinking of having the build step update source in place, but @borkdude shared an idea of using templates.\nOptions:\n\n** Maybe have `src/rewrite_clj.zip.template.cljc` that generates/overwrites `src/rewrite_clj/zip.cljc`.\n** Or a sister dir structure `template/rewrite_clj/zip.cljc` -> `src/rewrite_clj/zip.cljc`.\nI'll start with this, it:\n*** keeps templates separate from source.\nNot great for locality, but makes excluding them from release easier.\n*** keeps the ns name the same for template and target.\n\nLoses from moving to build-time solution:\n\n. When you click on view source on cljdoc you go to the implementation and see the code.\nNow you'll be directed to the delegator.\nThis won't be bothersome from an IDE, most will like it better, you'll be able to flit from delegator to the implementation easily, but a loss from cljdoc.\n. An extra build step is required.\nThis moves the burden from the user to the developer.\nI'm ok with this.\n. Potentially an extra call.\nWill this even register as a performance hit?\n\nCurrent import-vars usage.\nI don't always use import-vars to expose a public API, I sometimes use it internally to avoid human error.\nFor example `rewrite-clj.node.string` imports from `rewrite-clj.node.stringz`; the 2 namespaces exist due to API namespace collision issues in cljs.\n\nSo what would be a good name for the build step?\nMaybe `apply-import-vars gen-code`?\n\nI think we'd also want something to read-only verify that the template generated clj is different than the target.\nWe can fail CI build if this is true.\nMaybe `apply-import-vars check`?\n\nHow will we find templates?\nWe'll start with storing all templates under `./template`\n\nHow will we choose target for templates?\nWe'll start `./src` using, otherwise using same template filename.\nExtension will match template (clj vs cljc for us).\n\nOk, so what code should we be generating?\nWe want to definitely bring over the docstring (sometimes altered).\nWe'll have the import definition specify `:added` and `:deprecated` metadata.\n(Original version had this metadata specified on internal source var, cljs compiler warned about calls to internal deprecated fns from public API, which was not nice for folks using rewrite-clj under cljs).\nFor the var itself we have choices.\n\n. We could simply point to the source var.\nThis is effectively what we do with current import-vars at load-time.\n. We could generate a delegating fn matching the source arities.\nThis would probably be more familiar to folks, and many static analysis tooling?\nI'll start with this.\n\nAnd how will I find the info I need?\nThe build step will be Clojure and run under the JVM, the targets are all clj or cljc, so I think we are good.\nI could use clj-kondo analysis data, but I don't think that is necessary.\n\nWhat types of vars am I importing?\n\n* functions - covered above.\nNote that I am also importing fns from protocols.\nNot sure if that complicates - think we'll be OK.\n* macros - I guess I'll create a delegating macro.\n* dynamic vars - I don't think I have any of these anymore, so skip for now.\n\nI think I'll repeat, in comments, throughout the generated source that source is generated and from what template.\nJust to try to avoid edits in generated source.\n\nGenerated source will be checked in like all other source.\n\nVerification:\n\n* run diff-apis will will save cljdoc-analyzer output to .diff-apis/.cache.\nSave the .cache.\n* after changes verify that cljdoc-analyzer output is same.\n** we expect `:file` and `:line` meta to be different for statically imported items\n\nAnd what technology will we use to rewrite Clojure source?\nWell... rewrite-clj seems like a good fit.\nFor now, I will use master rewrite-clj to generate rewrite-clj sources from templates.\nTo achieve this, I'll use non generated sources only.\nAnd I'll adapt rewrite-clj to only use non-generated sources itself.\nExcept for paredit, it is really a higher level API, and I don't want to uglify it by using rewrite-clj internal nses.\n\nWe can adapt if my initial solution has warts.\n\n=== Potemkin defprotocol+\nRewrite-clj v0 used a customized version for potemkin defprotocol+.\nIt could be that I missed something, but I did not see how it would benefit rewrite-clj v1.\nIn the spirit of simplifying a cljc code-base, I turfed defprotocol+ in favour of plain old defprotocol.\n\nWe can reintroduce defprotocol+ if we learn that it does actually help with performance significantly.\n\n=== Positional support\nRewrite-clj v0:\n\n1. added a custom zipper to optionally track row/col within Clojure/ClojureScript/EDN files.\n2. expresses positions as a `[row-number col-number]` vector.\n\nRewrite-cljs:\n\n1. made use of the positional support provided by Clojure tools reader.\n2. exposed a couple of functions to search by position.\n3. expressed positions as a `{:row row-number :col col-number}` map\n\nBecause the positional support in rewrite-clj v0 tracks row/col even after zipper modifications, we use it in rewrite-clj v1 instead of rewrite-cljs's implementation.\nWe:\n\n1. continue to support both rewrite-clj v0 vector and rewrite-cljs map notations for positions on function parameters.\n2. use vector notation for position on function returns.\nI personally prefer the map notation, but, as a rule, favor rewrite-clj v0 over rewrite-cljs because rewrite-clj v0 is the more widely used library and thus changes affect more users.\n3. include rewrite-cljs's positional functions: `rewrite-clj.zip/find-last-by-pos` and `rewrite-clj.zip/find-tag-by-pos`.\n\nThe most glaring breaking change for ClojureScript is that it must now create the zipper with positional support enabled, for example: `(z/of-string \"[1 2 3]\" {:track-position true})`\n\n=== link:namespaced-elements.adoc[Namespaced maps and keywords]\n",
       :cljdoc.doc/type :cljdoc/asciidoc,
       :slug "merging-rewrite-clj-and-rewrite-cljs",
       :cljdoc.doc/contributors ("lread")},
      :children
      [{:title "Namespaced Elements",
        :attrs
        {:cljdoc.doc/source-file "doc/design/namespaced-elements.adoc",
         :cljdoc/asciidoc
         "= Namespaced elements\n:toc:\n:toclevels: 6\n\nHerein we study what rewrite-clj and rewrite-cljs currently do for namespaced elements and explore our options for rewrite-clj v1.\n\nYou will see a focus on `sepxr` in this document; it is the primary challenge in supporting namespaced elements.\n\n== Nomenclature\n\n*Namespaced Elements* +\nClojure docs describe namespaced elements but I did not see clear terms defined.\nAlex Miller helped out on Slack, I will use:\n\n|===\n| term | my shorthand | keyword example | map example\n\n| _unqualified_\n|\na| `:foo`\na| `{:x 10}`\n| _qualified_ +\n\n |\na| `:prefix-ns/foo`\na| `#:prefix-ns{:a 1}`\n\n| _auto-resolved current namespace qualified_\n| _current-ns qualified_\na| `::foo`\na| `#::{:b 2}`\n\n| _auto-resolved namespace alias qualified_\n| _ns-alias qualified_\na| `::ns-alias/foo`\na| `#::ns-alias{:c 3}`\n\n|===\n\nSee:\n\n* https://blog.jeaye.com/2017/10/31/clojure-keywords/[Jeaye's blog] for a refresher on namespaced keywords.\n* https://clojure.atlassian.net/browse/CLJ-1910[CLJ-1910] for details on namespaced maps.\n* https://groups.google.com/g/clojure/c/i770QaIFiF0/m/v63cZgrlBwAJ[Terminology and some history from Alex Miller]\n\n\nBecause the nuances of namespaced maps are not widely known by even the most experienced Clojure developers, I'll paste a subset of CLJ-1910 examples here.\nThe `_` prefix and the fact that namespaced maps qualify symbols in addition to keywords is not widely understood:\n\n// some of these will resolve to the current ns which is not user for test-doc-blocks, so skip\n// :test-doc-blocks/skip\n[source, Clojure]\n----\n;; same as above - notice you can nest #: maps and this is a case where the printer roundtrips\nuser=> #:person{:first \"Han\" :last \"Solo\" :ship #:ship{:name \"Millenium Falcon\" :model \"YT-1300f light freighter\"}}\n#:person{:first \"Han\" :last \"Solo\" :ship #:ship{:name \"Millenium Falcon\" :model \"YT-1300f light freighter\"}}\n\n;; effects on keywords with ns, without ns, with _ ns, and non-kw\nuser=> #:foo{:kw 1, :n/kw 2, :_/bare 3, 0 4}\n{:foo/kw 1, :n/kw 2, :bare 3, 0 4}\n\n;; auto-resolved namespaces (will use the current namespace, in this case, user as the ns)\nuser=> #::{:kw 1, :n/kw 2, :_/bare 3, 0 4}\n{:user/kw 1, :n/kw 2, :bare 3, 0 4}\n\n;; auto-resolve alias s to clojure.string\nuser=> (require '[clojure.string :as s])\nnil\nuser=> #::s{:kw 1, :n/kw 2, :_/bare 3, 0 4}\n{:clojure.string/kw 1, :n/kw 2, :bare 3, 0 4}\n\n;; to show symbol changes, we'll quote the whole thing to avoid evaluation\nuser=> '#::{a 1, n/b 2, _/c 3}\n{user/a 1, n/b 2, c 3}\n----\n\n*ClojureScript Flavors* +\nClojureScript has two flavors for which I've not found definitive unique terms.\nI'll use the following:\n\n[cols=\"15%,85%\"]\n|===\n| term | description\n\n| _Regular ClojureScript_ | The regular old JVM compiled ClojureScript that most folks are familiar with.\n| _Self-hosted ClojureScript_ | ClojureScript that is compiled by ClojureScript, also known as bootstrap ClojureScript.\nSelf-hosted ClojureScript can make runtime use of features that are only available at compile time in _Regular ClojureScript_.\nSelf-hosted ClojureScript behaves similarly to Clojure around namespaces.\n|===\n\n== What happens now in rewrite-clj v0 and rewrite-cljs?\n\n=== General use of sexpr in rewrite-clj\nThe `sexpr` function is used to convert a rewrite-clj node to a Clojure form.\nClojure forms are more familiar and can be easier to work with than rewrite-clj nodes.\n\nRewrite-clj's `sexpr` is also used internally in functions like `find-value`, `find-next-value` and `edit` and some paredit functions inherited from rewrite-cljs.\n\nThe following rewrite-clj nodes throw an exception for `sexpr` which is sensible and is as-designed.\n\n- comment\n- whitespace\n- uneval, which is rewrite-clj's term for `#_`\n\n=== Sexpr support for namespaced elements in rewrite-clj v0 and rewrite-cljs\n_Auto-resolved_ keywords have been around https://groups.google.com/g/clojure/c/i770QaIFiF0/m/v63cZgrlBwAJ[since at least Clojure 1.0, which was released in May 2009].\nhttps://github.com/clojure/clojure/blob/master/changes.md#12-support-for-working-with-maps-with-qualified-keys[Namespaced maps were introduced in Clojure 1.9, released in December 2017].\nWhen you take into account that rewrite-clj was released in 2013 and rewrite-cljs in 2015, we can understand why support for newer features is spotty.\n\n[cols=\"10%,10%,20%,20%,20%,20%\"]\n|===\n2.2+h| element 2+h| rewrite-clj v0 2+h| rewrite-cljs\nh|parse h|sexpr h|parse h|sexpr\n\n1.3+|keyword | _qualified_ +\n`:prefix/foo`\n| supported\n| supported\n| supported\n| supported\n\n| _current&#8209;ns&nbsp;qualified_ +\n`::foo`\n| supported\n| supported, +\n⚠️ *resolves via* `\\*ns*`\n| supported\n| ⚠️ *throws*\n\n| _ns-alias&nbsp;qualified_ +\n`::alias/foo`\n| supported\n| ⚠️ *incorrectly returns* `:alias/foo` for `::alias/foo`\n| supported\n| ⚠️ *incorrectly returns* `:alias/foo` for `::alias/foo`\n\n1.3+|map | _qualified_ +\n`#:prefix{:a 1}`\n| supported\n| supported\n| ⚠️ *somewhat supported with generic reader macro node*\na| ⚠️ *returns* `(read&#8209;string \"#:prefix{:a&nbsp;1}\")`\n\n| _current&#8209;ns&nbsp;qualified_ +\n`#::{:b 2}`\n| ⚠️ *throws*\n| ⚠️ *not applicable, +\ncan't parse*\n| ⚠️ *throws*\n| ⚠️ *not applicable, +\ncan't parse*\n\n| _ns-alias&nbsp;qualified_ +\n`#::alias{:c 3}`\n| supported\na| ⚠️ awkwardly supported, +\n*resolves via* +\n`(ns&#8209;aliases&nbsp;\\*ns*)`\n| ⚠️ *somewhat supported with generic reader macro node*\na| ⚠️ *returns* `(read&#8209;string \"#::alias{:c&nbsp;3}\")`\n\n|===\n\n== Options for rewrite-clj v1\n\n[cols=\"15%,5%,40%,40%\"]\n|===\n| status | ref |option | primary impact / notes\n\n| ❌ rejected\n| 1\n| Do nothing\na| * both Clojure and ClojureScript users can't fully parse Clojure/ClojureScript code.\n\n| ❌ rejected\n| 2\na| Support parsing and writing, but throw on `sexpr`\na| * breaks existing API compatibility\n* makes general navigation with certain rewrite-clj functions impossible\n\n| ✅ current choice\n| 3\na| Support parsing, writing.\nHave `sexpr` rely on user provided namespace info.\na| * seems like a good compromise\n\n| ❌ rejected\n| 4\na| Same as 3 but also ensure backward compatibility with current rewrite-clj implementation\na| * decided that backward compatibility for namespaced keywords sexpr is too awkward\n* we'll not entertain backward compatibility for namespaced maps\n\n| ❌ rejected\n| 5\na| Same as 4 but include a rudimentary namespace info resolver that parses namespace info from source\na| * had a good chat with borkdude on Slack and concluded that a namespace info resolver:\n** is a potential link:#sexpr-rabbit-hole[rabbit hole] (well, not potential - if only you knew the number of times I rewrote this section!)\n** could be a separate concern that is addressed if there is a want/need in the future.\n\n|===\n\nOption #4 was a candidate, but decided against maintaining/explaining the complexity the current rewrite-clj implementation.\n\n[#sexpr-rabbit-hole]\n=== The Rabbit Hole - Automatically Calculating sexpr for Auto-resolved Elements\n****\nParsing and writing namespaced elements seems relatively straightforward, but automatically parsing and returning a technically correct `sexpr` for _auto-resolved_ namespaced elements is a rabbit hole that we'll reject for now.\n\nLet's tumble down the hole a bit to look at some of the complexities that _auto-resolved_ namespaced elements include:\n\n1. The `sexpr` of a _current-ns qualified_ element will be affected by the current namespace.\n2. The `sexpr` of an _ns-alias qualified_ element will be affected by loaded namespaces aliases.\n3. The `sexpr` of any namespace element can be affected by reader conditionals:\n\n* within ns declarations\n* surrounding the form being ``sexpr``ed which can be ambiguous in absence of parsing context of the _Clojure platform_ (clj, cljs, cljr, sci)\n\n4. In turn, the current namespace can be affected by:\n\n* `ns` declaration\n* binding to `\\*ns*`\n* `in-ns`\n\n5. Loaded namespace aliases can be affected by:\n\n* `ns` declaration\n* `require` outside `ns` declaration\n\n6. I expect that macros can be used for generation of at least some of the above elements.\n\n7. Other aspects I have not thought of.\n\nI see one example from the wild of an attempt to parse `ns` declarations from Clojure in cljfmt.\nCljfmt can parse `ns` declarations from source code from which it extracts an alias map.\nWhile parsing `ns` declarations might work well for cljfmt, we won't entertain it for rewrite-clj v1.\n\n****\n\n== What will we do for rewrite-clj v1?\n\nRewrite-clj v1 can easily support `sexpr` on elements where the context is wholly contained in the form.\n_Auto-resolved_ namespaced elements are different.\nThey depend on context outside of the form; namely the current namespace and namespace aliases.\n\nRewrite-clj v1 will:\n\n* NOT take on evaluation of the Clojure code it is parsing to determine namespace info.\nIt will be up to the caller to optionally specify the current namespace and namespace aliases.\n\n* NOT offer any support for reader conditionals around caller provided namespace info\n** caller specified namespace info will not distinguish for _Clojure platforms_ (clj, cljs, cljr, sci)\n** an `sexpr` for a namespaced element will NOT evaluate differently if it is wrapped in a reader conditional\n\n* assume that callers will often have no real interest in an technically correct `sexpr` on _auto-resolved_ namespaced elements.\nThis means that it will return a result and not throw if the namespace info is not provided/available.\n\n* break rewrite-clj compatibility for namespaced maps.\nIt was a late and incomplete addition to rewrite-clj.\n** The prefix will be stored in a new `map-qualifier-node`.\nPreviously the prefix was stored as a keyword.\n** Unlike rewrite-clj, rewrite-clj v1 will not call `(ns-aliases \\*ns*)` to lookup namespace aliases.\n\n* break rewrite-clj compatibility for keywords:\n** node field `namespaced?` will be renamed to be `auto-resolved?` to represent what it really is (a grep.app search suggests this won't be impacting)\n** will no longer do any lookups on `*ns*`.\n\n* break compatibility for `sexpr` on some namespaced elements, in that it will:\n** no longer throw for formerly unsupported variants\n** have the possibility of returning a more correct Clojure form\n\n* NOT preserve compatibility for `sexpr` under the following questionable scenarios, we'll:\n** NOT fall back to `\\*ns*` if the current namespace is not specified by caller.\n** NOT return `:alias/foo` for _ns-alias qualified_ keyword `::alias/foo` when namespace aliases are not specified by caller.\n\n* forgetting about `sexpr`, whatever implementation we choose, rewrite-clj v1 must continue to emit the same code as parsed.\nThis should return `true` for any source we throw at rewrite-clj v1:\n+\n\n// {:test-doc-blocks/reader-cond :clj}\n[source,Clojure]\n----\n(require '[rewrite-clj.zip :as z])\n(def source (slurp \"https://raw.githubusercontent.com/clj-kondo/clj-kondo/v2020.12.12/src/pod/borkdude/clj_kondo.clj\"))\n(= source (-> source z/of-string z/root-string))\n=> true\n----\n+\nNote: an exception in equality might be newlines, which rewrite-clj v1 might normalize.\n\n=== Platform Support\n\nRewrite-clj v1 supports the following Clojure platforms:\n\n* Clojure\n* _Self-Hosted ClojureScript_\n* _Regular ClojureScript_\n\nIt also supports Clojure source that includes a mix of the above in `.cljc` files.\n\nOur solution will cover all the above and also be verified when GraalVM natively compiled rewrite-clj v1 and a rewrite-clj v1 exposed via sci.\n\n[#sexpr-behavior]\n=== Sexpr Behaviour\n\nThe caller will optionally convey a namespace `:auto-resolve` function in `opts` map argument.\n\nThe `:auto-resolve` function will take a single `alias` lookup arg, `alias` will be:\n\n- `:current` for a request for the current namespace\n- otherwise a request for a lookup for namespaced aliased by `alias`\n\nIf not specified, `:auto-resolve` will default a function that resolves:\n\n- the current namespace to `?\\_current-ns_?`\n- an aliased namespaced `x` to `??\\_x_??`\n\nThe optionally `opts` arg will be added to the existing `(rewrite-clj/node/sexpr node)`\n\nIf a caller wants their `:auto-resolve` function to make use of `\\*ns*` and/or `(ns-aliases \\*ns*)` that's fine, but unlike rewrite-clj v0, rewrite-clj v1 will not reference `\\*ns*`.\n\nMy guess is that the majority of rewrite-clj v1 users will not make use of `:auto-resolve`.\n\n[cols=\"20%,80%\"]\n|===\n|Condition | Result\n\n\na| `:auto-resolve` not specified\na|\n[source,Clojure]\n----\n(require '[rewrite-clj.node :as n]\n         '[rewrite-clj.parser :as p])\n\n(-> (p/parse-string \"::foo\") n/sexpr)\n;; => :?_current-ns_?/foo\n(-> (p/parse-string \"#::{:a 1 :b 2}\") n/sexpr)\n;; => {:?_current-ns_?/a 1 :?_current-ns_?/b 2}\n(-> (p/parse-string \"::str/foo\") n/sexpr)\n;; => :??_str_??/foo\n(-> (p/parse-string \"#::str{:a 1 :b 2}\") n/sexpr)\n;; => {:??_str_??/a 1 :??_str_??/b 2}\n----\n\na| `:auto-resolve` specified\na|\n[source,Clojure]\n----\n(require '[rewrite-clj.node :as n]\n         '[rewrite-clj.parser :as p])\n\n(def opts {:auto-resolve (fn [alias]\n                            (get {:current 'my.current.ns\n                                  'str 'clojure.string}\n                                 alias\n                                 (symbol (str alias \"-unresolved\"))))})\n\n(-> (p/parse-string \"::foo\") (n/sexpr opts))\n;; => :my.current.ns/foo\n(-> (p/parse-string \"#::{:a 1 :b 2}\") (n/sexpr opts))\n;; => {:my.current.ns/a 1 :my.current.ns/b 2}\n(-> (p/parse-string \"::str/foo\") (n/sexpr opts))\n;; => :clojure.string/foo\n(-> (p/parse-string \"#::str{:a 1 :b 2}\") (n/sexpr opts))\n;; => {:clojure.string/a 1 :clojure.string/b 2}\n----\n|===\n\nA benefit of `:auto-resolve` being a function rather than data, is flexibility.\nMaybe a caller would like the resolver to throw on an unresolved alias.\nCallers are free to code up whatever they need.\n\n=== Sexpr on a Key in a Namespaced Map\n\nTo support `sexpr` when navigating down to a key in a namespaced map, the key will hold the namespaced map context, namely a copy of the namespaced map qualifier.\n\nThis context will appropriately applied to symbols and keyword keys in namespaced maps:\n\n* at parse time\n* when node children are updated\n\nThe zip API applies updates when moving up through the zipper.\nThe update includes replacing children.\nTherefore the context will be reapplied to namespaced map keys when moving up through the zipper.\n\nWe'll provide some mechanism for zipper users to reapply the context throughout the zipper.\nThis will remove context from any keywords and symbols that are no longer under a namespaced map.\n\nNot sure what we'll provide for non-zipper users.\nPerhaps just exposing a clear-map-context for keyword and symbol nodes would suffice.\n\n=== Sexpr Behaviour from the zip API\n\nThe `rewrite-clj.zip` v0 API exposes functions that make use of `sexpr`:\n\n- `sexpr` - directly exposes `rewrite-clj.node/sexpr` for the current node in zipper\n- `find-value` - uses `sexpr` internally\n- `find-next-value` - uses `sexpr` internally\n- `edit-node` - uses `sexpr` internally\n- `get` - uses `find-value` internally\n\nMost of these functions lend themselves to adding an optional `opts` map for our `:auto-resolve`.\nUnfortunately `edit-node` is variadic.\n\nBecause all zip API functions operate on the zipper, I'm thinking that we could simply hold the `:auto-resolve` in the zipper.\n\nThis idea is already in play to for `:track-position?`.\n\n=== Node Creation\nThe primary user of rewrite-clj's node creation functions is the rewrite-clj parser.\nThe functions are also exposed for general use.\nGeneral usability might not have been a focus.\n\n==== Namespaced Map Node\n\nWe tweak rewrite-clj v0's `namespaced-map-node`.\n\nThe children will remain:\n\n* prefix\n* optional whitespace\n* map\n\nThe prefix will now be encoded as a new `map-qualifier-node` node which will have `auto-resolved?` and `prefix` fields.\nThis cleanly and explicitly adds support for auto-resolve current-ns namespaced maps which will be expressed with `auto-resolved?` as `true` and a `nil` `prefix`.\n\n==== Keyword Node\nThe current way to create namespaced keyword nodes works, but usage is not entirely self-evident:\n[source,clojure]\n----\n(require '[rewrite-clj.node :as n])\n\n;; unqualified\n(n/keyword-node :foo false)           ;; => \":foo\"\n;; literally qualified\n(n/keyword-node :prefix-ns/foo false) ;; => \":prefix-ns/foo\"\n;; current-ns qualified\n(n/keyword-node :foo true)            ;; => \"::foo\"\n;; ns-alias qualified\n(n/keyword-node :ns-alias/foo true)   ;; => \"::ns-alias/foo\"\n----\n\nUse of booleans in a function signature with more than one argument rarely contributes to readability but we'll stick with these functions for backward compatibility.\n\nLet's study the rewrite-clj v0 `KeywordNode` which currently has fields `k` and `namespaced?`.\n\n// we broke this in v1 by renaming :namespaced to :auto-resolved? so have test-doc-blocks skip this block\n// :test-doc-blocks/skip\n[source,clojure]\n----\n(require '[rewrite-clj.parser :as p]\n         '[rewrite-clj.node :as n])\n\n(-> (p/parse-string \":kw\") ((juxt :k :namespaced?)))\n;; => [:kw nil]\n(-> (p/parse-string \":qual/kw\") ((juxt :k :namespaced?)))\n;; => [:qual/kw nil]\n(-> (p/parse-string \"::kw\") ((juxt :k :namespaced?)))\n;; => [:kw true]\n(-> (p/parse-string \"::alias/kw\") ((juxt :k :namespaced?)))\n;; => [:alias/kw true]\n----\n\n* The `namespaced?` field is, in my opinion, misnamed and should be `auto-resolved?`.\nAs of this writing https://grep.app/search?q=%3Anamespaced%3F[a grep.app for :namespaced?] returns only clj-kondo and it uses its own custom version of rewrite-clj.\nI think I could get away with renaming `namespaced?` to `auto-resolved?` for rewrite-clj v1\n* The `prefix` is not stored separately, it is glommed into keyword field `k`.\n** This is ok for `:qual/kw` but, in my opinion, awkward for auto-resolved variants.\n** We'll preserve this storage behavior for backward compatibility.\nI will NOT look into adding a `prefix` field for consistency with maps at this time.\n\n==== Symbol Node\nFor rewrite-clj v1, we'll separate out a new SymbolNode out from under rewrite-clj v0's TokenNode.\n\nIt is probably simplest to have the existing `token-node` creator fn simply create a SymbolNode when passed value is a Clojure symbol.\n\n==== Symbol and Keyword Context\n\nIn rewrite-clj v1, the SymbolNode and KeywordNode will be MapQualifiable.\nThis means they will have `(set-map-context map-qualifier-node)` and `(clear-map-context)` functions.\n\nI don't think we need to expose the methods to our APIs but am not sure yet.\nIf we do, we might need a `(get-map-context)`.\nWhy not just update/retrieve via the `map-qualifier-node` node field?\nClojure turns a record into a map when a `dissoc` is done on a field, and I think abstracting away from that nuance makes sense.\n\n=== Node Traversal\n\nKeyword node traversal will remain unchanged (no new child nodes).\n\nNamespaced map node traversal remains unchanged except:\nThe prefix is now stored as a `map-qualifier-node`, in rewrite-clj the prefix was encoded in a keyword.\n\n=== Node Interrogation\n\n* `keyword-node?` - return true if rewrite-clj node and keyword node\n* `symbol-node?` - return true if rewrite-clj node and symbol node\n* Both `keyword-node` and `map-qualifier-node` will have:\n** `auto-resolved?` field\n\n=== Notes on Coercion\nRewrite-clj supports automatic coercion, how does this look in the context of namespaced elements?\nI'm not proposing any changes here, just demonstrating how things work.\n\nIf we try to explicitly coerce a namespaced element, we must remember that the Clojure reader will first evaluate in the context of the current ns before the element is converted to a node.\n\n[source,clojure]\n----\n(require '[clojure.string :as str]\n         '[rewrite-clj.node :as n])\n\n(-> (n/coerce :user/foo) n/string) ;; => \":user/foo\"\n(-> (n/coerce ::foo) n/string) ;; => \":user/foo\"\n(-> (n/coerce ::str/foo) n/string) ;; => \":clojure.string/foo\"\n----\n\nFor namespaced maps, the experience is the same:\n\n[source,clojure]\n----\n(require '[clojure.string :as str]\n         '[rewrite-clj.node :as n])\n\n(-> (n/coerce #:user{:a 1}) n/string) ;; => \"{:user/a 1}\"\n(-> (n/coerce #::{:b 2}) n/string)  ;; => \"{:user/b 2}\"\n(-> (n/coerce #::str{:c 3}) n/string) ;; => \"{:clojure.string/c 3}\"\n----\n\n== Misc Questions\nQuestions I had while writing doc.\n\n*Q:* Does the act of using find-value sometimes blow up if hitting an element that is not sexpressable? +\n*A:* Nope, find-value only searches token nodes and token nodes are always sexpressable (well after we are done our work they should be).\n",
         :cljdoc.doc/type :cljdoc/asciidoc,
         :slug "namespaced-elements",
         :cljdoc.doc/contributors ("lread")}}]}
     {:title "API Differences",
      :attrs {:slug "api-differences"},
      :children
      [{:title "rwt-clj v0 vs rwt-cljs",
        :attrs
        {:cljdoc.doc/source-file
         "doc/generated/api-diffs/rewrite-clj-v0-lang-clj-and-rewrite-cljs-lang-cljs.adoc",
         :cljdoc/asciidoc
         "// This file was auto-generated by diff-apis, best not to edit\n= pass:c[Diff of rewrite-clj 0.6.1 clj &  rewrite-cljs 0.4.5 cljs]\n:toc: macro\n:toclevels: 5\n:!toc-title:\n\n**Diff of apis in:**\n\nA. `+rewrite-clj+` `+0.6.1+` `+clj+`\nB. `+rewrite-cljs+` `+0.4.5+` `+cljs+`\n\n**Options**:\n\n[cols=\"1,3\"]\n|===\n| Option | Value\n\nl|:arglists-by\nl|:arity-only\n\nl|:include\nl|:changed-publics\n\n|===\n**Legend:**\n\n* [red]`*-*`[red]#pass:c[A only]#\n* [green]`*+*`[green]#pass:c[B only]#\n* [red]`*-*`[red]#pass:c[A is]#[green]`*+*`[green]#pass:c[different from B]#\n* [black]`*≠*`[black]#pass:c[changes within A and B]#\n* [black]`*=*`[black]#pass:c[equal]#\n\n**Stats:**\n\n|===\n| Element | Have [red]#pass:c[changes]# [green]#pass:c[within]# | [red]#pass:c[In A Only]# | [green]#pass:c[In B Only]#\n\n| namespaces\n| 20\n| 15\n| 8\n\n| publics\n| 100\n| 170\n| 79\n\n| arglists\n| 0\n| 298\n| 88\n\n|===\n**Notes:**\n\nThe apis of the last released version of rewrite-cljs and the last released version of rewrite-clj v0 are compared here.\n\nIn short, rewrite-cljs lagged far behind rewrite-clj v0, but rewrite-cljs had added some features of its own.\n\nSee link:../../design/01-merging-rewrite-clj-and-rewrite-cljs.adoc[rewrite-clj v1's design docs] for more details.\n\n**Table of diffs:**\n\ntoc::[]\n== [red]`*-*` [red]#pass:c[rewrite-clj.custom-zipper.core]#\n\n[unstyled]\n\n=== [red]`*-*`[red]#pass:c[append-child]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2836+` [red]`+G__2837+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[branch?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2769+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[children]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2772+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[custom-zipper]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+root+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [red]`*-*`[red]#pass:c[custom-zipper?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+value+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [red]`*-*`[red]#pass:c[down]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2782+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[edit]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+loc+` [red]`+f+` [red]`+&+` [red]`+args+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[end?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2851+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[insert-child]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2833+` [red]`+G__2834+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[insert-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2821+` [red]`+G__2822+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[insert-right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2825+` [red]`+G__2826+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2807+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[leftmost]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2814+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[lefts]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2780+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[make-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2775+` [red]`+G__2776+` [red]`+G__2777+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [red]`*-*`[red]#pass:c[next]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2839+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2766+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[position]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+loc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[prev]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2846+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[remove]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2853+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[replace]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2829+` [red]`+G__2830+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2797+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[rightmost]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2804+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[root]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2794+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[up]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2791+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[zipper]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+root+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n\n\n== [red]`*-*` [red]#pass:c[rewrite-clj.custom-zipper.utils]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [red]`*-*`[red]#pass:c[remove-and-move-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+loc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[remove-and-move-right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+loc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[remove-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+loc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[remove-left-while]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+p?+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[remove-right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+loc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[remove-right-while]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+p?+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node]#\n\n[unstyled]\n\n=== [black]`*≠*`[black]#pass:c[child-sexprs]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+node+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[children]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+_+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[coerce]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+_+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[comma-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+s+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[comma-separated]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+nodes+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[comma?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+node+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[comment-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+s+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[comment?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+node+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[concat-strings]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+nodes+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[deref-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+children+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[eval-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+children+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[fn-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+children+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[forms-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+children+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[inner?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+_+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[integer-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+value+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+value+` [red]`+base+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[keyword-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+k+` [red]`+&+` [red]`+[namespaced?]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[leader-length]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+_+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[length]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+_+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[line-separated]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+nodes+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[linebreak?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+node+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[list-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+children+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[map-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+children+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[meta-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+children+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+metadata+` [red]`+data+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[namespaced-map-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+children+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[newline-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+s+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[newlines]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+n+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[printable-only?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+_+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[quote-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+children+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[raw-meta-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+children+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+metadata+` [red]`+data+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[reader-macro-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+children+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+macro-node+` [red]`+form-node+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[regex-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+pattern-string+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[replace-children]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+_+` [red]`+children+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[set-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+children+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[sexpr]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+_+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[sexprs]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+nodes+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[spaces]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+n+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+_+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[string-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+lines+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[syntax-quote-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+children+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[tag]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+_+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[token-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+value+` [red]`+&+` [red]`+[string-value]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[uneval-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+children+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[unquote-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+children+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[unquote-splicing-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+children+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[value]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+node+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n* *pass:c[:deprecated]* [red]`*-*` [red]`+0.4.0+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[var-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+children+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[vector-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+children+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[whitespace-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+s+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[whitespace-nodes]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+s+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[whitespace?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+node+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [red]`*-*` [red]#pass:c[rewrite-clj.node.coerce]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.node.coercer]#\n\n[unstyled]\n\n=== [green]`*+*`[green]#pass:c[node-with-meta]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+n+` [green]`+value+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[seq-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]`+sq+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.comment]#\n\n[unstyled]\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n\n=== [black]`*=*`[black]#pass:c[comment-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+s+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[comment?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+node+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[CommentNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.forms]#\n\n[unstyled]\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n\n=== [black]`*=*`[black]#pass:c[forms-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+children+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[FormsNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [red]`*-*` [red]#pass:c[rewrite-clj.node.indent]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [red]`*-*`[red]#pass:c[indent-spaces]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+node+` [red]`+n+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[indent-tabs]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+node+` [red]`+n+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[LinePrefixedNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[prefix-lines]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+node+` [red]`+prefix+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [red]`*-*` [red]#pass:c[rewrite-clj.node.integer]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [red]`*-*`[red]#pass:c[integer-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+value+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+value+` [red]`+base+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[IntNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.keyword]#\n\n[unstyled]\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n\n=== [black]`*=*`[black]#pass:c[keyword-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+k+` [black]`+&+` [black]`+[namespaced?]+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[KeywordNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.meta]#\n\n[unstyled]\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n\n=== [black]`*=*`[black]#pass:c[meta-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+children+` [black]#pass:c[]]#\n* [black]`*=*` [black]#pass:c[[]# [black]`+metadata+` [black]`+data+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[MetaNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[raw-meta-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+children+` [black]#pass:c[]]#\n* [black]`*=*` [black]#pass:c[[]# [black]`+metadata+` [black]`+data+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.protocols]#\n\n[unstyled]\n\n=== [red]`*-*`[red]#pass:c[+extent]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+[row col]+` [red]`+[row-extent col-extent]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[assert-sexpr-count]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+nodes+` [black]`+c+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[assert-single-sexpr]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+nodes+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[concat-strings]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+nodes+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [red]`*-*`[red]#pass:c[extent]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+node+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[InnerNode]#\n|===\n.2+h| attributes 3+h| members\nh|name h| arglists h| attributes\n\n.999+a|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:protocol+`\na|\n[black]`*=*` [black]`+children+`\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+_+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n\na|\n[black]`*=*` [black]`+inner?+`\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+_+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n\na|\n[red]`*-*` [red]`+leader-length+`\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+_+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n\na|\n[black]`*=*` [black]`+replace-children+`\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+_+` [black]`+children+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n\n|===\n\n=== [red]`*-*`[red]#pass:c[make-printable!]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+class+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:macro+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[sum-lengths]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+nodes+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [red]`*-*`[red]#pass:c[write-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+writer+` [red]`+node+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n\n\n== [red]`*-*` [red]#pass:c[rewrite-clj.node.regex]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [red]`*-*`[red]#pass:c[regex-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+pattern-string+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[RegexNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.seq]#\n\n[unstyled]\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n\n=== [black]`*=*`[black]#pass:c[list-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+children+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[map-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+children+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[namespaced-map-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+children+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[NamespacedMapNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[SeqNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[set-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+children+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[vector-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+children+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[wrap-list]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+s+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[wrap-map]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+s+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[wrap-set]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+s+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[wrap-vec]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+s+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [red]`*-*` [red]#pass:c[rewrite-clj.node.string]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [red]`*-*`[red]#pass:c[string-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+lines+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[StringNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.node.stringz]#\n\n[unstyled]\n\n=== [green]`*+*`[green]#pass:c[string-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+lines+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[StringNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.token]#\n\n[unstyled]\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n\n=== [black]`*≠*`[black]#pass:c[token-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+value+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+value+` [green]`+string-value+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+value+` [red]`+&+` [red]`+[string-value]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[TokenNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.whitespace]#\n\n[unstyled]\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n\n=== [black]`*=*`[black]#pass:c[*count-fn*]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:dynamic]* [black]`*=*` [black]`+true+`\n|===\n\n=== [black]`*=*`[black]#pass:c[*newline-fn*]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:dynamic]* [black]`*=*` [black]`+true+`\n|===\n\n=== [red]`*-*`[red]#pass:c[comma-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+s+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[comma-separated]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+nodes+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[comma?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+node+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[CommaNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[line-separated]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+nodes+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[linebreak?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+node+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[newline-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+s+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[NewlineNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[newlines]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+n+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[space-separated]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+nodes+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[spaces]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+n+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[whitespace-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+s+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[whitespace-nodes]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+s+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[whitespace?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+node+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[WhitespaceNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[with-count-fn]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+f+` [red]`+&+` [red]`+body+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:macro+`\n|===\n\n=== [red]`*-*`[red]#pass:c[with-newline-fn]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+f+` [red]`+&+` [red]`+body+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:macro+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.paredit]#\n\n[unstyled]\n\n=== [green]`*+*`[green]#pass:c[barf-backward]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[barf-forward]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[join]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[kill]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[kill-at-pos]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[kill-one-at-pos]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[move-n]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+loc+` [green]`+f+` [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n|===\n\n=== [green]`*+*`[green]#pass:c[move-to-prev]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[raise]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[slurp-backward]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[slurp-backward-fully]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[slurp-forward]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[slurp-forward-fully]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[splice]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[splice-killing-backward]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[splice-killing-forward]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[split]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[split-at-pos]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[wrap-around]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+t+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[wrap-fully-forward-slurp]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+t+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.parser]#\n\n[unstyled]\n\n=== [red]`*-*`[red]#pass:c[parse-file]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+f+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[parse-file-all]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+f+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.parser.core]#\n\n[unstyled]\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n\n=== [black]`*=*`[black]#pass:c[parse-next]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.parser.keyword]#\n\n[unstyled]\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n\n=== [black]`*=*`[black]#pass:c[parse-keyword]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.parser.string]#\n\n[unstyled]\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n\n=== [black]`*=*`[black]#pass:c[parse-regex]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[parse-string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.parser.token]#\n\n[unstyled]\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n\n=== [black]`*=*`[black]#pass:c[parse-token]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [red]`*-*` [red]#pass:c[rewrite-clj.parser.utils]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [red]`*-*`[red]#pass:c[ignore]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+reader+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[linebreak?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+c+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[read-eol]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+reader+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[space?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+c+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[throw-reader]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+reader+` [red]`+&+` [red]`+msg+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[whitespace?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+c+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.parser.whitespace]#\n\n[unstyled]\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n\n=== [black]`*=*`[black]#pass:c[parse-whitespace]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [red]`*-*` [red]#pass:c[rewrite-clj.potemkin]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [red]`*-*`[red]#pass:c[defprotocol+]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+name+` [red]`+&+` [red]`+body+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:macro+`\n|===\n\n=== [red]`*-*`[red]#pass:c[import-def]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+sym+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+sym+` [red]`+name+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:macro+`\n|===\n\n=== [red]`*-*`[red]#pass:c[import-fn]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+sym+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+sym+` [red]`+name+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:macro+`\n|===\n\n=== [red]`*-*`[red]#pass:c[import-macro]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+sym+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+sym+` [red]`+name+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:macro+`\n|===\n\n=== [red]`*-*`[red]#pass:c[import-vars]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+&+` [red]`+syms+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:macro+`\n|===\n\n=== [red]`*-*`[red]#pass:c[link-vars]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+src+` [red]`+dst+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.reader]#\n\n[unstyled]\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n\n=== [black]`*=*`[black]#pass:c[boundary?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+c+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[buf]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[comma?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+c+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[file-reader]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+f+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[get-column-number]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[get-line-number]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[ignore]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[indexing-push-back-reader]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[linebreak?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+c+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[next]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[peek]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[peek-char]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[position]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+reader+` [red]`+row-k+` [red]`+col-k+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[read-char]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[read-include-linebreak]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[read-keyword]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+reader+` [green]`+initch+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[read-n]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]`+node-tag+` [black]`+read-fn+` [black]`+p?+` [black]`+n+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[read-repeatedly]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]`+read-fn+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[read-string]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[read-until]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]`+p?+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[read-while]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+reader+` [green]`+p?+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+reader+` [green]`+p?+` [green]`+eof?+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+reader+` [red]`+p?+` [red]`+&+` [red]`+[eof?]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[read-with-meta]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]`+read-fn+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[space?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+c+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[string->edn]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+s+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[string-reader]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+s+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[throw-reader]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]`+fmt+` [black]`+&+` [black]`+data+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[unread]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+reader+` [red]`+ch+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[whitespace-or-boundary?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+c+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[whitespace?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+c+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.zip]#\n\n[unstyled]\n\n=== [red]`*-*`[red]#pass:c[->root-string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n* *pass:c[:deprecated]* [red]`*-*` [red]`+0.4.0+`\n|===\n\n=== [red]`*-*`[red]#pass:c[->string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n* *pass:c[:deprecated]* [red]`*-*` [red]`+0.4.0+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[append-child]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+item+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[append-newline]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[n]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n* *pass:c[:deprecated]* [red]`*-*` [red]`+0.5.0+`\n|===\n\n=== [red]`*-*`[red]#pass:c[append-space]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[n]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n* *pass:c[:deprecated]* [red]`*-*` [red]`+0.5.0+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[assoc]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+k+` [red]`+v+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[child-sexprs]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[down]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[down*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2782+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[edit]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]`+&+` [red]`+args+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[edit*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+loc+` [red]`+f+` [red]`+&+` [red]`+args+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[edit->]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+body+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:macro+`\n|===\n\n=== [red]`*-*`[red]#pass:c[edit->>]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+body+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:macro+`\n|===\n\n=== [red]`*-*`[red]#pass:c[edit-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[edn]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+node+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+node+` [red]`+{}+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[edn*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+node+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+node+` [red]`+{}+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[end?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[find]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+p?+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]`+p?+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[find-depth-first]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+p?+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-last-by-pos]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[find-next]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+p?+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]`+p?+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[find-next-depth-first]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+p?+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[find-next-tag]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+t+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]`+t+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[find-next-token]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+p?+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]`+p?+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[find-next-value]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+v+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]`+v+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[find-tag]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+t+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]`+t+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-tag-by-pos]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[find-token]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+p?+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]`+p?+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[find-value]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+v+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]`+v+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[get]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+k+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[insert-child]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+item+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[insert-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+item+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[insert-left*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2821+` [red]`+G__2822+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[insert-right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+item+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[insert-right*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2825+` [red]`+G__2826+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[left*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2807+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[leftmost]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[leftmost*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2814+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[leftmost?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[length]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[linebreak?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[list?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[map]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+f+` [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[map-keys]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+f+` [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[map-vals]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+f+` [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[map?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[next]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[next*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2839+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2766+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[of-file]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+f+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+f+` [red]`+options+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[of-string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+s+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+s+` [red]`+options+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[position]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+loc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[postwalk]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+p?+` [red]`+f+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[prefix]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+s+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[prepend-newline]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[n]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n* *pass:c[:deprecated]* [red]`*-*` [red]`+0.5.0+`\n|===\n\n=== [red]`*-*`[red]#pass:c[prepend-space]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[n]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n* *pass:c[:deprecated]* [red]`*-*` [red]`+0.5.0+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[prev]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[prev*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2846+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[prewalk]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+p?+` [red]`+f+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[print]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[writer]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[print-root]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[writer]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[remove]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[remove*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2853+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[remove-preserve-newline]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[replace]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+value+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[replace*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2829+` [red]`+G__2830+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[right*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2797+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[rightmost]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[rightmost*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2804+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[rightmost?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[root]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2794+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[root-string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[seq?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[set?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[sexpr]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[skip]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+f+` [red]`+p?+` [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[skip-whitespace]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+f+` [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[skip-whitespace-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[splice]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[subedit->]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+body+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:macro+`\n|===\n\n=== [red]`*-*`[red]#pass:c[subedit->>]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+body+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:macro+`\n|===\n\n=== [red]`*-*`[red]#pass:c[subedit-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[suffix]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+s+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[tag]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[up]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[up*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+G__2791+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[value]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n* *pass:c[:deprecated]* [red]`*-*` [red]`+0.4.0+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[vector?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[whitespace-or-comment?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[whitespace?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.zip.base]#\n\n[unstyled]\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n\n=== [black]`*=*`[black]#pass:c[child-sexprs]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[edn]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+node+` [black]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+node+` [red]`+{}+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[edn*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+node+` [black]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+node+` [red]`+{}+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[length]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[of-file]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+f+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+f+` [red]`+options+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[of-string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+s+` [black]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+s+` [red]`+options+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[print]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[writer]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[print-root]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[writer]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[root-string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[sexpr]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[tag]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[value]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n* *pass:c[:deprecated]* [red]`*-*` [red]`+0.4.0+`\n|===\n\n\n\n== [red]`*-*` [red]#pass:c[rewrite-clj.zip.edit]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [red]`*-*`[red]#pass:c[edit]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]`+&+` [red]`+args+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[prefix]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+s+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[replace]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+value+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[splice]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[suffix]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+s+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.zip.editz]#\n\n[unstyled]\n\n=== [green]`*+*`[green]#pass:c[edit]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+&+` [green]`+args+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[prefix]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+s+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[replace]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+value+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[splice]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[suffix]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+s+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [red]`*-*` [red]#pass:c[rewrite-clj.zip.find]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [red]`*-*`[red]#pass:c[find]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+p?+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]`+p?+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[find-depth-first]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+p?+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[find-next]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+p?+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]`+p?+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[find-next-depth-first]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+p?+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[find-next-tag]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+t+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]`+t+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[find-next-token]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+p?+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]`+p?+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[find-next-value]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+v+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]`+v+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[find-tag]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+t+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]`+t+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[find-token]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+p?+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]`+p?+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[find-value]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+v+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]`+v+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.zip.findz]#\n\n[unstyled]\n\n=== [green]`*+*`[green]#pass:c[find]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-depth-first]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-last-by-pos]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-next]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-next-depth-first]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-next-tag]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+t+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+t+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-next-token]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-next-value]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+v+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+v+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-tag]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+t+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+t+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-tag-by-pos]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]`+t+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-token]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-value]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+v+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+v+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[in-range?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+{}+` [green]`+{}+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.zip.move]#\n\n[unstyled]\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n\n=== [black]`*=*`[black]#pass:c[down]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[end?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[leftmost]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[leftmost?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[next]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[prev]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[rightmost]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[rightmost?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[up]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [red]`*-*` [red]#pass:c[rewrite-clj.zip.remove]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [red]`*-*`[red]#pass:c[remove]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.zip.removez]#\n\n[unstyled]\n\n=== [green]`*+*`[green]#pass:c[remove]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[remove-preserve-newline]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [red]`*-*` [red]#pass:c[rewrite-clj.zip.seq]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [red]`*-*`[red]#pass:c[assoc]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+k+` [red]`+v+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[get]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+k+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[list?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[map]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+f+` [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[map-keys]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+f+` [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[map-vals]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+f+` [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[map?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[seq?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[set?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[vector?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.zip.seqz]#\n\n[unstyled]\n\n=== [green]`*+*`[green]#pass:c[assoc]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+k+` [green]`+v+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[get]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+k+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[list?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[map]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[map-keys]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[map-vals]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[map?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[seq?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[set?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[vector?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [red]`*-*` [red]#pass:c[rewrite-clj.zip.subedit]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [red]`*-*`[red]#pass:c[edit->]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+body+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:macro+`\n|===\n\n=== [red]`*-*`[red]#pass:c[edit->>]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+body+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:macro+`\n|===\n\n=== [red]`*-*`[red]#pass:c[edit-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[subedit->]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+body+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:macro+`\n|===\n\n=== [red]`*-*`[red]#pass:c[subedit->>]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+body+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:macro+`\n|===\n\n=== [red]`*-*`[red]#pass:c[subedit-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[subzip]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.zip.utils]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[remove-and-move-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+[_ {} :as loc]+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[remove-and-move-right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+[_ {} :as loc]+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[remove-and-move-up]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+loc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[remove-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+loc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[remove-left-while]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[remove-right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+loc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[remove-right-while]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[remove-while]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [red]`*-*` [red]#pass:c[rewrite-clj.zip.walk]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [red]`*-*`[red]#pass:c[postwalk]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+p?+` [red]`+f+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[postwalk-subtree]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+p?+` [red]`+f+` [red]`+loc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[prewalk]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+f+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+p?+` [red]`+f+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.zip.whitespace]#\n\n[unstyled]\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n\n=== [black]`*≠*`[black]#pass:c[append-newline]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[n]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:deprecated]* [red]`*-*` [red]`+0.5.0+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[append-space]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[n]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:deprecated]* [red]`*-*` [red]`+0.5.0+`\n|===\n\n=== [green]`*+*`[green]#pass:c[comment?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[insert-newline-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+n+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[insert-newline-right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+n+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[insert-space-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+n+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[insert-space-right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+n+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[linebreak?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[prepend-newline]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[n]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:deprecated]* [red]`*-*` [red]`+0.5.0+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[prepend-space]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[n]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:deprecated]* [red]`*-*` [red]`+0.5.0+`\n|===\n\n=== [black]`*=*`[black]#pass:c[skip]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+f+` [black]`+p?+` [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[skip-whitespace]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\n* [black]`*=*` [black]#pass:c[[]# [black]`+f+` [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[skip-whitespace-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[whitespace-not-linebreak?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[whitespace-or-comment?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[whitespace?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n",
         :cljdoc.doc/type :cljdoc/asciidoc,
         :slug "rwt-clj-v0-vs-rwt-cljs",
         :cljdoc.doc/contributors ("lread")}}
       {:title "rwt-clj v0 vs rwt-clj v1",
        :attrs
        {:cljdoc.doc/source-file
         "doc/generated/api-diffs/rewrite-clj-v0-lang-clj-and-rewrite-clj-v1-lang-clj.adoc",
         :cljdoc/asciidoc
         "// This file was auto-generated by diff-apis, best not to edit\n= pass:c[Diff of rewrite-clj 0.6.1 &  1.0.0-alpha]\n:toc: macro\n:toclevels: 5\n:!toc-title:\n\n**Diff of apis in:**\n\nA. `+rewrite-clj+` `+0.6.1+` `+clj+`\nB. `+rewrite-clj+` `+1.0.0-alpha+` `+clj+`\n\n**Options**:\n\n[cols=\"1,3\"]\n|===\n| Option | Value\n\nl|:arglists-by\nl|:arity-only\n\nl|:exclude-namespaces\nl|[\"rewrite-clj\"\n \"rewrite-clj.potemkin\"\n \"rewrite-clj.custom-zipper.switchable\"\n \"rewrite-clj.interop\"]\n\nl|:include\nl|:changed-publics\n\n|===\n**Legend:**\n\n* [red]`*-*`[red]#pass:c[A only]#\n* [green]`*+*`[green]#pass:c[B only]#\n* [red]`*-*`[red]#pass:c[A is]#[green]`*+*`[green]#pass:c[different from B]#\n* [black]`*≠*`[black]#pass:c[changes within A and B]#\n* [black]`*=*`[black]#pass:c[equal]#\n\n**Stats:**\n\n|===\n| Element | Have [red]#pass:c[changes]# [green]#pass:c[within]# | [red]#pass:c[In A Only]# | [green]#pass:c[In B Only]#\n\n| namespaces\n| 16\n| 3\n| 11\n\n| publics\n| 37\n| 14\n| 110\n\n| arglists\n| 0\n| 29\n| 163\n\n|===\n**Notes:**\n\nThe api of the last released version of rewrite-clj v0 was used as a reference for rewrite-clj v1.\nAs such, you'll notice the apis are almost the same.\n\nI assume that `rewrite-clj.custom-zipper.core` is internal and marked it as such with `:no-doc`.\n\nThere were some features unique to rewrite-cljs (such as paredit and some positional searching) which were brought over to rewrite-clj v1.\n\nThe internal rewrite-cljs namespaces that were link:../../design/01-merging-rewrite-clj-and-rewrite-cljs.adoc#_clojurescript_namespace_clashes[renamed to avoid cljs namespace collisions] also occur in the clj side of rewrite-clj v1.\nAll other differences are considered internal refactorings.\n\n**Table of diffs:**\n\ntoc::[]\n== [black]`*≠*` [black]#pass:c[rewrite-clj.custom-zipper.core]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [black]`*=*`[black]#pass:c[append-child]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+G__2836+` [black]`+G__2837+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[branch?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+G__2769+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[children]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+G__2772+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[custom-zipper]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+root+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[custom-zipper?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+value+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [black]`*=*`[black]#pass:c[down]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+G__2782+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[edit]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+loc+` [black]`+f+` [black]`+&+` [black]`+args+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[end?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+G__2851+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[insert-child]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+G__2833+` [black]`+G__2834+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[insert-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+G__2821+` [black]`+G__2822+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[insert-right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+G__2825+` [black]`+G__2826+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+G__2807+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[leftmost]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+G__2814+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[lefts]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+G__2780+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[make-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+G__2775+` [black]`+G__2776+` [black]`+G__2777+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [black]`*=*`[black]#pass:c[next]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+G__2839+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+G__2766+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[position]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+loc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[position-span]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[prev]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+G__2846+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[remove]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+G__2853+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[replace]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+G__2829+` [black]`+G__2830+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+G__2797+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[rightmost]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+G__2804+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[root]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+G__2794+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[up]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+G__2791+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[zipper]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+root+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.custom-zipper.utils]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[remove-and-move-up]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+loc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node]#\n\n[unstyled]\n\n=== [black]`*≠*`[black]#pass:c[child-sexprs]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+node+` [black]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[concat-strings]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+nodes+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[keyword-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+k+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+k+` [green]`+auto-resolved?+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+k+` [red]`+&+` [red]`+[namespaced?]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[keyword-node?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[map-context-apply]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]`+map-qualifier+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[map-context-clear]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[map-qualifier-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+auto-resolved?+` [green]`+prefix+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[node?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+x+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[sexpr]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+_+` [black]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[sexpr-able?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[sexprs]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+nodes+` [black]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+nodes+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[symbol-node?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[token-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+value+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+value+` [green]`+string-value+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+value+` [red]`+&+` [red]`+[string-value]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [red]`*-*` [red]#pass:c[rewrite-clj.node.coerce]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.node.coercer]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[node-with-meta]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+n+` [green]`+value+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.node.extras]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[whitespace-or-comment?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [red]`*-*` [red]#pass:c[rewrite-clj.node.indent]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [red]`*-*`[red]#pass:c[indent-spaces]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+node+` [red]`+n+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[indent-tabs]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+node+` [red]`+n+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[LinePrefixedNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[prefix-lines]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+node+` [red]`+prefix+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.keyword]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [black]`*≠*`[black]#pass:c[keyword-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+k+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+k+` [green]`+auto-resolved?+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+k+` [red]`+&+` [red]`+[namespaced?]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[keyword-node?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[keyword-sexpr]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+kw+` [green]`+kw-auto-resolved?+` [green]`+map-qualifier+` [green]`+{}+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[kw-qualifier]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+k+` [green]`+auto-resolved?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.node.namespaced-map]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[map-qualifier-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+auto-resolved?+` [green]`+prefix+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[MapQualifierNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[namespaced-map-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+children+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[NamespacedMapNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[reapply-namespaced-map-context]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.protocols]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [black]`*≠*`[black]#pass:c[+extent]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+[row col]+` [black]`+[row-extent col-extent]+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[assert-sexpr-count]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+nodes+` [black]`+c+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[assert-single-sexpr]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+nodes+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[child-sexprs]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+node+` [black]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[concat-strings]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+nodes+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [green]`*+*`[green]#pass:c[default-auto-resolve]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+alias+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[extent]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+node+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [black]`*=*`[black]#pass:c[InnerNode]#\n|===\n.2+h| attributes 3+h| members\nh|name h| arglists h| attributes\n\n.999+a|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:protocol+`\na|\n[black]`*=*` [black]`+children+`\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+_+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n\na|\n[black]`*=*` [black]`+inner?+`\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+_+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n\na|\n[black]`*=*` [black]`+leader-length+`\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+_+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n\na|\n[black]`*=*` [black]`+replace-children+`\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+_+` [black]`+children+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n\n|===\n\n=== [black]`*≠*`[black]#pass:c[make-printable!]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+class+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:macro+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [green]`*+*`[green]#pass:c[make-printable-clj!]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+class+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:macro+`\n|===\n\n=== [green]`*+*`[green]#pass:c[MapQualifiable]#\n|===\n.2+h| attributes 3+h| members\nh|name h| arglists h| attributes\n\n.999+a|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:protocol+`\na|\n[green]`*+*` [green]`+map-context-apply+`\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]`+map-qualifier+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n\na|\n[green]`*+*` [green]`+map-context-clear+`\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n\n|===\n\n=== [green]`*+*`[green]#pass:c[meta-elided]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+form+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[Node]#\n|===\n.2+h| attributes 3+h| members\nh|name h| arglists h| attributes\n\n.999+a|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:protocol+`\na|\n[black]`*=*` [black]`+length+`\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+_+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n\na|\n[green]`*+*` [green]`+node-type+`\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n\na|\n[black]`*=*` [black]`+printable-only?+`\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+_+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n\na|\n[red]`*-*` [red]`+sexpr+`\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+_+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n\na|\n[green]`*+*` [green]`+sexpr*+`\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n\na|\n[black]`*=*` [black]`+string+`\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+_+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n\na|\n[black]`*=*` [black]`+tag+`\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+_+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n\n|===\n\n=== [green]`*+*`[green]#pass:c[node?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+x+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[NodeCoerceable]#\n|===\n.2+h| attributes 3+h| members\nh|name h| arglists h| attributes\n\n.999+a|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:protocol+`\na|\n[black]`*=*` [black]`+coerce+`\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+_+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n\n|===\n\n=== [green]`*+*`[green]#pass:c[sexpr]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[sexpr-able?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[sexprs]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+nodes+` [black]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+nodes+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[sum-lengths]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+nodes+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [green]`*+*`[green]#pass:c[value]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n* *pass:c[:deprecated]* [green]`*+*` [green]`+0.4.0+`\n|===\n\n=== [green]`*+*`[green]#pass:c[without-whitespace]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+nodes+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[write-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+writer+` [black]`+node+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.regex]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[pattern-string-for-regex]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+regex+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.seq]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [red]`*-*`[red]#pass:c[namespaced-map-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+children+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[NamespacedMapNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.string]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [red]`*-*`[red]#pass:c[StringNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.node.stringz]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[string-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+lines+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[StringNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.token]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[symbol-node?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[SymbolNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[token-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+value+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+value+` [green]`+string-value+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+value+` [red]`+&+` [red]`+[string-value]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.paredit]#\n\n[unstyled]\n\n=== [green]`*+*`[green]#pass:c[barf-backward]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[barf-forward]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[join]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[kill]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[kill-at-pos]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[kill-one-at-pos]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[move-to-prev]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[raise]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[slurp-backward]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[slurp-backward-fully]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[slurp-forward]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[slurp-forward-fully]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[splice]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[splice-killing-backward]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[splice-killing-forward]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[split]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[split-at-pos]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[wrap-around]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+t+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[wrap-fully-forward-slurp]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+t+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.parser]#\n\n[unstyled]\n\n=== [black]`*≠*`[black]#pass:c[parse]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[parse-all]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.parser.namespaced-map]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[parse-namespaced-map]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+reader+` [green]`+read-next+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [red]`*-*` [red]#pass:c[rewrite-clj.parser.utils]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [red]`*-*`[red]#pass:c[ignore]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+reader+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[linebreak?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+c+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[read-eol]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+reader+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[space?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+c+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[throw-reader]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+reader+` [red]`+&+` [red]`+msg+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[whitespace?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+c+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.reader]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[newline-normalizing-reader]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+rdr+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[read-keyword]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+reader+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[read-while]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+reader+` [green]`+p?+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+reader+` [green]`+p?+` [green]`+eof?+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+reader+` [red]`+p?+` [red]`+&+` [red]`+[eof?]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.zip]#\n\n[unstyled]\n\n=== [green]`*+*`[green]#pass:c[append-child*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+item+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[append-newline]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[n]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:deprecated]* [black]`*=*` [black]`+0.5.0+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[append-space]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[n]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:deprecated]* [black]`*=*` [black]`+0.5.0+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-last-by-pos]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-tag-by-pos]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]`+t+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[insert-child*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+item+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[insert-newline-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[insert-newline-right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[insert-space-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[insert-space-right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[namespaced-map?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[position-span]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[prepend-newline]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[n]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:deprecated]* [black]`*=*` [black]`+0.5.0+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[prepend-space]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[n]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:deprecated]* [black]`*=*` [black]`+0.5.0+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[print]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+writer+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[writer]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[print-root]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+writer+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[writer]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[reapply-context]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[remove-preserve-newline]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[sexpr-able?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[subzip]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.zip.base]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[->root-string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n* *pass:c[:deprecated]* [green]`*+*` [green]`+0.4.0+`\n|===\n\n=== [green]`*+*`[green]#pass:c[->string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n* *pass:c[:deprecated]* [green]`*+*` [green]`+0.4.0+`\n|===\n\n=== [green]`*+*`[green]#pass:c[get-opts]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[print]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+writer+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[writer]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[print-root]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+writer+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[writer]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[set-opts]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[sexpr-able?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.zip.context]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[reapply-context]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.zip.editz]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[edit]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+&+` [green]`+args+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[prefix]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+s+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[replace]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+value+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[splice]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[suffix]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+s+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.zip.find]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[find-last-by-pos]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-tag-by-pos]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]`+t+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.zip.findz]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[find]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-depth-first]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-last-by-pos]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-next]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-next-depth-first]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-next-tag]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+t+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+t+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-next-token]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-next-value]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+v+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+v+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-tag]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+t+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+t+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-tag-by-pos]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]`+t+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-token]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-value]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+v+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+v+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.zip.remove]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[remove-preserve-newline]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.zip.removez]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[remove]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[remove-preserve-newline]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.zip.seqz]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[assoc]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+k+` [green]`+v+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[get]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+k+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[list?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[map]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[map-keys]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[map-vals]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[map?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[namespaced-map?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[seq?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[set?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[vector?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.zip.whitespace]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [black]`*≠*`[black]#pass:c[append-newline]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[n]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:deprecated]* [black]`*=*` [black]`+0.5.0+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[append-space]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[n]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:deprecated]* [black]`*=*` [black]`+0.5.0+`\n|===\n\n=== [green]`*+*`[green]#pass:c[comment?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[prepend-newline]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[n]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:deprecated]* [black]`*=*` [black]`+0.5.0+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[prepend-space]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+&+` [red]`+[n]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:deprecated]* [black]`*=*` [black]`+0.5.0+`\n|===\n\n=== [green]`*+*`[green]#pass:c[whitespace-not-linebreak?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n",
         :cljdoc.doc/type :cljdoc/asciidoc,
         :slug "rwt-clj-v0-vs-rwt-clj-v1",
         :cljdoc.doc/contributors ("lread")}}
       {:title "rwt-cljs vs rwt-clj v1",
        :attrs
        {:cljdoc.doc/source-file
         "doc/generated/api-diffs/rewrite-cljs-lang-cljs-and-rewrite-clj-v1-lang-cljs.adoc",
         :cljdoc/asciidoc
         "// This file was auto-generated by diff-apis, best not to edit\n= pass:c[Diff of rewrite-cljs 0.4.5 &  rewrite-clj 1.0.0-alpha]\n:toc: macro\n:toclevels: 5\n:!toc-title:\n\n**Diff of apis in:**\n\nA. `+rewrite-cljs+` `+0.4.5+` `+cljs+`\nB. `+rewrite-clj+` `+1.0.0-alpha+` `+cljs+`\n\n**Options**:\n\n[cols=\"1,3\"]\n|===\n| Option | Value\n\nl|:arglists-by\nl|:arity-only\n\nl|:exclude-namespaces\nl|[\"rewrite-clj\"\n \"rewrite-clj.potemkin\"\n \"rewrite-clj.custom-zipper.switchable\"\n \"rewrite-clj.interop\"]\n\nl|:include\nl|:changed-publics\n\n|===\n**Legend:**\n\n* [red]`*-*`[red]#pass:c[A only]#\n* [green]`*+*`[green]#pass:c[B only]#\n* [red]`*-*`[red]#pass:c[A is]#[green]`*+*`[green]#pass:c[different from B]#\n* [black]`*≠*`[black]#pass:c[changes within A and B]#\n* [black]`*=*`[black]#pass:c[equal]#\n\n**Stats:**\n\n|===\n| Element | Have [red]#pass:c[changes]# [green]#pass:c[within]# | [red]#pass:c[In A Only]# | [green]#pass:c[In B Only]#\n\n| namespaces\n| 27\n| 1\n| 10\n\n| publics\n| 104\n| 22\n| 166\n\n| arglists\n| 0\n| 18\n| 305\n\n|===\n**Notes:**\n\nYou'll notice that the API of the last released version of rewrite-cljs as compared to the cljs api of rewrite-clj v1 has many differences.\n\nRewrite-cljs lagged far behind rewrite-clj v0.\nThe cljs side of rewrite-clj v1 adds in, where possible, rewrite-clj features.\n\n**Table of diffs:**\n\ntoc::[]\n== [green]`*+*` [green]#pass:c[rewrite-clj.custom-zipper.core]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[append-child]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+item+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[branch?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[children]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+{}+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[custom-zipper]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+root+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[custom-zipper?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+value+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[down]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[edit]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+&+` [green]`+args+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[end?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[insert-child]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+item+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[insert-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+item+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[insert-right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+item+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[leftmost]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[lefts]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[make-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+_zloc+` [green]`+node+` [green]`+children+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[next]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[position]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[position-span]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[prev]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[remove]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[replace]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[rightmost]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[root]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[up]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[zipper]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+root+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.custom-zipper.utils]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[remove-and-move-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+loc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[remove-and-move-right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+loc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[remove-and-move-up]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+loc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[remove-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+loc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[remove-left-while]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[remove-right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+loc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[remove-right-while]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node]#\n\n[unstyled]\n\n=== [black]`*≠*`[black]#pass:c[child-sexprs]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[children]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[coerce]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+form+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[comma-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+s+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[comma-separated]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+nodes+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[comma?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[comment-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+s+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[comment?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[deref-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+children+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[eval-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+children+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[fn-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+children+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[forms-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+children+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[inner?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[integer-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+value+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+value+` [green]`+base+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[keyword-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+k+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+k+` [green]`+auto-resolved?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[keyword-node?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[leader-length]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[length]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[line-separated]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+nodes+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[linebreak?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[list-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+children+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[map-context-apply]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]`+map-qualifier+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[map-context-clear]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[map-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+children+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[map-qualifier-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+auto-resolved?+` [green]`+prefix+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[meta-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+children+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+metadata+` [green]`+data+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[namespaced-map-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+children+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[newline-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+s+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[newlines]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[node?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+x+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[printable-only?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[quote-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+children+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[raw-meta-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+children+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+metadata+` [green]`+data+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[reader-macro-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+children+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+macro-node+` [green]`+form-node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[regex-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+pattern-string+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[replace-children]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]`+children+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[set-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+children+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[sexpr]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[sexpr-able?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[sexprs]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+nodes+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+nodes+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[spaces]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[string-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+lines+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[symbol-node?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[syntax-quote-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+children+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[tag]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[token-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+value+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+value+` [green]`+string-value+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[uneval-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+children+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[unquote-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+children+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[unquote-splicing-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+children+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[value]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n* *pass:c[:deprecated]* [green]`*+*` [green]`+0.4.0+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[var-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+children+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[vector-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+children+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[whitespace-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+s+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[whitespace-nodes]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+s+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[whitespace?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.coercer]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [black]`*=*`[black]#pass:c[node-with-meta]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+n+` [black]`+value+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[seq-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+f+` [red]`+sq+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.comment]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [black]`*=*`[black]#pass:c[comment-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+s+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[comment?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+node+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[CommentNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.node.extras]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[whitespace-or-comment?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.forms]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [black]`*=*`[black]#pass:c[forms-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+children+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[FormsNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.node.integer]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[integer-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+value+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+value+` [green]`+base+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[IntNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.keyword]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [black]`*≠*`[black]#pass:c[keyword-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+k+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+k+` [green]`+auto-resolved?+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+k+` [red]`+&+` [red]`+[namespaced?]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[keyword-node?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[keyword-sexpr]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+kw+` [green]`+kw-auto-resolved?+` [green]`+map-qualifier+` [green]`+{}+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[KeywordNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[kw-qualifier]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+k+` [green]`+auto-resolved?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.meta]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [black]`*=*`[black]#pass:c[meta-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+children+` [black]#pass:c[]]#\n* [black]`*=*` [black]#pass:c[[]# [black]`+metadata+` [black]`+data+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[MetaNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[raw-meta-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+children+` [black]#pass:c[]]#\n* [black]`*=*` [black]#pass:c[[]# [black]`+metadata+` [black]`+data+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.node.namespaced-map]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[map-qualifier-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+auto-resolved?+` [green]`+prefix+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[MapQualifierNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[namespaced-map-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+children+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[NamespacedMapNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[reapply-namespaced-map-context]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.protocols]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [green]`*+*`[green]#pass:c[+extent]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+[row col]+` [green]`+[row-extent col-extent]+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[assert-sexpr-count]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+nodes+` [black]`+c+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[assert-single-sexpr]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+nodes+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[child-sexprs]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+node+` [black]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[concat-strings]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+nodes+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[default-auto-resolve]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+alias+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[extent]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[InnerNode]#\n|===\n.2+h| attributes 3+h| members\nh|name h| arglists h| attributes\n\n.999+a|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:protocol+`\na|\n[black]`*=*` [black]`+children+`\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+_+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n\na|\n[black]`*=*` [black]`+inner?+`\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+_+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n\na|\n[green]`*+*` [green]`+leader-length+`\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n\na|\n[black]`*=*` [black]`+replace-children+`\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+_+` [black]`+children+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n\n|===\n\n=== [green]`*+*`[green]#pass:c[make-printable!]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+obj+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[make-printable-cljs!]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+obj+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n|===\n\n=== [green]`*+*`[green]#pass:c[MapQualifiable]#\n|===\n.2+h| attributes 3+h| members\nh|name h| arglists h| attributes\n\n.999+a|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:protocol+`\na|\n[green]`*+*` [green]`+map-context-apply+`\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]`+map-qualifier+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n\na|\n[green]`*+*` [green]`+map-context-clear+`\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n\n|===\n\n=== [green]`*+*`[green]#pass:c[meta-elided]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+form+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[Node]#\n|===\n.2+h| attributes 3+h| members\nh|name h| arglists h| attributes\n\n.999+a|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:protocol+`\na|\n[black]`*=*` [black]`+length+`\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+_+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n\na|\n[green]`*+*` [green]`+node-type+`\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n\na|\n[black]`*=*` [black]`+printable-only?+`\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+_+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n\na|\n[red]`*-*` [red]`+sexpr+`\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+_+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n\na|\n[green]`*+*` [green]`+sexpr*+`\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n\na|\n[black]`*=*` [black]`+string+`\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+_+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n\na|\n[black]`*=*` [black]`+tag+`\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+_+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n\n|===\n\n=== [green]`*+*`[green]#pass:c[node?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+x+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[NodeCoerceable]#\n|===\n.2+h| attributes 3+h| members\nh|name h| arglists h| attributes\n\n.999+a|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:protocol+`\na|\n[black]`*=*` [black]`+coerce+`\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+_+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n\n|===\n\n=== [green]`*+*`[green]#pass:c[sexpr]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[sexpr-able?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[sexprs]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+nodes+` [black]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+nodes+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[sum-lengths]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+nodes+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[value]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n* *pass:c[:deprecated]* [green]`*+*` [green]`+0.4.0+`\n|===\n\n=== [green]`*+*`[green]#pass:c[without-whitespace]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+nodes+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.node.regex]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[pattern-string-for-regex]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+regex+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[regex-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+pattern-string+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[RegexNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.seq]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [black]`*=*`[black]#pass:c[list-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+children+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[map-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+children+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[SeqNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[set-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+children+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[vector-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+children+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[wrap-list]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+s+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[wrap-map]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+s+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[wrap-set]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+s+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[wrap-vec]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+s+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.stringz]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [black]`*=*`[black]#pass:c[string-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+lines+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[StringNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.token]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [green]`*+*`[green]#pass:c[symbol-node?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[SymbolNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[token-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+value+` [black]#pass:c[]]#\n* [black]`*=*` [black]#pass:c[[]# [black]`+value+` [black]`+string-value+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[TokenNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.whitespace]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [black]`*=*`[black]#pass:c[*count-fn*]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:dynamic]* [black]`*=*` [black]`+true+`\n|===\n\n=== [black]`*=*`[black]#pass:c[*newline-fn*]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:dynamic]* [black]`*=*` [black]`+true+`\n|===\n\n=== [green]`*+*`[green]#pass:c[comma-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+s+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[comma-separated]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+nodes+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[comma?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[CommaNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[line-separated]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+nodes+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[linebreak?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+node+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[newline-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+s+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[NewlineNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[newlines]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+n+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[space-separated]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+nodes+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[spaces]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+n+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[whitespace-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+s+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[whitespace-nodes]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+s+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[whitespace?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+node+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[WhitespaceNode]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[with-count-fn]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]`+&+` [green]`+body+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:macro+`\n|===\n\n=== [green]`*+*`[green]#pass:c[with-newline-fn]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]`+&+` [green]`+body+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:macro+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.paredit]#\n\n[unstyled]\n\n=== [red]`*-*`[red]#pass:c[move-n]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+loc+` [red]`+f+` [red]`+n+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.parser]#\n\n[unstyled]\n\n=== [black]`*≠*`[black]#pass:c[parse]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[parse-all]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.parser.core]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [black]`*=*`[black]#pass:c[parse-next]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+rdr+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.parser.keyword]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [black]`*=*`[black]#pass:c[parse-keyword]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.parser.namespaced-map]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[parse-namespaced-map]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+reader+` [green]`+read-next+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.parser.string]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [black]`*=*`[black]#pass:c[parse-regex]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[parse-string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.parser.token]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [black]`*=*`[black]#pass:c[parse-token]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.parser.whitespace]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [black]`*=*`[black]#pass:c[parse-whitespace]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.reader]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [black]`*=*`[black]#pass:c[boundary?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+c+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[buf]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[comma?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+c+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[get-column-number]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[get-line-number]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[ignore]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[indexing-push-back-reader]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[linebreak?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+c+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[next]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[peek]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[peek-char]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[position]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+reader+` [green]`+row-k+` [green]`+col-k+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[read-char]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[read-include-linebreak]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[read-keyword]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+reader+` [green]#pass:c[]]#\n* [red]`*-*` [red]#pass:c[[]# [red]`+reader+` [red]`+initch+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[read-n]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]`+node-tag+` [black]`+read-fn+` [black]`+p?+` [black]`+n+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[read-repeatedly]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]`+read-fn+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[read-string]#\n|===\n| attributes\n\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[read-until]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]`+p?+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[read-while]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]`+p?+` [black]#pass:c[]]#\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]`+p?+` [black]`+eof?+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[read-with-meta]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]`+read-fn+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[space?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+c+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[string->edn]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+s+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[string-reader]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+s+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[throw-reader]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+reader+` [black]`+fmt+` [black]`+&+` [black]`+data+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[unread]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+reader+` [green]`+ch+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[whitespace-or-boundary?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+c+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[whitespace?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+ch+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.zip]#\n\n[unstyled]\n\n=== [green]`*+*`[green]#pass:c[->root-string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n* *pass:c[:deprecated]* [green]`*+*` [green]`+0.4.0+`\n|===\n\n=== [green]`*+*`[green]#pass:c[->string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n* *pass:c[:deprecated]* [green]`*+*` [green]`+0.4.0+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[append-child]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+item+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[append-child*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+item+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[append-newline]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n* *pass:c[:deprecated]* [green]`*+*` [green]`+0.5.0+`\n|===\n\n=== [green]`*+*`[green]#pass:c[append-space]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n* *pass:c[:deprecated]* [green]`*+*` [green]`+0.5.0+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[assoc]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+k+` [green]`+v+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[child-sexprs]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[down]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[down*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[edit]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+&+` [green]`+args+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[edit*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+&+` [green]`+args+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[edit->]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+&+` [green]`+body+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:macro+`\n|===\n\n=== [green]`*+*`[green]#pass:c[edit->>]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+&+` [green]`+body+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:macro+`\n|===\n\n=== [green]`*+*`[green]#pass:c[edit-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[edn]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[edn*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[end?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[find]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[find-depth-first]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[find-last-by-pos]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[find-next]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[find-next-depth-first]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[find-next-tag]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+t+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+t+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[find-next-token]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[find-next-value]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+v+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+v+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[find-tag]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+t+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+t+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[find-tag-by-pos]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]`+t+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[find-token]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[find-value]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+v+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+v+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[get]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+k+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[insert-child]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+item+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[insert-child*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+item+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[insert-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+item+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[insert-left*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+item+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[insert-newline-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[insert-newline-right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[insert-right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+item+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[insert-right*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+item+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[insert-space-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[insert-space-right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[left*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[leftmost]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[leftmost*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[leftmost?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[length]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[linebreak?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[list?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[map]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[map-keys]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[map-vals]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[map?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[namespaced-map?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[next]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[next*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[of-string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+s+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+s+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[position]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[position-span]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[postwalk]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]`+f+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[prefix]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+s+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[prepend-newline]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n* *pass:c[:deprecated]* [green]`*+*` [green]`+0.5.0+`\n|===\n\n=== [green]`*+*`[green]#pass:c[prepend-space]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n* *pass:c[:deprecated]* [green]`*+*` [green]`+0.5.0+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[prev]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[prev*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[prewalk]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]`+f+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[print]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+writer+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[print-root]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+writer+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[reapply-context]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[remove]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[remove*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[remove-preserve-newline]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[replace]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+value+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[replace*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[right*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[rightmost]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[rightmost*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[rightmost?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[root]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[root-string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[seq?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[set?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[sexpr]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[sexpr-able?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[skip]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]`+p?+` [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[skip-whitespace]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[skip-whitespace-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[splice]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[subedit->]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+&+` [green]`+body+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:macro+`\n|===\n\n=== [green]`*+*`[green]#pass:c[subedit->>]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+&+` [green]`+body+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:macro+`\n|===\n\n=== [green]`*+*`[green]#pass:c[subedit-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[subzip]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[suffix]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+s+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[tag]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[up]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[up*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[value]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n* *pass:c[:deprecated]* [green]`*+*` [green]`+0.4.0+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[vector?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[whitespace-or-comment?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[whitespace?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.zip.base]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [green]`*+*`[green]#pass:c[->root-string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n* *pass:c[:deprecated]* [green]`*+*` [green]`+0.4.0+`\n|===\n\n=== [green]`*+*`[green]#pass:c[->string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n* *pass:c[:deprecated]* [green]`*+*` [green]`+0.4.0+`\n|===\n\n=== [black]`*=*`[black]#pass:c[child-sexprs]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[edn]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+node+` [black]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[edn*]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+node+` [black]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+node+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[get-opts]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[length]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[of-string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+s+` [black]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+s+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[print]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+writer+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[print-root]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+writer+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[root-string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[set-opts]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[sexpr]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[sexpr-able?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[string]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[tag]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[value]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n* *pass:c[:deprecated]* [green]`*+*` [green]`+0.4.0+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.zip.context]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[reapply-context]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.zip.editz]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [black]`*=*`[black]#pass:c[edit]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+f+` [black]`+&+` [black]`+args+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[prefix]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+s+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[replace]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+value+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[splice]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[suffix]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+s+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.zip.findz]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [black]`*=*`[black]#pass:c[find]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+p?+` [black]#pass:c[]]#\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+f+` [black]`+p?+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[find-depth-first]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+p?+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[find-last-by-pos]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+pos+` [black]#pass:c[]]#\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+pos+` [black]`+p?+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[find-next]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+p?+` [black]#pass:c[]]#\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+f+` [black]`+p?+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[find-next-depth-first]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+p?+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[find-next-tag]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+t+` [black]#pass:c[]]#\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+f+` [black]`+t+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[find-next-token]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+p?+` [black]#pass:c[]]#\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+f+` [black]`+p?+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[find-next-value]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+v+` [black]#pass:c[]]#\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+f+` [black]`+v+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[find-tag]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+t+` [black]#pass:c[]]#\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+f+` [black]`+t+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[find-tag-by-pos]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+pos+` [black]`+t+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[find-token]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+p?+` [black]#pass:c[]]#\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+f+` [black]`+p?+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[find-value]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+v+` [black]#pass:c[]]#\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+f+` [black]`+v+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[in-range?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+{}+` [red]`+{}+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.zip.move]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [black]`*=*`[black]#pass:c[down]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[end?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[leftmost]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[leftmost?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[next]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[prev]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[rightmost]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[rightmost?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[up]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.zip.removez]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [black]`*=*`[black]#pass:c[remove]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[remove-preserve-newline]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.zip.seqz]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [black]`*=*`[black]#pass:c[assoc]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+k+` [black]`+v+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[get]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+k+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[list?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[map]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+f+` [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[map-keys]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+f+` [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[map-vals]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+f+` [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[map?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[namespaced-map?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[seq?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[set?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[vector?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.zip.subedit]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[edit->]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+&+` [green]`+body+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:macro+`\n|===\n\n=== [green]`*+*`[green]#pass:c[edit->>]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+&+` [green]`+body+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:macro+`\n|===\n\n=== [green]`*+*`[green]#pass:c[edit-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[subedit->]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+&+` [green]`+body+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:macro+`\n|===\n\n=== [green]`*+*`[green]#pass:c[subedit->>]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+&+` [green]`+body+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:macro+`\n|===\n\n=== [green]`*+*`[green]#pass:c[subedit-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[subzip]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [red]`*-*` [red]#pass:c[rewrite-clj.zip.utils]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [red]`*-*`[red]#pass:c[remove-and-move-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+[_ {} :as loc]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[remove-and-move-right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+[_ {} :as loc]+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[remove-and-move-up]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+loc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[remove-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+loc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[remove-left-while]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+p?+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[remove-right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+loc+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[remove-right-while]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+p?+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n=== [red]`*-*`[red]#pass:c[remove-while]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+zloc+` [red]`+p?+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.zip.walk]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[postwalk]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]`+f+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[postwalk-subtree]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+p?+` [green]`+f+` [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[prewalk]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]`+f+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.zip.whitespace]#\n\n[unstyled]\n* *pass:c[:no-doc]* [green]`*+*` [green]`+true+`\n\n=== [black]`*≠*`[black]#pass:c[append-newline]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+n+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:deprecated]* [green]`*+*` [green]`+0.5.0+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[append-space]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+n+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:deprecated]* [green]`*+*` [green]`+0.5.0+`\n|===\n\n=== [black]`*=*`[black]#pass:c[comment?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[insert-newline-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[insert-newline-right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[insert-space-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[insert-space-right]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+n+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[linebreak?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[prepend-newline]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+n+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:deprecated]* [green]`*+*` [green]`+0.5.0+`\n|===\n\n=== [black]`*≠*`[black]#pass:c[prepend-space]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]`+n+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n* *pass:c[:deprecated]* [green]`*+*` [green]`+0.5.0+`\n|===\n\n=== [black]`*=*`[black]#pass:c[skip]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+f+` [black]`+p?+` [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[skip-whitespace]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\n* [black]`*=*` [black]#pass:c[[]# [black]`+f+` [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[skip-whitespace-left]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[whitespace-not-linebreak?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[whitespace-or-comment?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n=== [black]`*=*`[black]#pass:c[whitespace?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [black]`*=*` [black]#pass:c[[]# [black]`+zloc+` [black]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [black]`*=*` [black]`+:var+`\n|===\n\n\n",
         :cljdoc.doc/type :cljdoc/asciidoc,
         :slug "rwt-cljs-vs-rwt-clj-v1",
         :cljdoc.doc/contributors ("lread")}}
       {:title "rwt-clj v1 clj vs cljs all",
        :attrs
        {:cljdoc.doc/source-file
         "doc/generated/api-diffs/rewrite-clj-v1-lang-cljs-and-rewrite-clj-v1-lang-clj.adoc",
         :cljdoc/asciidoc
         "// This file was auto-generated by diff-apis, best not to edit\n= pass:c[Diff of rewrite-clj 1.0.0-alpha cljs &  clj]\n:toc: macro\n:toclevels: 5\n:!toc-title:\n\n**Diff of apis in:**\n\nA. `+rewrite-clj+` `+1.0.0-alpha+` `+cljs+`\nB. `+rewrite-clj+` `+1.0.0-alpha+` `+clj+`\n\n**Options**:\n\n[cols=\"1,3\"]\n|===\n| Option | Value\n\nl|:arglists-by\nl|:arity-only\n\nl|:exclude-namespaces\nl|[\"rewrite-clj.potemkin.clojure\"]\n\nl|:include\nl|:changed-publics\n\n|===\n**Legend:**\n\n* [red]`*-*`[red]#pass:c[A only]#\n* [green]`*+*`[green]#pass:c[B only]#\n* [red]`*-*`[red]#pass:c[A is]#[green]`*+*`[green]#pass:c[different from B]#\n* [black]`*≠*`[black]#pass:c[changes within A and B]#\n* [black]`*=*`[black]#pass:c[equal]#\n\n**Stats:**\n\n|===\n| Element | Have [red]#pass:c[changes]# [green]#pass:c[within]# | [red]#pass:c[In A Only]# | [green]#pass:c[In B Only]#\n\n| namespaces\n| 5\n| 0\n| 5\n\n| publics\n| 0\n| 1\n| 38\n\n| arglists\n| 0\n| 1\n| 49\n\n|===\n**Notes:**\n\nThe cljs and clj sides of rewrite-clj v1 have the following differences of note:\n\n1. You'll notice that the Clojure API has the ability to deal with files, the ClojureScript API does not.\n2. If we were to exclude api namespaces and functions marked with `no-doc` we link:rewrite-clj-v1-lang-cljs-and-rewrite-clj-v1-lang-clj-documented-only.adoc[would see only item 1 as differences].\nWe include them because it seems that historically, internal undocumented features have been used in rewrite-cljs and rewrite-clj.\n3. The ClojureScript API is missing the Clojure API namespaces that cause link:../../design/01-merging-rewrite-clj-and-rewrite-cljs.adoc#_clojurescript_namespace_clashes[namespace clashes on the clojurescript side].\n\n**Table of diffs:**\n\ntoc::[]\n== [black]`*≠*` [black]#pass:c[rewrite-clj.node.protocols]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[make-printable-clj!]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+class+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:macro+`\n|===\n\n=== [red]`*-*`[red]#pass:c[make-printable-cljs!]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [red]`*-*` [red]#pass:c[[]# [red]`+obj+` [red]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [red]`*-*` [red]`+:var+`\n* *pass:c[:no-doc]* [red]`*-*` [red]`+true+`\n|===\n\n=== [green]`*+*`[green]#pass:c[write-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+writer+` [green]`+node+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.node.string]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[string-node]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+lines+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.parser]#\n\n[unstyled]\n\n=== [green]`*+*`[green]#pass:c[parse-file]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[parse-file-all]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.reader]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[file-reader]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[newline-normalizing-reader]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+rdr+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.zip]#\n\n[unstyled]\n\n=== [green]`*+*`[green]#pass:c[of-file]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.zip.base]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[of-file]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.zip.edit]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[edit]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+&+` [green]`+args+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[prefix]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+s+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[replace]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+value+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[splice]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[suffix]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+s+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.zip.find]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[find]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-depth-first]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-last-by-pos]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-next]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-next-depth-first]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-next-tag]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+t+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+t+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-next-token]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-next-value]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+v+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+v+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-tag]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+t+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+t+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-tag-by-pos]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+pos+` [green]`+t+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-token]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+p?+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+p?+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[find-value]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+v+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+f+` [green]`+v+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.zip.remove]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[remove]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[remove-preserve-newline]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [green]`*+*` [green]#pass:c[rewrite-clj.zip.seq]#\n\n[unstyled]\n* *pass:c[:no-doc]* [black]`*=*` [black]`+true+`\n\n=== [green]`*+*`[green]#pass:c[assoc]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+k+` [green]`+v+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[get]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]`+k+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[list?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[map]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[map-keys]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[map-vals]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[map?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[seq?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[set?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[vector?]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+zloc+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n",
         :cljdoc.doc/type :cljdoc/asciidoc,
         :slug "rwt-clj-v1-clj-vs-cljs-all",
         :cljdoc.doc/contributors ("lread")}}
       {:title "rwt-clj v1 clj vs cljs public",
        :attrs
        {:cljdoc.doc/source-file
         "doc/generated/api-diffs/rewrite-clj-v1-lang-cljs-and-rewrite-clj-v1-lang-clj-documented-only.adoc",
         :cljdoc/asciidoc
         "// This file was auto-generated by diff-apis, best not to edit\n= pass:c[Diff of rewrite-clj 1.0.0-alpha cljs &  clj]\n:toc: macro\n:toclevels: 5\n:!toc-title:\n\n**Diff of apis in:**\n\nA. `+rewrite-clj+` `+1.0.0-alpha+` `+cljs+`\nB. `+rewrite-clj+` `+1.0.0-alpha+` `+clj+`\n\n**Options**:\n\n[cols=\"1,3\"]\n|===\n| Option | Value\n\nl|:arglists-by\nl|:arity-only\n\nl|:exclude-namespaces\nl|[\"rewrite-clj.potemkin.clojure\"]\n\nl|:exclude-with\nl|[:no-doc :skip-wiki]\n\nl|:include\nl|:changed-publics\n\n|===\n**Legend:**\n\n* [red]`*-*`[red]#pass:c[A only]#\n* [green]`*+*`[green]#pass:c[B only]#\n* [red]`*-*`[red]#pass:c[A is]#[green]`*+*`[green]#pass:c[different from B]#\n* [black]`*≠*`[black]#pass:c[changes within A and B]#\n* [black]`*=*`[black]#pass:c[equal]#\n\n**Stats:**\n\n|===\n| Element | Have [red]#pass:c[changes]# [green]#pass:c[within]# | [red]#pass:c[In A Only]# | [green]#pass:c[In B Only]#\n\n| namespaces\n| 2\n| 0\n| 0\n\n| publics\n| 0\n| 0\n| 3\n\n| arglists\n| 0\n| 0\n| 4\n\n|===\n**Notes:**\n\nWhen we exclude API elements that are considered internal, we are left with the expected feature differences between cljs and clj usages, namely: file support.\n\n**Table of diffs:**\n\ntoc::[]\n== [black]`*≠*` [black]#pass:c[rewrite-clj.parser]#\n\n[unstyled]\n\n=== [green]`*+*`[green]#pass:c[parse-file]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n=== [green]`*+*`[green]#pass:c[parse-file-all]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n\n== [black]`*≠*` [black]#pass:c[rewrite-clj.zip]#\n\n[unstyled]\n\n=== [green]`*+*`[green]#pass:c[of-file]#\n|===\n| arglists | attributes \n\na|\n[unstyled]\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]#pass:c[]]#\n* [green]`*+*` [green]#pass:c[[]# [green]`+f+` [green]`+opts+` [green]#pass:c[]]#\na|\n[unstyled]\n* *pass:c[:type]* [green]`*+*` [green]`+:var+`\n|===\n\n\n",
         :cljdoc.doc/type :cljdoc/asciidoc,
         :slug "rwt-clj-v1-clj-vs-cljs-public",
         :cljdoc.doc/contributors ("lread")}}]}]}
   {:title "Frequently Asked Questions",
    :attrs
    {:cljdoc.doc/source-file "doc/03-faq.adoc",
     :cljdoc/asciidoc
     "= Frequently Asked Questions\n\n== Documentation\n\n=== What is the meaning of the ^:no-doc metadata?\nOur goal is to produce documentation for users of rewrite-clj.\nAs such we only want to document public APIs.\n\n`^:no-doc` is a signal to https://cljdoc.org/[cljdoc] that source code should not be included in generated documentation.\nThis metadata convention was introduced by https://github.com/weavejester/codox[codox].\n\n== What the markdown?\nStand alone articles are written up in https://asciidoctor.org/docs/what-is-asciidoc/[AsciiDoc].\n\n1. it is a richer markup language than GitHub markdown.\n2. is supported by cljdoc.\n\nOur docstrings sometimes take advantage of https://commonmark.org/[CommonMark] which is supported by cljdoc for docstrings.\nGitHub uses CommonMark as part of of its markdown solution.\n",
     :cljdoc.doc/type :cljdoc/asciidoc,
     :slug "frequently-asked-questions",
     :cljdoc.doc/contributors ("lread")}}
   {:title "Contributing",
    :attrs
    {:cljdoc.doc/source-file "CONTRIBUTING.md",
     :cljdoc/markdown
     "# Contributing Guidelines\n\n**Do**\n- remember that a gift, while appreciated, is also a burden. We value your input but start with an issue to propose your change before investing your valuable time in a PR.\n- read the [rewrite-clj Developer Guide](doc/02-developer-guide.adoc).\n- follow [the seven rules of a great Git commit message][1].\n- follow [the Clojure Style Guide][2].\n- include/update tests for your change.\n- ensure that the Continuous Integration checks pass.\n- feel free to pester the project maintainers about your PR if it hasn't been responded to. Sometimes notifications can be missed.\n\n**Don't**\n- include more than one feature or fix in a single PR.\n- include changes unrelated to the purpose of the PR. This includes changing the project version number, adding lines to the\n`.gitignore` file, or changing the indentation or formatting.\n- open a new PR if changes are requested. Just push to the same branch and the PR will be updated.\n- overuse vertical whitespace; avoid multiple sequential blank lines.\n\n[1]: https://chris.beams.io/posts/git-commit/#seven-rules\n[2]: https://github.com/bbatsov/clojure-style-guide\n",
     :cljdoc.doc/type :cljdoc/markdown,
     :slug "contributing",
     :cljdoc.doc/contributors ("lread")}}
   {:title "Code of Conduct",
    :attrs
    {:cljdoc.doc/source-file "CODE_OF_CONDUCT.md",
     :cljdoc/markdown
     "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, religion, or sexual identity\nand orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our\ncommunity include:\n\n* Demonstrating empathy and kindness toward other people\n* Being respectful of differing opinions, viewpoints, and experiences\n* Giving and gracefully accepting constructive feedback\n* Accepting responsibility and apologizing to those affected by our mistakes,\n  and learning from the experience\n* Focusing on what is best not just for us as individuals, but for the\n  overall community\n\nExamples of unacceptable behavior include:\n\n* The use of sexualized language or imagery, and sexual attention or\n  advances of any kind\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or email\n  address, without their explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Enforcement Responsibilities\n\nCommunity leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful.\n\nCommunity leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\n[INSERT CONTACT METHOD].\nAll complaints will be reviewed and investigated promptly and fairly.\n\nAll community leaders are obligated to respect the privacy and security of the\nreporter of any incident.\n\n## Enforcement Guidelines\n\nCommunity leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct:\n\n### 1. Correction\n\n**Community Impact**: Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community.\n\n**Consequence**: A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested.\n\n### 2. Warning\n\n**Community Impact**: A violation through a single incident or series\nof actions.\n\n**Consequence**: A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or\npermanent ban.\n\n### 3. Temporary Ban\n\n**Community Impact**: A serious violation of community standards, including\nsustained inappropriate behavior.\n\n**Consequence**: A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban.\n\n### 4. Permanent Ban\n\n**Community Impact**: Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior,  harassment of an\nindividual, or aggression toward or disparagement of classes of individuals.\n\n**Consequence**: A permanent ban from any sort of public interaction within\nthe community.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 2.0, available at\nhttps://www.contributor-covenant.org/version/2/0/code_of_conduct.html.\n\nCommunity Impact Guidelines were inspired by [Mozilla's code of conduct\nenforcement ladder](https://github.com/mozilla/diversity).\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see the FAQ at\nhttps://www.contributor-covenant.org/faq. Translations are available at\nhttps://www.contributor-covenant.org/translations.\n",
     :cljdoc.doc/type :cljdoc/markdown,
     :slug "code-of-conduct",
     :cljdoc.doc/contributors ("lread")}}
   {:title "Maintainer Guide",
    :attrs
    {:cljdoc.doc/source-file "doc/04-maintainer-guide.adoc",
     :cljdoc/asciidoc
     "= Maintainer Guide\n:toclevels: 6\n:toc:\n\n== Introduction\nThis doc covers notes for project maintainers.\n\n== Releasing\n\n=== Overview\nThe released workflow is handled by our https://github.com/clj-commons/rewrite-clj/actions?query=workflow%3A%22Release%22[Release] GitHub Action.\n\nThe release workflow:\n\n. Create a thin jar using our version scheme\n. Apply jar version to following docs:\n.. user guide docs `deps.edn` usage example\n.. change log \"unreleased\" and \"unreleased breaking changes\" headings\n. Deploy the jar to clojars\n. Commit and push updates made to `CHANGELOG.adoc` and `01-user-guide.adoc` back to the project\n. Create and push a release tag back to the project repo\n. Inform cljdoc of the new release\n\nAt this time, the release workflow does not run tests.\nThe assumption is that you've waited for the last CI test run to complete and are happy with the results.\n\nThe release workflow will fail if the change log is not ready for release.\n\n=== Updating the Version\n\nEdit `version.edn` in the project root.\nThe release workflow consults this file when constructing the version.\n\n=== Special Setup\n\nGitHub has been configured with necessary secrets for GitHub Actions to deploy to clojars.\n\n=== Local Verification\nTo run the change log validation locally:\n\n[source,shell]\n----\nbb ci-release validate\n----\n\nIf you so wish, you can also locally run all steps up to, but not including, deploy via:\n\n[source,shell]\n----\nbb ci-release prep\n----\nBe aware though that you will NOT want to check in changes `prep` makes to `CHANGELOG.adoc` and `01-user-guide.adoc`.\n\n=== Invoking\n\nAs a maintainer you should have sufficient privileges to see a \"Run Workflow\" dropdown button on the https://github.com/clj-commons/rewrite-clj/actions?query=workflow%3A%22Release%22[Release] action page.\nThe dropdown will prompt for a branch.\nI did not see a way to disable this prompt, simply leave it at \"main\" and run the workflow.\n\nTIP: Don't forget to pull after a release to get the changes made by the release workflow.\n",
     :cljdoc.doc/type :cljdoc/asciidoc,
     :slug "maintainer-guide",
     :cljdoc.doc/contributors ("lread")}}],
  :config
  #:cljdoc.doc{:tree
               [["Readme" {:file "README.adoc"}]
                ["Changelog" {:file "CHANGELOG.adoc"}]
                ["User Guide" {:file "doc/01-user-guide.adoc"}]
                ["Developer Guide"
                 {:file "doc/02-developer-guide.adoc"}]
                ["Design"
                 {}
                 ["Merging rewrite-clj and rewrite-cljs"
                  {:file
                   "doc/design/01-merging-rewrite-clj-and-rewrite-cljs.adoc"}
                  ["Namespaced Elements"
                   {:file "doc/design/namespaced-elements.adoc"}]]
                 ["API Differences"
                  {}
                  ["rwt-clj v0 vs rwt-cljs"
                   {:file
                    "doc/generated/api-diffs/rewrite-clj-v0-lang-clj-and-rewrite-cljs-lang-cljs.adoc"}]
                  ["rwt-clj v0 vs rwt-clj v1"
                   {:file
                    "doc/generated/api-diffs/rewrite-clj-v0-lang-clj-and-rewrite-clj-v1-lang-clj.adoc"}]
                  ["rwt-cljs vs rwt-clj v1"
                   {:file
                    "doc/generated/api-diffs/rewrite-cljs-lang-cljs-and-rewrite-clj-v1-lang-cljs.adoc"}]
                  ["rwt-clj v1 clj vs cljs all"
                   {:file
                    "doc/generated/api-diffs/rewrite-clj-v1-lang-cljs-and-rewrite-clj-v1-lang-clj.adoc"}]
                  ["rwt-clj v1 clj vs cljs public"
                   {:file
                    "doc/generated/api-diffs/rewrite-clj-v1-lang-cljs-and-rewrite-clj-v1-lang-clj-documented-only.adoc"}]]]
                ["Frequently Asked Questions"
                 {:file "doc/03-faq.adoc"}]
                ["Contributing" {:file "CONTRIBUTING.md"}]
                ["Code of Conduct" {:file "CODE_OF_CONDUCT.md"}]
                ["Maintainer Guide"
                 {:file "doc/04-maintainer-guide.adoc"}]]}},
 :namespaces
 #{{:doc
    "Create, update, convert and integorate nodes.\n\nAll nodes represent Clojure/ClojureScript/EDN.\n\nBecause this API contains many functions, we offer the following categorized listing:\n\n**Node creation**\n[[comma-node]]\n[[comment-node]]\n[[deref-node]]\n[[eval-node]]\n[[fn-node]]\n[[forms-node]]\n[[integer-node]]\n[[keyword-node]]\n[[map-node]]\n[[map-qualifier-node]]\n[[meta-node]]\n[[namespaced-map-node]]\n[[newline-node]]\n[[quote-node]]\n[[raw-meta-node]]\n[[reader-macro-node]]\n[[regex-node]]\n[[set-node]]\n[[string-node]]\n[[syntax-quote-node]]\n[[token-node]]\n[[uneval-node]]\n[[unquote-node]]\n[[unquote-splicing-node]]\n[[var-node]]\n[[vector-node]]\n[[whitespace-node]]\n\n**Whitespace creation convenience**\n[[spaces]]\n[[newlines]]\n[[comma-separated]]\n[[line-separated]]\n[[whitespace-nodes]]\n\n**Convert form to node**\n[[coerce]]\n\n**Convert node to form**\n[[sexpr-able?]]\n[[sexpr]]\n[[sexprs]]\n[[child-sexprs]]\n\n**Convert node to string**\n[[string]]\n\n**Node interogation**\n[[tag]]\n[[inner?]]\n[[children]]\n[[length]]\n[[leader-length]]\n[[printable-only?]]\n\n**Update node**\n[[replace-children]]\n\n**Namespaced map element support**\n[[map-context-apply]]\n[[map-context-clear]]\n\n**Test type**\n[[node?]]\n[[comment?]]\n[[whitespace-or-comment?]]\n[[keyword-node?]]\n[[symbol-node?]]\n[[linebreak?]]\n[[comma?]]",
    :name "rewrite-clj.node",
    :platform "clj",
    :version-entity
    {:id 25,
     :group-id "rewrite-clj",
     :artifact-id "rewrite-clj",
     :version "1.0.767-alpha"}}
   {:name "rewrite-clj.zip",
    :doc
    "A rich API for navigating and updating Clojure/ClojureScripti/EDN source code via a zipper tree.\n\nThe zipper holds a tree of nodes representing source code. It also holds your current location while navigating\nthrough the tree and any pending changes you have made. Changes are applied back into the tree\nwhen invoking root functions.\n\nAlthough they are preserved, whitespace and comment nodes are normally skipped when navigating through the tree.\nThere are times when you will want to include whitespace and comment nodes, and as you see below, provisions are\navailable to do so.\n\nIt is good to remember that while some function names convey mutation, we are never changing anything, we are\ninstead returning modified copies.\n\nSome conventions in the code and docstrings:\n- `zloc` is the used as the argument name for our zipper\n- \"current node in `zloc`\" is shorthand for: node at current location in zipper `zloc`\n\nBecause this API contains many functions, we offer the following categorized listing:\n\n**Create a zipper**\n[[edn]]\n[[edn*]]\n[[of-string]]\n[[of-file]]\n\n**Move**\n[[left]]\n[[right]]\n[[up]]\n[[down]]\n[[prev]]\n[[next]]\n[[leftmost]]\n[[rightmost]]\n\n**Move without skipping whitespace and comments**\n[[left*]]\n[[right*]]\n[[up*]]\n[[down*]]\n[[prev*]]\n[[next*]]\n[[leftmost*]]\n[[rightmost*]]\n\n**Whitespace/comment aware skip**\n[[skip]]\n[[skip-whitespace]]\n[[skip-whitespace-left]]\n\n**Test for whitespace**\n[[whitespace?]]\n[[linebreak?]]\n[[whitespace-or-comment?]]\n\n**Test location**\n[[leftmost?]]\n[[rightmost?]]\n[[end?]]\n\n**Test data type**\n[[seq?]]\n[[list?]]\n[[vector?]]\n[[set?]]\n[[map?]]\n[[namespaced-map?]]\n\n**Find**\n[[find]]\n[[find-next]]\n[[find-depth-first]]\n[[find-next-depth-first]]\n[[find-tag]]\n[[find-next-tag]]\n[[find-value]]\n[[find-next-value]]\n[[find-token]]\n[[find-next-token]]\n[[find-last-by-pos]]\n[[find-tag-by-pos]]\n\n**Inspect**\n[[node]]\n[[position]]\n[[position-span]]\n[[tag]]\n[[length]]\n\n**Convert**\n[[sexpr-able?]]\n[[sexpr]]\n[[child-sexprs]]\n[[reapply-context]]\n\n**Update**\n[[replace]]\n[[edit]]\n[[splice]]\n[[prefix]]\n[[suffix]]\n[[insert-right]]\n[[insert-left]]\n[[insert-child]]\n[[insert-space-left]]\n[[insert-space-right]]\n[[insert-newline-left]]\n[[insert-newline-right]]\n[[append-child]]\n[[remove]]\n[[remove-preserve-newline]]\n[[root]]\n\n**Update without coercion**\n[[replace*]]\n[[edit*]]\n\n**Update without whitespace treatment**\n[[insert-left*]]\n[[insert-right*]]\n[[insert-child*]]\n[[append-child*]]\n[[remove*]]\n\n**Update without changing location**\n[[edit-node]]\n[[edit->]]\n[[edit->>]]\n\n**Isolated update without changing location**\n[[subedit-node]]\n[[subzip]]\n[[prewalk]]\n[[postwalk]]\n[[subedit->]]\n[[subedit->>]]\n\n**Sequence operations**\n[[map]]\n[[map-keys]]\n[[map-vals]]\n[[get]]\n[[assoc]]\n\n**Stringify**\n[[string]]\n[[root-string]]\n\n**Output**\n[[print]]\n[[print-root]]",
    :platform "cljs",
    :version-entity
    {:id 25,
     :group-id "rewrite-clj",
     :artifact-id "rewrite-clj",
     :version "1.0.767-alpha"}}
   {:name "rewrite-clj.node",
    :doc
    "Create, update, convert and integorate nodes.\n\nAll nodes represent Clojure/ClojureScript/EDN.\n\nBecause this API contains many functions, we offer the following categorized listing:\n\n**Node creation**\n[[comma-node]]\n[[comment-node]]\n[[deref-node]]\n[[eval-node]]\n[[fn-node]]\n[[forms-node]]\n[[integer-node]]\n[[keyword-node]]\n[[map-node]]\n[[map-qualifier-node]]\n[[meta-node]]\n[[namespaced-map-node]]\n[[newline-node]]\n[[quote-node]]\n[[raw-meta-node]]\n[[reader-macro-node]]\n[[regex-node]]\n[[set-node]]\n[[string-node]]\n[[syntax-quote-node]]\n[[token-node]]\n[[uneval-node]]\n[[unquote-node]]\n[[unquote-splicing-node]]\n[[var-node]]\n[[vector-node]]\n[[whitespace-node]]\n\n**Whitespace creation convenience**\n[[spaces]]\n[[newlines]]\n[[comma-separated]]\n[[line-separated]]\n[[whitespace-nodes]]\n\n**Convert form to node**\n[[coerce]]\n\n**Convert node to form**\n[[sexpr-able?]]\n[[sexpr]]\n[[sexprs]]\n[[child-sexprs]]\n\n**Convert node to string**\n[[string]]\n\n**Node interogation**\n[[tag]]\n[[inner?]]\n[[children]]\n[[length]]\n[[leader-length]]\n[[printable-only?]]\n\n**Update node**\n[[replace-children]]\n\n**Namespaced map element support**\n[[map-context-apply]]\n[[map-context-clear]]\n\n**Test type**\n[[node?]]\n[[comment?]]\n[[whitespace-or-comment?]]\n[[keyword-node?]]\n[[symbol-node?]]\n[[linebreak?]]\n[[comma?]]",
    :platform "cljs",
    :version-entity
    {:id 25,
     :group-id "rewrite-clj",
     :artifact-id "rewrite-clj",
     :version "1.0.767-alpha"}}
   {:doc
    "A rich API for navigating and updating Clojure/ClojureScripti/EDN source code via a zipper tree.\n\nThe zipper holds a tree of nodes representing source code. It also holds your current location while navigating\nthrough the tree and any pending changes you have made. Changes are applied back into the tree\nwhen invoking root functions.\n\nAlthough they are preserved, whitespace and comment nodes are normally skipped when navigating through the tree.\nThere are times when you will want to include whitespace and comment nodes, and as you see below, provisions are\navailable to do so.\n\nIt is good to remember that while some function names convey mutation, we are never changing anything, we are\ninstead returning modified copies.\n\nSome conventions in the code and docstrings:\n- `zloc` is the used as the argument name for our zipper\n- \"current node in `zloc`\" is shorthand for: node at current location in zipper `zloc`\n\nBecause this API contains many functions, we offer the following categorized listing:\n\n**Create a zipper**\n[[edn]]\n[[edn*]]\n[[of-string]]\n[[of-file]]\n\n**Move**\n[[left]]\n[[right]]\n[[up]]\n[[down]]\n[[prev]]\n[[next]]\n[[leftmost]]\n[[rightmost]]\n\n**Move without skipping whitespace and comments**\n[[left*]]\n[[right*]]\n[[up*]]\n[[down*]]\n[[prev*]]\n[[next*]]\n[[leftmost*]]\n[[rightmost*]]\n\n**Whitespace/comment aware skip**\n[[skip]]\n[[skip-whitespace]]\n[[skip-whitespace-left]]\n\n**Test for whitespace**\n[[whitespace?]]\n[[linebreak?]]\n[[whitespace-or-comment?]]\n\n**Test location**\n[[leftmost?]]\n[[rightmost?]]\n[[end?]]\n\n**Test data type**\n[[seq?]]\n[[list?]]\n[[vector?]]\n[[set?]]\n[[map?]]\n[[namespaced-map?]]\n\n**Find**\n[[find]]\n[[find-next]]\n[[find-depth-first]]\n[[find-next-depth-first]]\n[[find-tag]]\n[[find-next-tag]]\n[[find-value]]\n[[find-next-value]]\n[[find-token]]\n[[find-next-token]]\n[[find-last-by-pos]]\n[[find-tag-by-pos]]\n\n**Inspect**\n[[node]]\n[[position]]\n[[position-span]]\n[[tag]]\n[[length]]\n\n**Convert**\n[[sexpr-able?]]\n[[sexpr]]\n[[child-sexprs]]\n[[reapply-context]]\n\n**Update**\n[[replace]]\n[[edit]]\n[[splice]]\n[[prefix]]\n[[suffix]]\n[[insert-right]]\n[[insert-left]]\n[[insert-child]]\n[[insert-space-left]]\n[[insert-space-right]]\n[[insert-newline-left]]\n[[insert-newline-right]]\n[[append-child]]\n[[remove]]\n[[remove-preserve-newline]]\n[[root]]\n\n**Update without coercion**\n[[replace*]]\n[[edit*]]\n\n**Update without whitespace treatment**\n[[insert-left*]]\n[[insert-right*]]\n[[insert-child*]]\n[[append-child*]]\n[[remove*]]\n\n**Update without changing location**\n[[edit-node]]\n[[edit->]]\n[[edit->>]]\n\n**Isolated update without changing location**\n[[subedit-node]]\n[[subzip]]\n[[prewalk]]\n[[postwalk]]\n[[subedit->]]\n[[subedit->>]]\n\n**Sequence operations**\n[[map]]\n[[map-keys]]\n[[map-vals]]\n[[get]]\n[[assoc]]\n\n**Stringify**\n[[string]]\n[[root-string]]\n\n**Output**\n[[print]]\n[[print-root]]",
    :name "rewrite-clj.zip",
    :platform "clj",
    :version-entity
    {:id 25,
     :group-id "rewrite-clj",
     :artifact-id "rewrite-clj",
     :version "1.0.767-alpha"}}
   {:doc
    "Paredit zipper operations for Clojure/ClojureScript/EDN.\n\nYou might find inspiration from examples here: http://pub.gajendra.net/src/paredit-refcard.pdf",
    :name "rewrite-clj.paredit",
    :platform "clj",
    :version-entity
    {:id 25,
     :group-id "rewrite-clj",
     :artifact-id "rewrite-clj",
     :version "1.0.767-alpha"}}
   {:doc
    "Parse Clojure/ClojureScript/EDN source code to nodes.\n\nParsing includes all source code elements including whitespace.\n\nAfter parsing, the typical next step is [[rewrite-clj.zip/edn]] to create zipper.\n\nAlternatively consider parsing and zipping in one step from [[rewrite-clj.zip/of-string]] or [[rewrite-clj.zip/of-file]].",
    :name "rewrite-clj.parser",
    :platform "clj",
    :version-entity
    {:id 25,
     :group-id "rewrite-clj",
     :artifact-id "rewrite-clj",
     :version "1.0.767-alpha"}}
   {:name "rewrite-clj.parser",
    :doc
    "Parse Clojure/ClojureScript/EDN source code to nodes.\n\nParsing includes all source code elements including whitespace.\n\nAfter parsing, the typical next step is [[rewrite-clj.zip/edn]] to create zipper.\n\nAlternatively consider parsing and zipping in one step from [[rewrite-clj.zip/of-string]] or [[rewrite-clj.zip/of-file]].",
    :platform "cljs",
    :version-entity
    {:id 25,
     :group-id "rewrite-clj",
     :artifact-id "rewrite-clj",
     :version "1.0.767-alpha"}}
   {:doc
    "APIs to navigate and update Clojure/ClojureScript/EDN source code.\n\nUse [[rewrite-clj.zip]] to ingest your source code into a zipper of nodes and then again to navigate and/or change it.\n\nOptionally use [[rewrite-clj.parser]] to instead work with raw nodes.\n\n[[rewrite-clj.node]] will help you to inspect and create nodes.\n\n[[rewrite-clj.paredit]] first appeared in the ClojureScript only version of rewrite-clj and supports structured editing of the zipper tree.",
    :name "rewrite-clj",
    :platform "clj",
    :version-entity
    {:id 25,
     :group-id "rewrite-clj",
     :artifact-id "rewrite-clj",
     :version "1.0.767-alpha"}}
   {:name "rewrite-clj.paredit",
    :doc
    "Paredit zipper operations for Clojure/ClojureScript/EDN.\n\nYou might find inspiration from examples here: http://pub.gajendra.net/src/paredit-refcard.pdf",
    :platform "cljs",
    :version-entity
    {:id 25,
     :group-id "rewrite-clj",
     :artifact-id "rewrite-clj",
     :version "1.0.767-alpha"}}
   {:name "rewrite-clj",
    :doc
    "APIs to navigate and update Clojure/ClojureScript/EDN source code.\n\nUse [[rewrite-clj.zip]] to ingest your source code into a zipper of nodes and then again to navigate and/or change it.\n\nOptionally use [[rewrite-clj.parser]] to instead work with raw nodes.\n\n[[rewrite-clj.node]] will help you to inspect and create nodes.\n\n[[rewrite-clj.paredit]] first appeared in the ClojureScript only version of rewrite-clj and supports structured editing of the zipper tree.",
    :platform "cljs",
    :version-entity
    {:id 25,
     :group-id "rewrite-clj",
     :artifact-id "rewrite-clj",
     :version "1.0.767-alpha"}}},
 :defs
 #{{:added "0.5.0",
    :name "insert-space-right",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 887,
    :arglists ([zloc] [zloc n]),
    :doc
    "Return zipper with `n` space whitespace node inserted to the right of the current node in `zloc`, without moving location.\n`n` defaults to 1.",
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "slurp-forward",
    :file "rewrite_clj/paredit.cljc",
    :line 233,
    :arglists ([zloc]),
    :doc
    "Pull in next right outer node (if none at first level, tries next etc) into\ncurrent S-expression\n\n- `[1 2 [|3] 4 5] => [1 2 [|3 4] 5]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "clj"}
   {:name "prev",
    :file "rewrite_clj/zip.cljc",
    :line 531,
    :arglists ([zloc]),
    :doc
    "Return zipper with location moved to the previous depth-first non-whitespace/non-comment node in `zloc`. If already at root, returns nil.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "raise",
    :file "rewrite_clj/paredit.cljc",
    :line 515,
    :arglists ([zloc]),
    :doc
    "Delete siblings and raise node at zloc one level up\n\n- `[1 [2 |3 4]] => [1 |3]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "clj"}
   {:name "rightmost?",
    :file "rewrite_clj/zip.cljc",
    :line 557,
    :arglists ([zloc]),
    :doc
    "Return true if at rightmost non-whitespace/non-comment sibling node in `zloc`.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "append-newline",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 926,
    :deprecated "0.5.0",
    :arglists ([zloc n] [zloc]),
    :doc "DEPRECATED: renamed to [[insert-newline-right]].\n",
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "insert-left*",
    :file "rewrite_clj/zip.cljc",
    :line 1051,
    :arglists ([zloc item]),
    :doc
    "Raw version of [[insert-left]].\n\nReturns zipper with node `item` inserted as the left sibling of current node in `zloc`,\n without moving location.\n\nNOTE: This function does no coercion, does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "sexpr",
    :file "rewrite_clj/node.cljc",
    :line 156,
    :arglists ([node] [node opts]),
    :doc
    "Return `node` converted to form.\n\nOptional `opts` can specify:\n- `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\n\nSee docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "replace",
    :file "rewrite_clj/zip.cljc",
    :line 306,
    :arglists ([zloc item]),
    :doc
    "Return `zloc` with the current node replaced by `item`.\nIf `item` is not already a node, an attempt will be made to coerce it to one.\n\nUse [[replace*]] for non-coercing version of replace.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "up*",
    :file "rewrite_clj/zip.cljc",
    :line 962,
    :arglists ([zloc]),
    :doc
    "Raw version of [[up]].\n\nReturns zipper with the location at the parent of current node in `zloc`, or nil if at\n  the top.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "append-child*",
    :file "rewrite_clj/zip.cljc",
    :line 1081,
    :arglists ([zloc item]),
    :doc
    "Raw version of [[append-child]].\n\nReturns zipper with node `item` inserted as the rightmost child of the current node in `zloc`,\n  without moving.\n\nNOTE: This function does no coercion, does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "remove",
    :file "rewrite_clj/zip.cljc",
    :line 567,
    :arglists ([zloc]),
    :doc
    "Return `zloc` with current node removed. Returned zipper location\n is moved to the first non-whitespace node preceding removed node in a depth-first walk.\n Removes whitespace appropriately.\n\n- `[1 |2  3]    => [|1 3]`\n- `[1 |2]       => [|1]`\n- `[|1 2]       => |[2]`\n- `[|1]         => |[]`\n- `[  |1  ]     => |[]`\n- `[1 [2 3] |4] => [1 [2 |3]]`\n- `[|1 [2 3] 4] => |[[2 3] 4]`\n\n If the removed node is a rightmost sibling, both leading and trailing whitespace\n is removed, otherwise only trailing whitespace is removed.\n\n The result is that a following element (no matter whether it is on the same line\n or not) will end up at same positon (line/column) as the removed one.\n If a comment lies betwen the original node and the neighbour this will not hold true.\n\n If the removed node is at end of input and is trailed by 1 or more newlines,\n a single trailing newline will be preserved.\n\n Use [[remove*]] to remove node without removing any surrounding whitespace.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "comment-node",
    :file "rewrite_clj/node.cljc",
    :line 212,
    :arglists ([s] [prefix s]),
    :doc
    "Create node representing a comment with text `s`.\n\nYou may optionally specify a `prefix` of `\";\"` or `\"#!\"`, defaults is `\";\"`.\n\nArgument `s`:\n- must not include the `prefix`\n- usually includes the trailing newline character, otherwise subsequent nodes will be on the comment line\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/comment-node \"; my comment\\n\")\n    n/string)\n;; => \";; my comment\\n\"\n\n(-> (n/comment-node \"#!\" \"/usr/bin/env bb\\n\")\n    n/string)\n;; => \"#!/usr/bin/env bb\\n\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "prev",
    :file "rewrite_clj/zip.cljc",
    :line 531,
    :arglists ([zloc]),
    :doc
    "Return zipper with location moved to the previous depth-first non-whitespace/non-comment node in `zloc`. If already at root, returns nil.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "kill-one-at-pos",
    :file "rewrite_clj/paredit.cljc",
    :line 194,
    :arglists ([zloc pos]),
    :doc
    "In string and comment aware kill for one node/word at `pos` in `zloc`.\n\n- `(+ |100 100) => (+ |100)`\n- `(for |(bar do)) => (foo)`\n- `\"|hello world\" => \"| world\"`\n- ` ; |hello world => ;  |world`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "cljs"}
   {:name "keyword-node",
    :file "rewrite_clj/node.cljc",
    :line 302,
    :arglists ([k auto-resolved?] [k]),
    :doc
    "Create a node representing a keyword `k`.\n\nOptionally include `auto-resolved?`, which defaults to `false`.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n;; unqualified keyword\n(-> (n/keyword-node :kw)\n    n/string)\n;; => \":kw\"\n\n;; qualified keyword\n(-> (n/keyword-node :my-prefix/kw)\n    n/string)\n;; => \":my-prefix/kw\"\n\n;; keyword auto-resolved to current ns\n(-> (n/keyword-node :kw true)\n    n/string)\n;; => \"::kw\"\n\n;; keyword auto-resolved to a namespace with given alias\n(-> (n/keyword-node :ns-alias/kw true)\n    n/string)\n;; => \"::ns-alias/kw\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "rightmost",
    :file "rewrite_clj/zip.cljc",
    :line 547,
    :arglists ([zloc]),
    :doc
    "Return zipper with location moved to the rightmost non-whitespace/non-comment sibling of current node in `zloc`.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:added "0.4.9",
    :name "postwalk",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 802,
    :arglists ([zloc f] [zloc p? f]),
    :doc
    "Return zipper modified by an isolated depth-first post-order traversal.\n\nPre-order traversal visits children before root.\nFor example, traversal order of `(1 (2 3 (4 5) 6 (7 8)) 9)` is:\n\n1. `1`\n2. `2`\n3. `3`\n4. `4`\n5. `5`\n6. `(4 5)`\n7. `6`\n8. `7`\n9. `8`\n10. `(7 8)`\n11. `(2 3 (4 5) 6 (7 8))`\n12. `9`\n13. `(1 (2 3 (4 5) 6 (7 8)) 9)`\n\nTraversal starts at the current node in `zloc` and continues to the end of the isolated sub-tree.\n\nFunction `f` is called on the zipper locations satisfying predicate `p?` and must return either\n- nil to indicate no changes\n- or a valid zipper\nWARNING: when function `f` changes the location in the zipper, normal traversal will be affected.\n\nWhen `p?` is not specified `f` is called on all locations.\n\nNote that by default a newly created zipper automatically navigates to the first non-whitespace\nnode. If you want to be sure to walk all forms in a zipper, you'll want to navigate one up prior to your walk:\n\n```Clojure\n(-> (zip/of-string \"my clojure forms\")\n    zip/up\n    (zip/postwalk ...))\n```\n\nSee [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).",
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "list?",
    :file "rewrite_clj/zip.cljc",
    :line 605,
    :arglists ([zloc]),
    :doc "Returns true if current node in `zloc` is a list.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "comma-node",
    :file "rewrite_clj/node.cljc",
    :line 834,
    :arglists ([s]),
    :doc
    "Create comma node of string `s`, where `s` is one or more comma characters.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "insert-right*",
    :file "rewrite_clj/zip.cljc",
    :line 1061,
    :arglists ([zloc item]),
    :doc
    "Raw version of [[insert-right]].\n\nReturns zipper with node `item` inserted as the right sibling of the current node in `zloc`,\n  without moving location.\n\nNOTE: This function does no coercion, does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "raise",
    :file "rewrite_clj/paredit.cljc",
    :line 515,
    :arglists ([zloc]),
    :doc
    "Delete siblings and raise node at zloc one level up\n\n- `[1 [2 |3 4]] => [1 |3]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "cljs"}
   {:name "position",
    :file "rewrite_clj/zip.cljc",
    :line 181,
    :arglists ([zloc]),
    :doc
    "Returns the ones-based `[row col]` of the start of the current node in `zloc`.\n\nThrows if `zloc` was not created with [position tracking](/doc/01-user-guide.adoc#position-tracking).",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "find-next",
    :file "rewrite_clj/zip.cljc",
    :line 376,
    :arglists ([zloc p?] [zloc f p?]),
    :doc
    "Return `zloc` located to the next node satisfying predicate `p?` else `nil`.\nSearch starts one movement `f` from the current node and continues via `f`.\n\n`f` defaults to [[right]]",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "set?",
    :file "rewrite_clj/zip.cljc",
    :line 615,
    :arglists ([zloc]),
    :doc "Returns true if current node in `zloc` is a set.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "next",
    :file "rewrite_clj/zip.cljc",
    :line 536,
    :arglists ([zloc]),
    :doc
    "Return zipper with location moved to the next depth-first non-whitespace/non-comment node in `zloc`.\nEnd can be detected with [[end?]], if already at end, stays there.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "map",
    :file "rewrite_clj/zip.cljc",
    :line 630,
    :arglists ([f zloc]),
    :doc
    "Returns `zloc` with function `f` applied to all nodes of the current node.\nCurrent node must be a sequence node. Equivalent to [[rewrite-clj.zip/map-vals]] for maps.\n\n`zloc` location is unchanged.\n\n`f` arg is zloc positioned at\n- value nodes for maps\n- each element of a seq\nand is should return:\n- an updated zloc with zloc positioned at edited node\n- a falsey value to leave value node unchanged\n\nFolks typically use [[edit]] for `f`.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "left",
    :file "rewrite_clj/zip.cljc",
    :line 511,
    :arglists ([zloc]),
    :doc
    "Return zipper with location moved left to next non-whitespace/non-comment sibling of current node in `zloc`.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "sexpr-able?",
    :file "rewrite_clj/zip.cljc",
    :line 242,
    :arglists ([zloc]),
    :doc
    "Return true if current node's element type in `zloc` can be [[sexpr]]-ed.\n\nSee [related docs in user guide](/doc/01-user-guide.adoc#not-all-clojure-is-sexpr-able)",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "set-node",
    :file "rewrite_clj/node.cljc",
    :line 611,
    :arglists ([children]),
    :doc
    "Create a node representing a set with `children`.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/set-node [(n/token-node 1)\n                 (n/spaces 1)\n                 (n/token-node 2)\n                 (n/spaces 1)\n                 (n/token-node 3)])\n    n/string)\n;; => \"#{1 2 3}\"\n```\n\nNote that rewrite-clj allows the, technically illegal, set with duplicate values:\n```Clojure\n(-> (n/set-node [(n/token-node 1)\n                 (n/spaces 1)\n                 (n/token-node 1)])\n    (n/string))\n;; => \"#{1 1}\"\n```\n\nSee [docs on sets with duplicate values](/doc/01-user-guide.adoc#sets-with-duplicate-values).",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "down*",
    :file "rewrite_clj/zip.cljc",
    :line 972,
    :arglists ([zloc]),
    :doc
    "Raw version of [[down]].\n\nReturns zipper with the location at the leftmost child of current node in `zloc`, or\n  nil if no children.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "namespaced-map-node",
    :file "rewrite_clj/node.cljc",
    :line 430,
    :arglists ([children]),
    :doc
    "Create a namespaced map node with `children`.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/namespaced-map-node [(n/map-qualifier-node true \"my-ns-alias\")\n                            (n/spaces 1)\n                            (n/map-node [(n/keyword-node :a)\n                                         (n/spaces 1)\n                                         (n/token-node 1)])])\n    n/string)\n;; => \"#::my-ns-alias {:a 1}\"\n```\n\nMap qualifier context is automatically applied to map keys for sexpr support.\n\nSee also [[map-qualifier-node]] and [[map-node]].",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "subedit->",
    :file "rewrite_clj/zip.cljc",
    :line 743,
    :arglists ([zloc & body]),
    :doc
    "Like `->`, threads `zloc`, as an isolated sub-tree through forms, then zips\nup to, and locates at, the root of the modified sub-tree.\n\nSee [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).",
    :type :macro,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "insert-child",
    :file "rewrite_clj/zip.cljc",
    :line 493,
    :arglists ([zloc item]),
    :doc
    "Return zipper with `item` inserted as the first child of the current node in `zloc`, without moving location.\nWill insert a space if necessary.\nIf `item` is not already a node, an attempt will be made to coerce it to one.\n\nUse [[insert-child*]] to insert without adding any whitespace.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "string-node",
    :file "rewrite_clj/node.cljc",
    :line 656,
    :arglists ([lines]),
    :doc
    "Create node representing a string value where `lines` can be a sequence of strings or a single string.\n\nWhen `lines` is a sequence, the resulting node will `tag` will be `:multi-line`, otherwise `:token`.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/string-node \"hello\")\n    n/string)\n;; => \"\\\"hello\\\"\"\n\n(-> (n/string-node [\"line1\" \"\" \"line3\"])\n     n/string)\n;; => \"\\\"line1\\n\\nline3\\\"\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "comma-node",
    :file "rewrite_clj/node.cljc",
    :line 834,
    :arglists ([s]),
    :doc
    "Create comma node of string `s`, where `s` is one or more comma characters.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:added "0.5.0",
    :name "insert-newline-right",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 901,
    :arglists ([zloc] [zloc n]),
    :doc
    "Return zipper with `n` newlines node inserted to the right of the current node in `zloc`, without moving location.\n`n` defaults to 1.",
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "eval-node",
    :file "rewrite_clj/node.cljc",
    :line 485,
    :arglists ([children]),
    :doc
    "Create node representing an inline evaluation\nwhere `children` is either a sequence of nodes or a single node.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/eval-node (n/list-node [(n/token-node 'inc)\n                               (n/spaces 1)\n                               (n/token-node 1)]))\n    n/string)\n;; => \"#=(inc 1)\"\n\n;; specifying a sequence allows for whitespace between the\n;; prefix and the form\n(-> (n/eval-node [(n/spaces 3)\n                  (n/list-node [(n/token-node 'inc)\n                                (n/spaces 1)\n                                (n/token-node 1)])])\n    n/string)\n;; => \"#=   (inc 1)\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "print",
    :file "rewrite_clj/zip.cljc",
    :line 290,
    :arglists ([zloc writer] [zloc]),
    :doc
    "Print current node in `zloc`.\n\nNOTE: Optional `writer` is currently ignored for ClojureScript.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "vector-node",
    :file "rewrite_clj/node.cljc",
    :line 639,
    :arglists ([children]),
    :doc
    "Create a node representing a vector with `children`.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/vector-node [(n/token-node 1)\n                    (n/spaces 1)\n                    (n/token-node 2)\n                    (n/spaces 1)\n                    (n/token-node 3)])\n    n/string)\n;; => \"[1 2 3]\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "slurp-backward",
    :file "rewrite_clj/paredit.cljc",
    :line 271,
    :arglists ([zloc]),
    :doc
    "Pull in prev left outer node (if none at first level, tries next etc) into\ncurrent S-expression\n\n- `[1 2 [|3] 4 5] => [1 [2 |3] 4 5]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "cljs"}
   {:name "->string",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 275,
    :deprecated "0.4.0",
    :arglists ([zloc]),
    :doc "DEPRECATED. Renamed to [[string]].\n",
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "root",
    :file "rewrite_clj/zip.cljc",
    :line 196,
    :arglists ([zloc]),
    :doc
    "Zips all the way up `zloc` and returns the root node, reflecting any changes.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "value",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 254,
    :deprecated "0.4.0",
    :arglists ([zloc]),
    :doc
    "DEPRECATED. Return a tag/s-expression pair for inner nodes, or\nthe s-expression itself for leaves.",
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "var-node",
    :file "rewrite_clj/node.cljc",
    :line 533,
    :arglists ([children]),
    :doc
    "Create node representing a var where `children` is either a\nsequence of nodes or a single node.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/var-node (n/token-node 'my-var))\n    n/string)\n;; => \"#'my-var\"\n\n;; specifying a sequence allows for whitespace between the\n;; prefix and the var\n(-> (n/var-node [(n/spaces 2)\n                 (n/token-node 'my-var)])\n    n/string)\n;; => \"#'  my-var\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "map?",
    :file "rewrite_clj/zip.cljc",
    :line 620,
    :arglists ([zloc]),
    :doc "Returns true if current node in `zloc` is a map.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "tag",
    :file "rewrite_clj/node.cljc",
    :line 200,
    :arglists ([node]),
    :doc "Returns keyword representing type of `node`.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "whitespace-nodes",
    :file "rewrite_clj/node.cljc",
    :line 844,
    :arglists ([s]),
    :doc
    "Convert string `s` of whitespace to whitespace/newline nodes.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "up",
    :file "rewrite_clj/zip.cljc",
    :line 521,
    :arglists ([zloc]),
    :doc
    "Return zipper with location moved up to next non-whitespace/non-comment parent of current node in `zloc`, or `nil` if at the top.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "symbol-node?",
    :file "rewrite_clj/node.cljc",
    :line 775,
    :arglists ([n]),
    :doc "Returns true if `n` is a node representing a symbol.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "->string",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 275,
    :deprecated "0.4.0",
    :arglists ([zloc]),
    :doc "DEPRECATED. Renamed to [[string]].\n",
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "unquote-node",
    :file "rewrite_clj/node.cljc",
    :line 717,
    :arglists ([children]),
    :doc
    "Create node representing a single unquoted form where `children`\nis either a sequence of nodes or a single node.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/unquote-node (n/token-node 'my-var))\n    n/string)\n;; => \"~my-var\"\n\n;; specifying a sequence allows for whitespace between the\n;; unquote and the uquoted\n(-> (n/unquote-node [(n/spaces 4)\n                     (n/token-node 'my-var)])\n    n/string)\n;; => \"~    my-var\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "move-to-prev",
    :file "rewrite_clj/paredit.cljc",
    :line 526,
    :arglists ([zloc]),
    :doc
    "Move node at current location to the position of previous location given a depth first traversal\n\n  -  `(+ 1 (+ 2 |3) 4) => (+ 1 (+ |3 2) 4)`\n  - `(+ 1 (+ 2 3) |4) => (+ 1 (+ 2 3 |4))`\n\nreturns zloc after move or given zloc if a move isn't possible",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "clj"}
   {:name "kill",
    :file "rewrite_clj/paredit.cljc",
    :line 80,
    :arglists ([zloc]),
    :doc
    "Kill all sibling nodes to the right of the current node in `zloc`.\n\n- `[1 2| 3 4] => [1 2|]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "clj"}
   {:name "quote-node",
    :file "rewrite_clj/node.cljc",
    :line 675,
    :arglists ([children]),
    :doc
    "Create node representing a single quoted form where `children`\nis either a sequence of nodes or a single node.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/quote-node (n/token-node 'sym))\n    (n/string))\n;; => \"'sym\"\n\n;; specifying a sequence allows for whitespace between the\n;; quote and the quoted\n(-> (n/quote-node [(n/spaces 10)\n                   (n/token-node 'sym1) ])\n    n/string)\n;; => \"'          sym1\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "kill-one-at-pos",
    :file "rewrite_clj/paredit.cljc",
    :line 194,
    :arglists ([zloc pos]),
    :doc
    "In string and comment aware kill for one node/word at `pos` in `zloc`.\n\n- `(+ |100 100) => (+ |100)`\n- `(for |(bar do)) => (foo)`\n- `\"|hello world\" => \"| world\"`\n- ` ; |hello world => ;  |world`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "clj"}
   {:name "edit",
    :file "rewrite_clj/zip.cljc",
    :line 314,
    :arglists ([zloc f & args]),
    :doc
    "Return `zloc` with the current node replaced with the result of:\n\n `(apply f (s-expr current-node) args)`\n\nThe result of `f`, if not already a node, will be coerced to a node if possible.\n\nSee docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).\n\nUse [[edit*]] for non-coercing version of edit.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "join",
    :file "rewrite_clj/paredit.cljc",
    :line 497,
    :arglists ([zloc]),
    :doc
    "Join S-expression to the left and right of current loc. Also works for strings.\n\n- `[[1 2] |[3 4]] => [[1 2 3 4]]`\n- `[\"Hello \" | \"World\"] => [\"Hello World\"]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "cljs"}
   {:name "up",
    :file "rewrite_clj/zip.cljc",
    :line 521,
    :arglists ([zloc]),
    :doc
    "Return zipper with location moved up to next non-whitespace/non-comment parent of current node in `zloc`, or `nil` if at the top.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "reapply-context",
    :file "rewrite_clj/zip.cljc",
    :line 354,
    :arglists ([zloc]),
    :doc
    "Returns `zloc` with namespaced map sexpr context to all symbols and keywords reapplied from current location downward.\n\nKeywords and symbols:\n* that are keys in a namespaced map will have namespaced map context applied\n* otherwise will have any namespaced map context removed\n\nYou should only need to use this function if:\n* you care about `sexpr` on keywords and symbols\n* and you are moving keywords and symbols from a namespaced map to some other location.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "map?",
    :file "rewrite_clj/zip.cljc",
    :line 620,
    :arglists ([zloc]),
    :doc "Returns true if current node in `zloc` is a map.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "edit-node",
    :file "rewrite_clj/zip.cljc",
    :line 701,
    :arglists ([zloc f]),
    :doc
    "Return zipper applying function `f` to `zloc`. The resulting\nzipper will be located at the same path (i.e. the same number of\ndownwards and right movements from the root) incoming `zloc`.\n\nSee also [[subedit-node]] for an isolated edit.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "unquote-splicing-node",
    :file "rewrite_clj/node.cljc",
    :line 738,
    :arglists ([children]),
    :doc
    "Create node representing a single unquote-spliced form where `children`\nis either a sequence of nodes or a single node.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/unquote-splicing-node (n/token-node 'my-var))\n    n/string)\n;; => \"~@my-var\"\n\n;; specifying a sequence allows for whitespace between the\n;; splicing unquote and the splicing unquoted\n(-> (n/unquote-splicing-node [(n/spaces 2)\n                              (n/token-node 'my-var)])\n    n/string)\n;; => \"~@  my-var\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "slurp-forward-fully",
    :file "rewrite_clj/paredit.cljc",
    :line 256,
    :arglists ([zloc]),
    :doc
    "Pull in all right outer-nodes into current S-expression, but only the ones at the same level\nas the the first one.\n\n- `[1 2 [|3] 4 5] => [1 2 [|3 4 5]]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "clj"}
   {:name "uneval-node",
    :file "rewrite_clj/node.cljc",
    :line 780,
    :arglists ([children]),
    :doc
    "Create node representing an unevaled form with `children`.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/uneval-node [(n/spaces 1)\n                    (n/token-node 42)])\n    n/string)\n;; => \"#_ 42\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "insert-child*",
    :file "rewrite_clj/zip.cljc",
    :line 1071,
    :arglists ([zloc item]),
    :doc
    "Raw version of [[insert-child]].\n\nReturns zipper with node `item` inserted as the leftmost child of the current node in `zloc`,\n  without moving location.\n\nNOTE: This function does no coercion, does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "suffix",
    :file "rewrite_clj/zip.cljc",
    :line 347,
    :arglists ([zloc s]),
    :doc
    "Return zipper with the current node in `zloc` suffixed with string `s`.\nOperates on token node or a multi-line node, else exception is thrown.\nWhen multi-line, last line is suffixed.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "print",
    :file "rewrite_clj/zip.cljc",
    :line 290,
    :arglists ([zloc writer] [zloc]),
    :doc
    "Print current node in `zloc`.\n\nNOTE: Optional `writer` is currently ignored for ClojureScript.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "append-space",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 914,
    :deprecated "0.5.0",
    :arglists ([zloc n] [zloc]),
    :doc "DEPRECATED: renamed to [[insert-space-right]].\n",
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "next",
    :file "rewrite_clj/zip.cljc",
    :line 536,
    :arglists ([zloc]),
    :doc
    "Return zipper with location moved to the next depth-first non-whitespace/non-comment node in `zloc`.\nEnd can be detected with [[end?]], if already at end, stays there.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "find-tag",
    :file "rewrite_clj/zip.cljc",
    :line 397,
    :arglists ([zloc t] [zloc f t]),
    :doc
    "Return `zloc` located to the first node with tag `t` else `nil`.\nSearch starts at the current node and continues via movement function `f`.\n\n`f` defaults to [[right]]",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "splice",
    :file "rewrite_clj/zip.cljc",
    :line 327,
    :arglists ([zloc]),
    :doc
    "Return zipper with the children of the current node in `zloc` merged into itself.\n (akin to Clojure's `unquote-splicing` macro: `~@...`).\n - if the node is not one that can have children, no modification will\n   be performed.\n - if the node has no or only whitespace children, it will be removed.\n - otherwise, splicing will be performed, moving the zipper to the first\n   non-whitespace spliced child node.\n\nFor example, given `[[1 2 3] 4 5 6]`, if zloc is located at vector `[1 2 3]`, a splice will result in raising the vector's children up `[1 2 3 4 5 6]` and locating the zipper at node `1`.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "uneval-node",
    :file "rewrite_clj/node.cljc",
    :line 780,
    :arglists ([children]),
    :doc
    "Create node representing an unevaled form with `children`.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/uneval-node [(n/spaces 1)\n                    (n/token-node 42)])\n    n/string)\n;; => \"#_ 42\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "append-child*",
    :file "rewrite_clj/zip.cljc",
    :line 1081,
    :arglists ([zloc item]),
    :doc
    "Raw version of [[append-child]].\n\nReturns zipper with node `item` inserted as the rightmost child of the current node in `zloc`,\n  without moving.\n\nNOTE: This function does no coercion, does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "barf-forward",
    :file "rewrite_clj/paredit.cljc",
    :line 313,
    :arglists ([zloc]),
    :doc
    "Push out the rightmost node of the current S-expression into outer right form.\n\n- `[1 2 [|3 4] 5] => [1 2 [|3] 4 5]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "clj"}
   {:name "newlines",
    :file "rewrite_clj/node.cljc",
    :line 809,
    :arglists ([n]),
    :doc "Create node representing `n` newline characters.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "replace",
    :file "rewrite_clj/zip.cljc",
    :line 306,
    :arglists ([zloc item]),
    :doc
    "Return `zloc` with the current node replaced by `item`.\nIf `item` is not already a node, an attempt will be made to coerce it to one.\n\nUse [[replace*]] for non-coercing version of replace.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "string",
    :file "rewrite_clj/node.cljc",
    :line 195,
    :arglists ([node]),
    :doc "Return the string version of `node`.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "wrap-fully-forward-slurp",
    :file "rewrite_clj/paredit.cljc",
    :line 373,
    :arglists ([zloc t]),
    :doc
    "Create a new seq node of type `t` left of `zloc` then slurp fully into the new node\n\n- `[1 |2 3 4] => [1 [|2 3 4]]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "clj"}
   {:name "symbol-node?",
    :file "rewrite_clj/node.cljc",
    :line 775,
    :arglists ([n]),
    :doc "Returns true if `n` is a node representing a symbol.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "insert-right",
    :file "rewrite_clj/zip.cljc",
    :line 474,
    :arglists ([zloc item]),
    :doc
    "Return zipper with `item` inserted to the right of the current node in `zloc`, without moving location.\nIf `item` is not already a node, an attempt will be made to coerce it to one.\n\nWill insert a space if necessary.\n\nUse [[rewrite-clj.zip/insert-right*]] to insert without adding any whitespace.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "find",
    :file "rewrite_clj/zip.cljc",
    :line 367,
    :arglists ([zloc p?] [zloc f p?]),
    :doc
    "Return `zloc` located to the first node satisfying predicate `p?` else nil.\nSearch starts at the current node and continues via movement function `f`.\n\n`f` defaults to [[right]]",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "fn-node",
    :file "rewrite_clj/node.cljc",
    :line 246,
    :arglists ([children]),
    :doc
    "Create node representing an anonymous function with `children`.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/fn-node [(n/token-node '+)\n                (n/spaces 1)\n                (n/token-node 1)\n                (n/spaces 1)\n                (n/token-node '%1)])\n    n/string)\n;; => \"#(+ 1 %1)\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "forms-node",
    :file "rewrite_clj/node.cljc",
    :line 263,
    :arglists ([children]),
    :doc
    "Create top-level node wrapping multiple `children`.\nThe forms node is equivalent to an implicit `do` at the top-level.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/forms-node [(n/token-node 1)\n                   (n/spaces 1)\n                   (n/token-node 2)])\n    n/string)\n;; => \"1 2\"\n```\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "deref-node",
    :file "rewrite_clj/node.cljc",
    :line 465,
    :arglists ([children]),
    :doc
    "Create node representing the dereferencing of a form\nwhere `children` is either a sequence of nodes or a single node.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/deref-node (n/token-node 'my-var))\n    n/string)\n;; => \"@my-var\"\n\n;; specifying a sequence allows for whitespace between @ and form\n(-> (n/deref-node [(n/spaces 2)\n                   (n/token-node 'my-var)])\n    n/string)\n;; => \"@  my-var\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "list-node",
    :file "rewrite_clj/node.cljc",
    :line 554,
    :arglists ([children]),
    :doc
    "Create a node representing a list with `children`.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/list-node [(n/token-node 1)\n                  (n/spaces 1)\n                  (n/token-node 2)\n                  (n/spaces 1)\n                  (n/token-node 3)])\n    n/string)\n;; => \"(1 2 3)\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "syntax-quote-node",
    :file "rewrite_clj/node.cljc",
    :line 696,
    :arglists ([children]),
    :doc
    "Create node representing a single syntax-quoted form where `children`\nis either a sequence of nodes or a single node.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/syntax-quote-node (n/token-node 'map))\n    n/string)\n;; => \"`map\"\n\n;; specifying a sequence allows for whitespace between the\n;; syntax quote and the syntax quoted\n(-> (n/syntax-quote-node [(n/spaces 3)\n                          (n/token-node 'map)])\n    n/string)\n;; => \"`   map\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:added "0.5.0",
    :name "insert-newline-left",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 894,
    :arglists ([zloc] [zloc n]),
    :doc
    "Return zipper with `n` newlines node inserted to the left of the current node in `zloc`, without moving location.\n`n` defaults to 1.",
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "value",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 254,
    :deprecated "0.4.0",
    :arglists ([zloc]),
    :doc
    "DEPRECATED. Return a tag/s-expression pair for inner nodes, or\nthe s-expression itself for leaves.",
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "raw-meta-node",
    :file "rewrite_clj/node.cljc",
    :line 371,
    :arglists ([children] [metadata data]),
    :doc
    "Create a node representing a form with metadata that renders to the reader syntax.\n\nWhen creating manually, you can specify `metadata` and `data` and spacing between the 2 elems will be included:\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/raw-meta-node (n/keyword-node :foo)\n                     (n/vector-node [(n/token-node 2)]))\n     n/string)\n;; => \"#^:foo [2]\"\n\n(-> (n/raw-meta-node (n/map-node [:foo (n/spaces 1) 42])\n                     (n/vector-node [(n/token-node 2)]))\n    n/string)\n;; => \"#^{:foo 42} [2]\"\n```\nWhen specifying a sequence of `children`, spacing is explicit:\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/raw-meta-node [(n/keyword-node :foo)\n                      (n/spaces 1)\n                      (n/vector-node [(n/token-node 2)])])\n    n/string)\n;; => \"#^:foo [2]\"\n```\nSee also: [[meta-node]]",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "sexpr",
    :file "rewrite_clj/zip.cljc",
    :line 235,
    :arglists ([zloc]),
    :doc
    "Return s-expression (the Clojure form) of current node in `zloc`.\n\nSee docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "barf-forward",
    :file "rewrite_clj/paredit.cljc",
    :line 313,
    :arglists ([zloc]),
    :doc
    "Push out the rightmost node of the current S-expression into outer right form.\n\n- `[1 2 [|3 4] 5] => [1 2 [|3] 4 5]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "cljs"}
   {:name "map-node",
    :file "rewrite_clj/node.cljc",
    :line 571,
    :arglists ([children]),
    :doc
    "Create a node representing a map with `children`.\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/map-node [(n/keyword-node :a)\n                 (n/spaces 1)\n                 (n/token-node 1)\n                 (n/spaces 1)\n                 (n/keyword-node :b)\n                 (n/spaces 1)\n                 (n/token-node 2)])\n    (n/string))\n;; => \"{:a 1 :b 2}\"\n```\n\nNote that rewrite-clj allows the, technically illegal, unbalanced map:\n```Clojure\n(-> (n/map-node [(n/keyword-node :a)])\n    (n/string))\n;; => \"{:a}\"\n```\nSee [docs on unbalanced maps](/doc/01-user-guide.adoc#unbalanced-maps).\n\nRewrite-clj also allows the, also technically illegal, map with duplicate keys:\n```Clojure\n(-> (n/map-node [(n/keyword-node :a)\n                 (n/spaces 1)\n                 (n/token-node 1)\n                 (n/spaces 1)\n                 (n/keyword-node :a)\n                 (n/spaces 1)\n                 (n/token-node 2)])\n    (n/string))\n;; => \"{:a 1 :a 2}\"\n```\nSee [docs on maps with duplicate keys](/doc/01-user-guide.adoc#maps-with-duplicate-keys).",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "barf-backward",
    :file "rewrite_clj/paredit.cljc",
    :line 337,
    :arglists ([zloc]),
    :doc
    "Push out the leftmost node of the current S-expression into outer left form.\n\n- `[1 2 [3 |4] 5] => [1 2 3 [|4] 5]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "clj"}
   {:name "edit-node",
    :file "rewrite_clj/zip.cljc",
    :line 701,
    :arglists ([zloc f]),
    :doc
    "Return zipper applying function `f` to `zloc`. The resulting\nzipper will be located at the same path (i.e. the same number of\ndownwards and right movements from the root) incoming `zloc`.\n\nSee also [[subedit-node]] for an isolated edit.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "find-value",
    :file "rewrite_clj/zip.cljc",
    :line 415,
    :arglists ([zloc v] [zloc f v]),
    :doc
    "Return `zloc` located to the first token node that `sexpr`esses to `v` else `nil`.\n Search starts from the current node and continues via movement function `f`.\n\n `v` can be a single value or a set. When `v` is a set, matches on any value in set.\n\n `f` defaults to [[right]] in short form call.\n\nSee docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "integer-node",
    :file "rewrite_clj/node.cljc",
    :line 280,
    :arglists ([value] [value base]),
    :doc
    "Create node representing an integer `value` in `base`.\n\n`base` defaults to 10.\n\n ```Clojure\n (require '[rewrite-clj.node :as n])\n\n (-> (n/integer-node 42)\n     n/string)\n ;; => \"42\"\n\n (-> (n/integer-node 31 2)\n     n/string)\n ;; => \"2r11111\"\n ```\n\n Note: the parser does not currently parse to integer-nodes, but they fully supported for output.",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "token-node",
    :file "rewrite_clj/node.cljc",
    :line 759,
    :arglists ([value] [value string-value]),
    :doc
    "Create node for an unspecified token of `value`.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/token-node 'sym) n/string)\n;; => \"sym\"\n\n(-> (n/token-node 42) n/string)\n;; => \"42\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "leader-length",
    :file "rewrite_clj/node.cljc",
    :line 131,
    :arglists ([node]),
    :doc "Returns number of characters before children for `node`.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "parse-string-all",
    :file "rewrite_clj/parser.cljc",
    :line 39,
    :arglists ([s]),
    :doc
    "Return forms node for all source code elements in string `s`.\n",
    :type :var,
    :namespace "rewrite-clj.parser",
    :platform "cljs"}
   {:name "newline-node",
    :file "rewrite_clj/node.cljc",
    :line 814,
    :arglists ([s]),
    :doc
    "Create newline node of string `s`, where `s` is one or more linebreak characters.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "replace-children",
    :file "rewrite_clj/node.cljc",
    :line 151,
    :arglists ([node children]),
    :doc
    "Returns `node` replacing current children with `children`.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "keyword-node",
    :file "rewrite_clj/node.cljc",
    :line 302,
    :arglists ([k auto-resolved?] [k]),
    :doc
    "Create a node representing a keyword `k`.\n\nOptionally include `auto-resolved?`, which defaults to `false`.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n;; unqualified keyword\n(-> (n/keyword-node :kw)\n    n/string)\n;; => \":kw\"\n\n;; qualified keyword\n(-> (n/keyword-node :my-prefix/kw)\n    n/string)\n;; => \":my-prefix/kw\"\n\n;; keyword auto-resolved to current ns\n(-> (n/keyword-node :kw true)\n    n/string)\n;; => \"::kw\"\n\n;; keyword auto-resolved to a namespace with given alias\n(-> (n/keyword-node :ns-alias/kw true)\n    n/string)\n;; => \"::ns-alias/kw\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "prev*",
    :file "rewrite_clj/zip.cljc",
    :line 993,
    :arglists ([zloc]),
    :doc
    "Raw version of [[prev]].\n\nReturns zipper with location at the previous depth-first location in the hierarchy in `zloc`.\n  If already at the root, returns nil.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "leftmost",
    :file "rewrite_clj/zip.cljc",
    :line 542,
    :arglists ([zloc]),
    :doc
    "Return zipper with location moved to the leftmost non-whitespace/non-comment sibling of current node in `zloc`.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "node?",
    :file "rewrite_clj/node.cljc",
    :line 141,
    :arglists ([x]),
    :doc "Returns true if `x` is a rewrite-clj created node.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "prefix",
    :file "rewrite_clj/zip.cljc",
    :line 340,
    :arglists ([zloc s]),
    :doc
    "Return zipper with the current node in `zloc` prefixed with string `s`.\nOperates on token node or a multi-line node, else exception is thrown.\nWhen multi-line, first line is prefixed.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:added "0.4.9",
    :name "postwalk",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 802,
    :arglists ([zloc f] [zloc p? f]),
    :doc
    "Return zipper modified by an isolated depth-first post-order traversal.\n\nPre-order traversal visits children before root.\nFor example, traversal order of `(1 (2 3 (4 5) 6 (7 8)) 9)` is:\n\n1. `1`\n2. `2`\n3. `3`\n4. `4`\n5. `5`\n6. `(4 5)`\n7. `6`\n8. `7`\n9. `8`\n10. `(7 8)`\n11. `(2 3 (4 5) 6 (7 8))`\n12. `9`\n13. `(1 (2 3 (4 5) 6 (7 8)) 9)`\n\nTraversal starts at the current node in `zloc` and continues to the end of the isolated sub-tree.\n\nFunction `f` is called on the zipper locations satisfying predicate `p?` and must return either\n- nil to indicate no changes\n- or a valid zipper\nWARNING: when function `f` changes the location in the zipper, normal traversal will be affected.\n\nWhen `p?` is not specified `f` is called on all locations.\n\nNote that by default a newly created zipper automatically navigates to the first non-whitespace\nnode. If you want to be sure to walk all forms in a zipper, you'll want to navigate one up prior to your walk:\n\n```Clojure\n(-> (zip/of-string \"my clojure forms\")\n    zip/up\n    (zip/postwalk ...))\n```\n\nSee [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).",
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "find-tag",
    :file "rewrite_clj/zip.cljc",
    :line 397,
    :arglists ([zloc t] [zloc f t]),
    :doc
    "Return `zloc` located to the first node with tag `t` else `nil`.\nSearch starts at the current node and continues via movement function `f`.\n\n`f` defaults to [[right]]",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "find-next-tag",
    :file "rewrite_clj/zip.cljc",
    :line 406,
    :arglists ([zloc t] [zloc f t]),
    :doc
    "Return `zloc` located to the next node with tag `t` else `nil`.\nSearch starts one movement `f` after the current node and continues via `f`.\n\n `f` defaults to [[right]]",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "replace*",
    :file "rewrite_clj/zip.cljc",
    :line 1031,
    :arglists ([zloc item]),
    :doc
    "Raw version of [[replace]].\n\nReturns zipper with node `item` replacing current node in `zloc`, without moving location.\n\nNOTE: This function does no coercion, does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "skip-whitespace-left",
    :file "rewrite_clj/zip.cljc",
    :line 875,
    :arglists ([zloc]),
    :doc
    "Return zipper with location moved to first non-whitespace/non-comment starting from current node in `zloc` traversing left.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "right",
    :file "rewrite_clj/zip.cljc",
    :line 516,
    :arglists ([zloc]),
    :doc
    "Return zipper with location moved right to next non-whitespace/non-comment sibling of current node in `zloc`.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "length",
    :file "rewrite_clj/zip.cljc",
    :line 249,
    :arglists ([zloc]),
    :doc
    "Return length of printable [[string]] of current node in `zloc`.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "length",
    :file "rewrite_clj/node.cljc",
    :line 136,
    :arglists ([node]),
    :doc
    "Return number of characters for the string version of `node`.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "vector?",
    :file "rewrite_clj/zip.cljc",
    :line 610,
    :arglists ([zloc]),
    :doc "Returns true if current node in `zloc` is a vector.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "map-node",
    :file "rewrite_clj/node.cljc",
    :line 571,
    :arglists ([children]),
    :doc
    "Create a node representing a map with `children`.\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/map-node [(n/keyword-node :a)\n                 (n/spaces 1)\n                 (n/token-node 1)\n                 (n/spaces 1)\n                 (n/keyword-node :b)\n                 (n/spaces 1)\n                 (n/token-node 2)])\n    (n/string))\n;; => \"{:a 1 :b 2}\"\n```\n\nNote that rewrite-clj allows the, technically illegal, unbalanced map:\n```Clojure\n(-> (n/map-node [(n/keyword-node :a)])\n    (n/string))\n;; => \"{:a}\"\n```\nSee [docs on unbalanced maps](/doc/01-user-guide.adoc#unbalanced-maps).\n\nRewrite-clj also allows the, also technically illegal, map with duplicate keys:\n```Clojure\n(-> (n/map-node [(n/keyword-node :a)\n                 (n/spaces 1)\n                 (n/token-node 1)\n                 (n/spaces 1)\n                 (n/keyword-node :a)\n                 (n/spaces 1)\n                 (n/token-node 2)])\n    (n/string))\n;; => \"{:a 1 :a 2}\"\n```\nSee [docs on maps with duplicate keys](/doc/01-user-guide.adoc#maps-with-duplicate-keys).",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "node",
    :file "rewrite_clj/zip.cljc",
    :line 176,
    :arglists ([zloc]),
    :doc "Returns the current node in `zloc`.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "comment?",
    :file "rewrite_clj/node.cljc",
    :line 236,
    :arglists ([node]),
    :doc "Returns true if `node` is a comment.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:added "0.4.0",
    :name "string",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 270,
    :arglists ([zloc]),
    :doc "Return string representing the current node in `zloc`.\n",
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "find-next-tag",
    :file "rewrite_clj/zip.cljc",
    :line 406,
    :arglists ([zloc t] [zloc f t]),
    :doc
    "Return `zloc` located to the next node with tag `t` else `nil`.\nSearch starts one movement `f` after the current node and continues via `f`.\n\n `f` defaults to [[right]]",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "subzip",
    :file "rewrite_clj/zip.cljc",
    :line 718,
    :arglists ([zloc]),
    :doc
    "Create and return a zipper whose root is the current node in `zloc`.\n\nSee [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "find-depth-first",
    :file "rewrite_clj/zip.cljc",
    :line 385,
    :arglists ([zloc p?]),
    :doc
    "Return `zloc` located to the first node satisfying predicate `p?` else `nil`.\nSearch is depth-first from the current node.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "raw-meta-node",
    :file "rewrite_clj/node.cljc",
    :line 371,
    :arglists ([children] [metadata data]),
    :doc
    "Create a node representing a form with metadata that renders to the reader syntax.\n\nWhen creating manually, you can specify `metadata` and `data` and spacing between the 2 elems will be included:\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/raw-meta-node (n/keyword-node :foo)\n                     (n/vector-node [(n/token-node 2)]))\n     n/string)\n;; => \"#^:foo [2]\"\n\n(-> (n/raw-meta-node (n/map-node [:foo (n/spaces 1) 42])\n                     (n/vector-node [(n/token-node 2)]))\n    n/string)\n;; => \"#^{:foo 42} [2]\"\n```\nWhen specifying a sequence of `children`, spacing is explicit:\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/raw-meta-node [(n/keyword-node :foo)\n                      (n/spaces 1)\n                      (n/vector-node [(n/token-node 2)])])\n    n/string)\n;; => \"#^:foo [2]\"\n```\nSee also: [[meta-node]]",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "splice-killing-backward",
    :file "rewrite_clj/paredit.cljc",
    :line 398,
    :arglists ([zloc]),
    :doc
    "Remove left siblings of current given node in S-Expression and unwrap remaining into enclosing S-expression\n\n- `(foo (let ((x 5)) |(sqrt n)) bar) => (foo (sqrt n) bar)`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "cljs"}
   {:name "insert-left*",
    :file "rewrite_clj/zip.cljc",
    :line 1051,
    :arglists ([zloc item]),
    :doc
    "Raw version of [[insert-left]].\n\nReturns zipper with node `item` inserted as the left sibling of current node in `zloc`,\n without moving location.\n\nNOTE: This function does no coercion, does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "edit->>",
    :file "rewrite_clj/zip.cljc",
    :line 734,
    :arglists ([zloc & body]),
    :doc
    "Like `->>`, threads `zloc` through forms.\nThe resulting zipper will be located at the same path (i.e. the same\nnumber of downwards and right movements from the root) as incoming `zloc`.\n\nSee also [[subedit->>]] for an isolated edit.",
    :type :macro,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "wrap-fully-forward-slurp",
    :file "rewrite_clj/paredit.cljc",
    :line 373,
    :arglists ([zloc t]),
    :doc
    "Create a new seq node of type `t` left of `zloc` then slurp fully into the new node\n\n- `[1 |2 3 4] => [1 [|2 3 4]]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "cljs"}
   {:name "map-context-clear",
    :file "rewrite_clj/node.cljc",
    :line 190,
    :arglists ([node]),
    :doc "Removes map-qualifier context for `node`\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "kill-at-pos",
    :file "rewrite_clj/paredit.cljc",
    :line 125,
    :arglists ([zloc pos]),
    :doc
    "In string and comment aware kill\n\nPerform kill for given position `pos` Like [[kill]], but:\n\n- if inside string kills to end of string and stops there\n- If inside comment kills to end of line (not including linebreak)\n\n`pos` should provide `{:row :col }` which are relative to the start of the given form the zipper represents\n`zloc` must be positioned at a node previous (given depth first) to the node at given pos",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "clj"}
   {:name "find-next-value",
    :file "rewrite_clj/zip.cljc",
    :line 428,
    :arglists ([zloc v] [zloc f v]),
    :doc
    "Return `zloc` located to the next token node that `sexpr`esses to `v` else `nil`.\n Search starts one movement `f` from the current location, and continues via `f`.\n\n `v` can be a single value or a set. When `v` is a set matches on any value in set.\n\n `f` defaults to [[right]] in short form call.\n\nSee docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "->root-string",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 285,
    :deprecated "0.4.0",
    :arglists ([zloc]),
    :doc "DEPRECATED. Renamed to [[root-string]].\n",
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "syntax-quote-node",
    :file "rewrite_clj/node.cljc",
    :line 696,
    :arglists ([children]),
    :doc
    "Create node representing a single syntax-quoted form where `children`\nis either a sequence of nodes or a single node.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/syntax-quote-node (n/token-node 'map))\n    n/string)\n;; => \"`map\"\n\n;; specifying a sequence allows for whitespace between the\n;; syntax quote and the syntax quoted\n(-> (n/syntax-quote-node [(n/spaces 3)\n                          (n/token-node 'map)])\n    n/string)\n;; => \"`   map\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "of-string",
    :file "rewrite_clj/zip.cljc",
    :line 260,
    :arglists ([s] [s opts]),
    :doc
    "Create and return zipper from all forms in Clojure/ClojureScript/EDN string `s`.\n\nOptional `opts` can specify:\n- `:track-position?` set to `true` to enable ones-based row/column tracking, see [docs on position tracking](/doc/01-user-guide.adoc#position-tracking).\n- `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "printable-only?",
    :file "rewrite_clj/node.cljc",
    :line 146,
    :arglists ([node]),
    :doc
    "Return true if `node` cannot be converted to an s-expression element.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "edit*",
    :file "rewrite_clj/zip.cljc",
    :line 1040,
    :arglists ([zloc f & args]),
    :doc
    "Raw version of [[edit]].\n\nReturns zipper with value of `(apply f current-node args)` replacing current node in `zloc`.\n\n   The result of `f` should be a rewrite-clj node.\n\nNOTE: This function does no coercion, does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "suffix",
    :file "rewrite_clj/zip.cljc",
    :line 347,
    :arglists ([zloc s]),
    :doc
    "Return zipper with the current node in `zloc` suffixed with string `s`.\nOperates on token node or a multi-line node, else exception is thrown.\nWhen multi-line, last line is suffixed.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "edn",
    :file "rewrite_clj/zip.cljc",
    :line 218,
    :arglists ([node] [node opts]),
    :doc
    "Create and return zipper from Clojure/ClojureScript/EDN `node` (likely parsed by [[rewrite-clj.parse]]),\nand move to the first non-whitespace/non-comment child. If node is not forms node, is wrapped in forms node\nfor a consistent root.\n\nOptional `opts` can specify:\n- `:track-position?` set to `true` to enable ones-based row/column tracking, see [docs on position tracking](/doc/01-user-guide.adoc#position-tracking).\n- `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "map-context-apply",
    :file "rewrite_clj/node.cljc",
    :line 185,
    :arglists ([node map-qualifier]),
    :doc "Applies `map-qualifier` context to `node`\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "print-root",
    :file "rewrite_clj/zip.cljc",
    :line 298,
    :arglists ([zloc writer] [zloc]),
    :doc
    "Zip up and print `zloc` from root node.\n\nNOTE: Optional `writer` is currently ignored for ClojureScript.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "prev*",
    :file "rewrite_clj/zip.cljc",
    :line 993,
    :arglists ([zloc]),
    :doc
    "Raw version of [[prev]].\n\nReturns zipper with location at the previous depth-first location in the hierarchy in `zloc`.\n  If already at the root, returns nil.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "insert-left",
    :file "rewrite_clj/zip.cljc",
    :line 484,
    :arglists ([zloc item]),
    :doc
    "Return zipper with `item` inserted to the left of the current node in `zloc`, without moving location.\nWill insert a space if necessary.\nIf `item` is not already a node, an attempt will be made to coerce it to one.\n\nUse [[insert-left*]] to insert without adding any whitespace.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "right",
    :file "rewrite_clj/zip.cljc",
    :line 516,
    :arglists ([zloc]),
    :doc
    "Return zipper with location moved right to next non-whitespace/non-comment sibling of current node in `zloc`.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "map-vals",
    :file "rewrite_clj/zip.cljc",
    :line 661,
    :arglists ([f zloc]),
    :doc
    "Returns `zloc` with function `f` applied to each value node of the current node.\n Current node must be map node.\n\n`zloc` location is unchanged.\n\n`f` arg is zloc positioned at value node and should return:\n- an updated zloc with zloc positioned at value node\n- a falsey value to leave value node unchanged\n\nFolks typically use [[edit]] for `f`.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "of-string",
    :file "rewrite_clj/zip.cljc",
    :line 260,
    :arglists ([s] [s opts]),
    :doc
    "Create and return zipper from all forms in Clojure/ClojureScript/EDN string `s`.\n\nOptional `opts` can specify:\n- `:track-position?` set to `true` to enable ones-based row/column tracking, see [docs on position tracking](/doc/01-user-guide.adoc#position-tracking).\n- `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "leftmost?",
    :file "rewrite_clj/zip.cljc",
    :line 552,
    :arglists ([zloc]),
    :doc
    "Return true if at leftmost non-whitespace/non-comment sibling node in `zloc`.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "remove-preserve-newline",
    :file "rewrite_clj/zip.cljc",
    :line 594,
    :arglists ([zloc]),
    :doc
    "Same as [[remove]] but preserves newlines.\nSpecifically: will trim all whitespace - or whitespace up to first linebreak if present.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "assoc",
    :file "rewrite_clj/zip.cljc",
    :line 687,
    :arglists ([zloc k v]),
    :doc
    "Returns `zloc` with current node's `k` set to value `v`.\n\n`zloc` location is unchanged.\n\n`k` should be:\n- a key for maps\n- a zero-based index for sequences, an exception is thrown if index is out of bounds\n\nNOTE: `k` will be compared against resolved keywords in maps.\nSee docs for sexpr behavior on [namespaced elements](/doc/01-user-guide.adoc#namespaced-elements).",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "keyword-node?",
    :file "rewrite_clj/node.cljc",
    :line 334,
    :arglists ([n]),
    :doc "Returns true if `n` is a node representing a keyword.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "comma?",
    :file "rewrite_clj/node.cljc",
    :line 839,
    :arglists ([node]),
    :doc "Returns true if `node` represents one or more commas.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "reapply-context",
    :file "rewrite_clj/zip.cljc",
    :line 354,
    :arglists ([zloc]),
    :doc
    "Returns `zloc` with namespaced map sexpr context to all symbols and keywords reapplied from current location downward.\n\nKeywords and symbols:\n* that are keys in a namespaced map will have namespaced map context applied\n* otherwise will have any namespaced map context removed\n\nYou should only need to use this function if:\n* you care about `sexpr` on keywords and symbols\n* and you are moving keywords and symbols from a namespaced map to some other location.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "coerce",
    :file "rewrite_clj/node.cljc",
    :line 107,
    :arglists ([form]),
    :doc "Coerce `form` to node.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "newline-node",
    :file "rewrite_clj/node.cljc",
    :line 814,
    :arglists ([s]),
    :doc
    "Create newline node of string `s`, where `s` is one or more linebreak characters.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "split-at-pos",
    :file "rewrite_clj/paredit.cljc",
    :line 457,
    :arglists ([zloc pos]),
    :doc
    "In string aware split\n\nPerform split at given position `pos` Like split, but:\n\n- if inside string splits string into two strings\n\n`pos` should provide `{:row :col }` which are relative to the start of the given form the zipper represents\n`zloc` must be positioned at a node previous (given depth first) to the node at given pos",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "clj"}
   {:name "edn",
    :file "rewrite_clj/zip.cljc",
    :line 218,
    :arglists ([node] [node opts]),
    :doc
    "Create and return zipper from Clojure/ClojureScript/EDN `node` (likely parsed by [[rewrite-clj.parse]]),\nand move to the first non-whitespace/non-comment child. If node is not forms node, is wrapped in forms node\nfor a consistent root.\n\nOptional `opts` can specify:\n- `:track-position?` set to `true` to enable ones-based row/column tracking, see [docs on position tracking](/doc/01-user-guide.adoc#position-tracking).\n- `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "whitespace?",
    :file "rewrite_clj/node.cljc",
    :line 829,
    :arglists ([node]),
    :doc "Returns true if `node` represents Clojure whitespace.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "insert-child*",
    :file "rewrite_clj/zip.cljc",
    :line 1071,
    :arglists ([zloc item]),
    :doc
    "Raw version of [[insert-child]].\n\nReturns zipper with node `item` inserted as the leftmost child of the current node in `zloc`,\n  without moving location.\n\nNOTE: This function does no coercion, does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "find-tag-by-pos",
    :file "rewrite_clj/zip.cljc",
    :line 468,
    :arglists ([zloc pos t]),
    :doc
    "Return `zloc` located to the last node spanning position `pos` with tag `t` else `nil`.\nSearch is depth-first from the current node.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "find-next-depth-first",
    :file "rewrite_clj/zip.cljc",
    :line 391,
    :arglists ([zloc p?]),
    :doc
    "Return `zloc` located to next node satisfying predicate `p?` else `nil`.\nSearch starts depth-first after the current node.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "string-node",
    :file "rewrite_clj/node.cljc",
    :line 656,
    :arglists ([lines]),
    :doc
    "Create node representing a string value where `lines` can be a sequence of strings or a single string.\n\nWhen `lines` is a sequence, the resulting node will `tag` will be `:multi-line`, otherwise `:token`.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/string-node \"hello\")\n    n/string)\n;; => \"\\\"hello\\\"\"\n\n(-> (n/string-node [\"line1\" \"\" \"line3\"])\n     n/string)\n;; => \"\\\"line1\\n\\nline3\\\"\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "vector-node",
    :file "rewrite_clj/node.cljc",
    :line 639,
    :arglists ([children]),
    :doc
    "Create a node representing a vector with `children`.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/vector-node [(n/token-node 1)\n                    (n/spaces 1)\n                    (n/token-node 2)\n                    (n/spaces 1)\n                    (n/token-node 3)])\n    n/string)\n;; => \"[1 2 3]\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:added "0.5.0",
    :name "insert-space-right",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 887,
    :arglists ([zloc] [zloc n]),
    :doc
    "Return zipper with `n` space whitespace node inserted to the right of the current node in `zloc`, without moving location.\n`n` defaults to 1.",
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "insert-right",
    :file "rewrite_clj/zip.cljc",
    :line 474,
    :arglists ([zloc item]),
    :doc
    "Return zipper with `item` inserted to the right of the current node in `zloc`, without moving location.\nIf `item` is not already a node, an attempt will be made to coerce it to one.\n\nWill insert a space if necessary.\n\nUse [[rewrite-clj.zip/insert-right*]] to insert without adding any whitespace.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "reader-macro-node",
    :file "rewrite_clj/node.cljc",
    :line 510,
    :arglists ([children] [macro-node form-node]),
    :doc
    "Create node representing a reader macro with `macro-node` and `form-node` or `children`.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n;; here we call with macro-node and form-node\n(-> (n/reader-macro-node (n/token-node 'my-macro)\n                         (n/token-node 42))\n    n/string)\n;; => \"#my-macro 42\"\n\n;; calling with a sequence of children gives us control over whitespace\n(-> (n/reader-macro-node [(n/token-node 'my-macro)\n                          (n/spaces 4)\n                          (n/token-node 42)])\n    n/string)\n;; => \"#my-macro    42\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "remove",
    :file "rewrite_clj/zip.cljc",
    :line 567,
    :arglists ([zloc]),
    :doc
    "Return `zloc` with current node removed. Returned zipper location\n is moved to the first non-whitespace node preceding removed node in a depth-first walk.\n Removes whitespace appropriately.\n\n- `[1 |2  3]    => [|1 3]`\n- `[1 |2]       => [|1]`\n- `[|1 2]       => |[2]`\n- `[|1]         => |[]`\n- `[  |1  ]     => |[]`\n- `[1 [2 3] |4] => [1 [2 |3]]`\n- `[|1 [2 3] 4] => |[[2 3] 4]`\n\n If the removed node is a rightmost sibling, both leading and trailing whitespace\n is removed, otherwise only trailing whitespace is removed.\n\n The result is that a following element (no matter whether it is on the same line\n or not) will end up at same positon (line/column) as the removed one.\n If a comment lies betwen the original node and the neighbour this will not hold true.\n\n If the removed node is at end of input and is trailed by 1 or more newlines,\n a single trailing newline will be preserved.\n\n Use [[remove*]] to remove node without removing any surrounding whitespace.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "left*",
    :file "rewrite_clj/zip.cljc",
    :line 953,
    :arglists ([zloc]),
    :doc
    "Raw version of [[left]].\n\nReturns zipper with location at the left sibling of the current node in `zloc`, or nil.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "move-to-prev",
    :file "rewrite_clj/paredit.cljc",
    :line 526,
    :arglists ([zloc]),
    :doc
    "Move node at current location to the position of previous location given a depth first traversal\n\n  -  `(+ 1 (+ 2 |3) 4) => (+ 1 (+ |3 2) 4)`\n  - `(+ 1 (+ 2 3) |4) => (+ 1 (+ 2 3 |4))`\n\nreturns zloc after move or given zloc if a move isn't possible",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "cljs"}
   {:name "up*",
    :file "rewrite_clj/zip.cljc",
    :line 962,
    :arglists ([zloc]),
    :doc
    "Raw version of [[up]].\n\nReturns zipper with the location at the parent of current node in `zloc`, or nil if at\n  the top.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "tag",
    :file "rewrite_clj/node.cljc",
    :line 200,
    :arglists ([node]),
    :doc "Returns keyword representing type of `node`.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "keyword-node?",
    :file "rewrite_clj/node.cljc",
    :line 334,
    :arglists ([n]),
    :doc "Returns true if `n` is a node representing a keyword.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "find-value",
    :file "rewrite_clj/zip.cljc",
    :line 415,
    :arglists ([zloc v] [zloc f v]),
    :doc
    "Return `zloc` located to the first token node that `sexpr`esses to `v` else `nil`.\n Search starts from the current node and continues via movement function `f`.\n\n `v` can be a single value or a set. When `v` is a set, matches on any value in set.\n\n `f` defaults to [[right]] in short form call.\n\nSee docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "find-depth-first",
    :file "rewrite_clj/zip.cljc",
    :line 385,
    :arglists ([zloc p?]),
    :doc
    "Return `zloc` located to the first node satisfying predicate `p?` else `nil`.\nSearch is depth-first from the current node.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "map-keys",
    :file "rewrite_clj/zip.cljc",
    :line 647,
    :arglists ([f zloc]),
    :doc
    "Returns `zloc` with function `f` applied to all key nodes of the current node.\n Current node must be map node.\n\n`zloc` location is unchanged.\n\n`f` arg is zloc positioned at key node and should return:\n- an updated zloc with zloc positioned at key node\n- a falsey value to leave value node unchanged\n\nFolks typically use [[rewrite-clj.zip/edit]] for `f`.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "set-node",
    :file "rewrite_clj/node.cljc",
    :line 611,
    :arglists ([children]),
    :doc
    "Create a node representing a set with `children`.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/set-node [(n/token-node 1)\n                 (n/spaces 1)\n                 (n/token-node 2)\n                 (n/spaces 1)\n                 (n/token-node 3)])\n    n/string)\n;; => \"#{1 2 3}\"\n```\n\nNote that rewrite-clj allows the, technically illegal, set with duplicate values:\n```Clojure\n(-> (n/set-node [(n/token-node 1)\n                 (n/spaces 1)\n                 (n/token-node 1)])\n    (n/string))\n;; => \"#{1 1}\"\n```\n\nSee [docs on sets with duplicate values](/doc/01-user-guide.adoc#sets-with-duplicate-values).",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "position-span",
    :file "rewrite_clj/zip.cljc",
    :line 188,
    :arglists ([zloc]),
    :doc
    "Returns the ones-based `[[start-row start-col] [end-row end-col]]` of the current node in `zloc`.\n`end-col` is exclusive.\n\nThrows if `zloc` was not created with [position tracking](/doc/01-user-guide.adoc#position-tracking).",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "edit->>",
    :file "rewrite_clj/zip.cljc",
    :line 734,
    :arglists ([zloc & body]),
    :doc
    "Like `->>`, threads `zloc` through forms.\nThe resulting zipper will be located at the same path (i.e. the same\nnumber of downwards and right movements from the root) as incoming `zloc`.\n\nSee also [[subedit->>]] for an isolated edit.",
    :type :macro,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "edit->",
    :file "rewrite_clj/zip.cljc",
    :line 725,
    :arglists ([zloc & body]),
    :doc
    "Like `->`, threads `zloc` through forms.\nThe resulting zipper will be located at the same path (i.e. the same\nnumber of downwards and right movements from the root) as incoming `zloc`.\n\nSee also [[subedit->]] for an isolated edit.",
    :type :macro,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "reader-macro-node",
    :file "rewrite_clj/node.cljc",
    :line 510,
    :arglists ([children] [macro-node form-node]),
    :doc
    "Create node representing a reader macro with `macro-node` and `form-node` or `children`.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n;; here we call with macro-node and form-node\n(-> (n/reader-macro-node (n/token-node 'my-macro)\n                         (n/token-node 42))\n    n/string)\n;; => \"#my-macro 42\"\n\n;; calling with a sequence of children gives us control over whitespace\n(-> (n/reader-macro-node [(n/token-node 'my-macro)\n                          (n/spaces 4)\n                          (n/token-node 42)])\n    n/string)\n;; => \"#my-macro    42\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "sexpr",
    :file "rewrite_clj/zip.cljc",
    :line 235,
    :arglists ([zloc]),
    :doc
    "Return s-expression (the Clojure form) of current node in `zloc`.\n\nSee docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "replace-children",
    :file "rewrite_clj/node.cljc",
    :line 151,
    :arglists ([node children]),
    :doc
    "Returns `node` replacing current children with `children`.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "splice-killing-forward",
    :file "rewrite_clj/paredit.cljc",
    :line 405,
    :arglists ([zloc]),
    :doc
    "Remove current given node and its right siblings in S-Expression and unwrap remaining into enclosing S-expression\n\n- `(a (b c |d e) f) => (a b |c f)`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "cljs"}
   {:name "var-node",
    :file "rewrite_clj/node.cljc",
    :line 533,
    :arglists ([children]),
    :doc
    "Create node representing a var where `children` is either a\nsequence of nodes or a single node.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/var-node (n/token-node 'my-var))\n    n/string)\n;; => \"#'my-var\"\n\n;; specifying a sequence allows for whitespace between the\n;; prefix and the var\n(-> (n/var-node [(n/spaces 2)\n                 (n/token-node 'my-var)])\n    n/string)\n;; => \"#'  my-var\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "leftmost*",
    :file "rewrite_clj/zip.cljc",
    :line 1012,
    :arglists ([zloc]),
    :doc
    "Raw version of [[leftmost]].\n\nReturns zipper with location at the leftmost sibling of the current node in `zloc`, or self.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "inner?",
    :file "rewrite_clj/node.cljc",
    :line 126,
    :arglists ([node]),
    :doc "Returns true if `node` can have children.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "subedit-node",
    :file "rewrite_clj/zip.cljc",
    :line 710,
    :arglists ([zloc f]),
    :doc
    "Return zipper replacing current node in `zloc` with result of `f` applied to said node as an isolated sub-tree.\nThe resulting zipper will be located on the root of the modified sub-tree.\n\nSee [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "whitespace-or-comment?",
    :file "rewrite_clj/node.cljc",
    :line 241,
    :arglists ([node]),
    :doc
    "Check whether the given node represents whitespace or comment.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "end?",
    :file "rewrite_clj/zip.cljc",
    :line 562,
    :arglists ([zloc]),
    :doc "Return true if `zloc` is at end of depth-first traversal.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "value",
    :file "rewrite_clj/node.cljc",
    :type :var,
    :line 205,
    :deprecated "0.4.0",
    :arglists ([node]),
    :doc
    "DEPRECATED: Get first child as a pair of tag/sexpr (if inner node),\nor just the node's own sexpr. (use explicit analysis of `children`\n`child-sexprs` instead) ",
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "left*",
    :file "rewrite_clj/zip.cljc",
    :line 953,
    :arglists ([zloc]),
    :doc
    "Raw version of [[left]].\n\nReturns zipper with location at the left sibling of the current node in `zloc`, or nil.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "whitespace-node",
    :file "rewrite_clj/node.cljc",
    :line 824,
    :arglists ([s]),
    :doc
    "Create whitespace node of string `s`, where `s` is one or more space characters.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "linebreak?",
    :file "rewrite_clj/zip.cljc",
    :line 850,
    :arglists ([zloc]),
    :doc
    "Returns true when the current node in `zloc` is a linebreak.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "whitespace-or-comment?",
    :file "rewrite_clj/zip.cljc",
    :line 855,
    :arglists ([zloc]),
    :doc
    "Returns true when current node in `zloc` is whitespace or a comment.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "down",
    :file "rewrite_clj/zip.cljc",
    :line 526,
    :arglists ([zloc]),
    :doc
    "Return zipper with location moved down to the first non-whitespace/non-comment child node of the current node in `zloc`, or nil if no applicable children.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "sexprs",
    :file "rewrite_clj/node.cljc",
    :line 174,
    :arglists ([nodes] [nodes opts]),
    :doc
    "Return forms for `nodes`. Nodes that do not represent s-expression are skipped.\n\nOptional `opts` can specify:\n- `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\n\nSee docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "rightmost*",
    :file "rewrite_clj/zip.cljc",
    :line 1003,
    :arglists ([zloc]),
    :doc
    "Raw version of [[rightmost]].\n\nReturns zipper with location at the rightmost sibling of the current node in `zloc`, or self.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "insert-child",
    :file "rewrite_clj/zip.cljc",
    :line 493,
    :arglists ([zloc item]),
    :doc
    "Return zipper with `item` inserted as the first child of the current node in `zloc`, without moving location.\nWill insert a space if necessary.\nIf `item` is not already a node, an attempt will be made to coerce it to one.\n\nUse [[insert-child*]] to insert without adding any whitespace.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "slurp-backward-fully",
    :file "rewrite_clj/paredit.cljc",
    :line 298,
    :arglists ([zloc]),
    :doc
    "Pull in all left outer-nodes into current S-expression, but only the ones at the same level\nas the the first one.\n\n- `[1 2 [|3] 4 5] => [[1 2 |3] 4 5]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "cljs"}
   {:name "prewalk",
    :file "rewrite_clj/zip.cljc",
    :line 759,
    :arglists ([zloc f] [zloc p? f]),
    :doc
    "Return zipper modified by an isolated depth-first pre-order traversal.\n\nPre-order traversal visits root before children.\nFor example, traversal order of `(1 (2 3 (4 5) 6 (7 8)) 9)` is:\n\n1. `(1 (2 3 (4 5) 6 (7 8)) 9)`\n2. `1`\n3. `(2 3 (4 5) 6 (7 8))`\n4. `2`\n5. `3`\n6. `(4 5)`\n7. `4`\n8. `5`\n9. `6`\n10. `(7 8)`\n11. `7`\n12. `8`\n13. `9`\n\nTraversal starts at the current node in `zloc` and continues to the end of the isolated sub-tree.\n\nFunction `f` is called on the zipper locations satisfying predicate `p?` and must return either\n- nil to indicate no changes\n- or a valid zipper\nWARNING: when function `f` changes the location in the zipper, normal traversal will be affected.\n\nWhen `p?` is not specified `f` is called on all locations.\n\nNote that by default a newly created zipper automatically navigates to the first non-whitespace\nnode. If you want to be sure to walk all forms in a zipper, you'll want to navigate one up prior to your walk:\n\n```Clojure\n(-> (zip/of-string \"my clojure forms\")\n    zip/up\n    (zip/prewalk ...))\n```\n\nSee [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "newlines",
    :file "rewrite_clj/node.cljc",
    :line 809,
    :arglists ([n]),
    :doc "Create node representing `n` newline characters.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "inner?",
    :file "rewrite_clj/node.cljc",
    :line 126,
    :arglists ([node]),
    :doc "Returns true if `node` can have children.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "down",
    :file "rewrite_clj/zip.cljc",
    :line 526,
    :arglists ([zloc]),
    :doc
    "Return zipper with location moved down to the first non-whitespace/non-comment child node of the current node in `zloc`, or nil if no applicable children.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "unquote-splicing-node",
    :file "rewrite_clj/node.cljc",
    :line 738,
    :arglists ([children]),
    :doc
    "Create node representing a single unquote-spliced form where `children`\nis either a sequence of nodes or a single node.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/unquote-splicing-node (n/token-node 'my-var))\n    n/string)\n;; => \"~@my-var\"\n\n;; specifying a sequence allows for whitespace between the\n;; splicing unquote and the splicing unquoted\n(-> (n/unquote-splicing-node [(n/spaces 2)\n                              (n/token-node 'my-var)])\n    n/string)\n;; => \"~@  my-var\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "rightmost*",
    :file "rewrite_clj/zip.cljc",
    :line 1003,
    :arglists ([zloc]),
    :doc
    "Raw version of [[rightmost]].\n\nReturns zipper with location at the rightmost sibling of the current node in `zloc`, or self.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:added "0.4.4",
    :name "child-sexprs",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 201,
    :arglists ([zloc]),
    :doc
    "Return s-expression (the Clojure forms) of children of current node in `zloc`.\n\nSee docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).",
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "prepend-newline",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 920,
    :deprecated "0.5.0",
    :arglists ([zloc n] [zloc]),
    :doc "DEPRECATED: renamed to [[insert-newline-left]].\n",
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "splice-killing-forward",
    :file "rewrite_clj/paredit.cljc",
    :line 405,
    :arglists ([zloc]),
    :doc
    "Remove current given node and its right siblings in S-Expression and unwrap remaining into enclosing S-expression\n\n- `(a (b c |d e) f) => (a b |c f)`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "clj"}
   {:name "coerce",
    :file "rewrite_clj/node.cljc",
    :line 107,
    :arglists ([form]),
    :doc "Coerce `form` to node.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "slurp-backward-fully",
    :file "rewrite_clj/paredit.cljc",
    :line 298,
    :arglists ([zloc]),
    :doc
    "Pull in all left outer-nodes into current S-expression, but only the ones at the same level\nas the the first one.\n\n- `[1 2 [|3] 4 5] => [[1 2 |3] 4 5]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "clj"}
   {:name "value",
    :file "rewrite_clj/node.cljc",
    :type :var,
    :line 205,
    :deprecated "0.4.0",
    :arglists ([node]),
    :doc
    "DEPRECATED: Get first child as a pair of tag/sexpr (if inner node),\nor just the node's own sexpr. (use explicit analysis of `children`\n`child-sexprs` instead) ",
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "namespaced-map?",
    :file "rewrite_clj/zip.cljc",
    :line 625,
    :arglists ([zloc]),
    :doc
    "Returns true if the current node in `zloc` is a namespaced map.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:added "0.5.0",
    :name "insert-space-left",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 880,
    :arglists ([zloc] [zloc n]),
    :doc
    "Return zipper with `n` space whitespace node inserted to the left of the current node in `zloc`, without moving location.\n`n` defaults to 1.",
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "parse-string-all",
    :file "rewrite_clj/parser.cljc",
    :line 39,
    :arglists ([s]),
    :doc
    "Return forms node for all source code elements in string `s`.\n",
    :type :var,
    :namespace "rewrite-clj.parser",
    :platform "clj"}
   {:name "meta-node",
    :file "rewrite_clj/node.cljc",
    :line 339,
    :arglists ([children] [metadata data]),
    :doc
    "Create a node representing a form with metadata.\n\nWhen creating manually, you can specify `metadata` and `data` and spacing between the 2 elems will be included:\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/meta-node (n/keyword-node :foo)\n                 (n/vector-node [(n/token-node 1)]))\n    n/string)\n;; => \"^:foo [1]\"\n\n(-> (n/meta-node (n/map-node [:foo (n/spaces 1) 42])\n                 (n/vector-node [(n/token-node 1)]))\n    n/string)\n;; => \"^{:foo 42} [1]\"\n```\nWhen specifying a sequence of `children`, spacing is explicit:\n\n```Clojure\n(-> (n/meta-node [(n/keyword-node :foo)\n                  (n/spaces 1)\n                  (n/vector-node [(n/token-node 1)])])\n    n/string)\n;; => \"^:foo [1]\"\n```\nSee also: [[raw-meta-node]]",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "map-context-clear",
    :file "rewrite_clj/node.cljc",
    :line 190,
    :arglists ([node]),
    :doc "Removes map-qualifier context for `node`\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "namespaced-map-node",
    :file "rewrite_clj/node.cljc",
    :line 430,
    :arglists ([children]),
    :doc
    "Create a namespaced map node with `children`.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/namespaced-map-node [(n/map-qualifier-node true \"my-ns-alias\")\n                            (n/spaces 1)\n                            (n/map-node [(n/keyword-node :a)\n                                         (n/spaces 1)\n                                         (n/token-node 1)])])\n    n/string)\n;; => \"#::my-ns-alias {:a 1}\"\n```\n\nMap qualifier context is automatically applied to map keys for sexpr support.\n\nSee also [[map-qualifier-node]] and [[map-node]].",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "subedit-node",
    :file "rewrite_clj/zip.cljc",
    :line 710,
    :arglists ([zloc f]),
    :doc
    "Return zipper replacing current node in `zloc` with result of `f` applied to said node as an isolated sub-tree.\nThe resulting zipper will be located on the root of the modified sub-tree.\n\nSee [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "splice",
    :file "rewrite_clj/paredit.cljc",
    :line 383,
    :doc "See [[rewrite-clj.zip/splice]]\n",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "cljs"}
   {:name "edit->",
    :file "rewrite_clj/zip.cljc",
    :line 725,
    :arglists ([zloc & body]),
    :doc
    "Like `->`, threads `zloc` through forms.\nThe resulting zipper will be located at the same path (i.e. the same\nnumber of downwards and right movements from the root) as incoming `zloc`.\n\nSee also [[subedit->]] for an isolated edit.",
    :type :macro,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "skip",
    :file "rewrite_clj/zip.cljc",
    :line 860,
    :arglists ([f p? zloc]),
    :doc
    "Return zipper with location moved to first location not satisfying predicate `p?` starting from the node in\n`zloc` and traversing by function `f`.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "join",
    :file "rewrite_clj/paredit.cljc",
    :line 497,
    :arglists ([zloc]),
    :doc
    "Join S-expression to the left and right of current loc. Also works for strings.\n\n- `[[1 2] |[3 4]] => [[1 2 3 4]]`\n- `[\"Hello \" | \"World\"] => [\"Hello World\"]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "clj"}
   {:name "node",
    :file "rewrite_clj/zip.cljc",
    :line 176,
    :arglists ([zloc]),
    :doc "Returns the current node in `zloc`.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "slurp-backward",
    :file "rewrite_clj/paredit.cljc",
    :line 271,
    :arglists ([zloc]),
    :doc
    "Pull in prev left outer node (if none at first level, tries next etc) into\ncurrent S-expression\n\n- `[1 2 [|3] 4 5] => [1 [2 |3] 4 5]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "clj"}
   {:added "0.4.0",
    :name "string",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 270,
    :arglists ([zloc]),
    :doc "Return string representing the current node in `zloc`.\n",
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "find-next",
    :file "rewrite_clj/zip.cljc",
    :line 376,
    :arglists ([zloc p?] [zloc f p?]),
    :doc
    "Return `zloc` located to the next node satisfying predicate `p?` else `nil`.\nSearch starts one movement `f` from the current node and continues via `f`.\n\n`f` defaults to [[right]]",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "sexpr-able?",
    :file "rewrite_clj/zip.cljc",
    :line 242,
    :arglists ([zloc]),
    :doc
    "Return true if current node's element type in `zloc` can be [[sexpr]]-ed.\n\nSee [related docs in user guide](/doc/01-user-guide.adoc#not-all-clojure-is-sexpr-able)",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "tag",
    :file "rewrite_clj/zip.cljc",
    :line 230,
    :arglists ([zloc]),
    :doc "Return tag of current node in `zloc`.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "edit",
    :file "rewrite_clj/zip.cljc",
    :line 314,
    :arglists ([zloc f & args]),
    :doc
    "Return `zloc` with the current node replaced with the result of:\n\n `(apply f (s-expr current-node) args)`\n\nThe result of `f`, if not already a node, will be coerced to a node if possible.\n\nSee docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).\n\nUse [[edit*]] for non-coercing version of edit.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "remove-preserve-newline",
    :file "rewrite_clj/zip.cljc",
    :line 594,
    :arglists ([zloc]),
    :doc
    "Same as [[remove]] but preserves newlines.\nSpecifically: will trim all whitespace - or whitespace up to first linebreak if present.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "regex-node",
    :file "rewrite_clj/node.cljc",
    :line 451,
    :arglists ([pattern-string]),
    :doc
    "Create node representing a regex with `pattern-string`.\nUse same escape rules for `pattern-string` as you would for `(re-pattern \"pattern-string\")`\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/regex-node \"my\\\\.lil.*regex\")\n    n/string)\n;; => \"#\\\"my\\\\.lil.*regex\\\"\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "split",
    :file "rewrite_clj/paredit.cljc",
    :line 417,
    :arglists ([zloc]),
    :doc
    "Split current s-sexpression in two at given node `zloc`\n\n-  `[1 2 |3 4 5] => [1 2 3] [4 5]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "clj"}
   {:name "map-vals",
    :file "rewrite_clj/zip.cljc",
    :line 661,
    :arglists ([f zloc]),
    :doc
    "Returns `zloc` with function `f` applied to each value node of the current node.\n Current node must be map node.\n\n`zloc` location is unchanged.\n\n`f` arg is zloc positioned at value node and should return:\n- an updated zloc with zloc positioned at value node\n- a falsey value to leave value node unchanged\n\nFolks typically use [[edit]] for `f`.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "leader-length",
    :file "rewrite_clj/node.cljc",
    :line 131,
    :arglists ([node]),
    :doc "Returns number of characters before children for `node`.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "insert-left",
    :file "rewrite_clj/zip.cljc",
    :line 484,
    :arglists ([zloc item]),
    :doc
    "Return zipper with `item` inserted to the left of the current node in `zloc`, without moving location.\nWill insert a space if necessary.\nIf `item` is not already a node, an attempt will be made to coerce it to one.\n\nUse [[insert-left*]] to insert without adding any whitespace.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "splice",
    :file "rewrite_clj/zip.cljc",
    :line 327,
    :arglists ([zloc]),
    :doc
    "Return zipper with the children of the current node in `zloc` merged into itself.\n (akin to Clojure's `unquote-splicing` macro: `~@...`).\n - if the node is not one that can have children, no modification will\n   be performed.\n - if the node has no or only whitespace children, it will be removed.\n - otherwise, splicing will be performed, moving the zipper to the first\n   non-whitespace spliced child node.\n\nFor example, given `[[1 2 3] 4 5 6]`, if zloc is located at vector `[1 2 3]`, a splice will result in raising the vector's children up `[1 2 3 4 5 6]` and locating the zipper at node `1`.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "tag",
    :file "rewrite_clj/zip.cljc",
    :line 230,
    :arglists ([zloc]),
    :doc "Return tag of current node in `zloc`.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "next*",
    :file "rewrite_clj/zip.cljc",
    :line 982,
    :arglists ([zloc]),
    :doc
    "Raw version of [[next]].\n\nReturns zipper with location at the next depth-first location in the hierarchy in `zloc`.\n  When reaching the end, returns a distinguished zipper detectable via [[end?]]. If already\n  at the end, stays there.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "fn-node",
    :file "rewrite_clj/node.cljc",
    :line 246,
    :arglists ([children]),
    :doc
    "Create node representing an anonymous function with `children`.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/fn-node [(n/token-node '+)\n                (n/spaces 1)\n                (n/token-node 1)\n                (n/spaces 1)\n                (n/token-node '%1)])\n    n/string)\n;; => \"#(+ 1 %1)\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "find-next-token",
    :file "rewrite_clj/zip.cljc",
    :line 450,
    :arglists ([zloc p?] [zloc f p?]),
    :doc
    "Return `zloc` located to the next token node satisfying predicate `p?` else `nil`.\nSearch starts one movement `f` after the current node and continues via `f`.\n\n `f` defaults to [[right]]",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "remove*",
    :file "rewrite_clj/zip.cljc",
    :line 1021,
    :arglists ([zloc]),
    :doc
    "Raw version of [[remove]].\n\nReturns zipper with current node in `zloc` removed, with location at node that would have preceded\n  it in a depth-first walk.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "skip",
    :file "rewrite_clj/zip.cljc",
    :line 860,
    :arglists ([f p? zloc]),
    :doc
    "Return zipper with location moved to first location not satisfying predicate `p?` starting from the node in\n`zloc` and traversing by function `f`.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "right*",
    :file "rewrite_clj/zip.cljc",
    :line 944,
    :arglists ([zloc]),
    :doc
    "Raw version of [[right]].\n\nReturns zipper with location at the right sibling of the current node in `zloc`, or nil.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "parse-file",
    :file "rewrite_clj/parser.cljc",
    :line 45,
    :arglists ([f]),
    :doc "Return node for first source code element in file `f`.\n",
    :type :var,
    :namespace "rewrite-clj.parser",
    :platform "clj"}
   {:name "children",
    :file "rewrite_clj/node.cljc",
    :line 112,
    :arglists ([node]),
    :doc "Returns child nodes for `node`.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "root",
    :file "rewrite_clj/zip.cljc",
    :line 196,
    :arglists ([zloc]),
    :doc
    "Zips all the way up `zloc` and returns the root node, reflecting any changes.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "prefix",
    :file "rewrite_clj/zip.cljc",
    :line 340,
    :arglists ([zloc s]),
    :doc
    "Return zipper with the current node in `zloc` prefixed with string `s`.\nOperates on token node or a multi-line node, else exception is thrown.\nWhen multi-line, first line is prefixed.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "skip-whitespace-left",
    :file "rewrite_clj/zip.cljc",
    :line 875,
    :arglists ([zloc]),
    :doc
    "Return zipper with location moved to first non-whitespace/non-comment starting from current node in `zloc` traversing left.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "leftmost",
    :file "rewrite_clj/zip.cljc",
    :line 542,
    :arglists ([zloc]),
    :doc
    "Return zipper with location moved to the leftmost non-whitespace/non-comment sibling of current node in `zloc`.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "down*",
    :file "rewrite_clj/zip.cljc",
    :line 972,
    :arglists ([zloc]),
    :doc
    "Raw version of [[down]].\n\nReturns zipper with the location at the leftmost child of current node in `zloc`, or\n  nil if no children.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "whitespace?",
    :file "rewrite_clj/zip.cljc",
    :line 845,
    :arglists ([zloc]),
    :doc
    "Returns true when the current the node in `zloc` is a Clojure whitespace (which includes the comma).\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "end?",
    :file "rewrite_clj/zip.cljc",
    :line 562,
    :arglists ([zloc]),
    :doc "Return true if `zloc` is at end of depth-first traversal.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "linebreak?",
    :file "rewrite_clj/node.cljc",
    :line 804,
    :arglists ([node]),
    :doc "Returns true if `node` represents one or more linebreaks.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "find-next-value",
    :file "rewrite_clj/zip.cljc",
    :line 428,
    :arglists ([zloc v] [zloc f v]),
    :doc
    "Return `zloc` located to the next token node that `sexpr`esses to `v` else `nil`.\n Search starts one movement `f` from the current location, and continues via `f`.\n\n `v` can be a single value or a set. When `v` is a set matches on any value in set.\n\n `f` defaults to [[right]] in short form call.\n\nSee docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "vector?",
    :file "rewrite_clj/zip.cljc",
    :line 610,
    :arglists ([zloc]),
    :doc "Returns true if current node in `zloc` is a vector.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "parse-string",
    :file "rewrite_clj/parser.cljc",
    :line 34,
    :arglists ([s]),
    :doc
    "Return a node for first source code element in string `s`.\n",
    :type :var,
    :namespace "rewrite-clj.parser",
    :platform "clj"}
   {:name "line-separated",
    :file "rewrite_clj/node.cljc",
    :line 799,
    :arglists ([nodes]),
    :doc "Interleave `nodes` with newline nodes.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "assoc",
    :file "rewrite_clj/zip.cljc",
    :line 687,
    :arglists ([zloc k v]),
    :doc
    "Returns `zloc` with current node's `k` set to value `v`.\n\n`zloc` location is unchanged.\n\n`k` should be:\n- a key for maps\n- a zero-based index for sequences, an exception is thrown if index is out of bounds\n\nNOTE: `k` will be compared against resolved keywords in maps.\nSee docs for sexpr behavior on [namespaced elements](/doc/01-user-guide.adoc#namespaced-elements).",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "comma-separated",
    :file "rewrite_clj/node.cljc",
    :line 794,
    :arglists ([nodes]),
    :doc "Interleave `nodes` with `\", \"` nodes.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "unquote-node",
    :file "rewrite_clj/node.cljc",
    :line 717,
    :arglists ([children]),
    :doc
    "Create node representing a single unquoted form where `children`\nis either a sequence of nodes or a single node.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/unquote-node (n/token-node 'my-var))\n    n/string)\n;; => \"~my-var\"\n\n;; specifying a sequence allows for whitespace between the\n;; unquote and the uquoted\n(-> (n/unquote-node [(n/spaces 4)\n                     (n/token-node 'my-var)])\n    n/string)\n;; => \"~    my-var\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "wrap-around",
    :file "rewrite_clj/paredit.cljc",
    :line 359,
    :arglists ([zloc t]),
    :doc
    "Wrap current node with a given type `t` where `t` can be one of `:vector`, `:list`, `:set`, `:map` `:fn`.\n\n- `|123 => [|123]` given `:vector`\n- `|[1 [2]] => [|[1 [2]]]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "cljs"}
   {:name "printable-only?",
    :file "rewrite_clj/node.cljc",
    :line 146,
    :arglists ([node]),
    :doc
    "Return true if `node` cannot be converted to an s-expression element.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "find-tag-by-pos",
    :file "rewrite_clj/zip.cljc",
    :line 468,
    :arglists ([zloc pos t]),
    :doc
    "Return `zloc` located to the last node spanning position `pos` with tag `t` else `nil`.\nSearch is depth-first from the current node.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "wrap-around",
    :file "rewrite_clj/paredit.cljc",
    :line 359,
    :arglists ([zloc t]),
    :doc
    "Wrap current node with a given type `t` where `t` can be one of `:vector`, `:list`, `:set`, `:map` `:fn`.\n\n- `|123 => [|123]` given `:vector`\n- `|[1 [2]] => [|[1 [2]]]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "clj"}
   {:name "parse-file-all",
    :file "rewrite_clj/parser.cljc",
    :line 52,
    :arglists ([f]),
    :doc
    "Return forms node for all source code elements in file `f`.\n",
    :type :var,
    :namespace "rewrite-clj.parser",
    :platform "clj"}
   {:name "sexpr",
    :file "rewrite_clj/node.cljc",
    :line 156,
    :arglists ([node] [node opts]),
    :doc
    "Return `node` converted to form.\n\nOptional `opts` can specify:\n- `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\n\nSee docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "comment?",
    :file "rewrite_clj/node.cljc",
    :line 236,
    :arglists ([node]),
    :doc "Returns true if `node` is a comment.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "eval-node",
    :file "rewrite_clj/node.cljc",
    :line 485,
    :arglists ([children]),
    :doc
    "Create node representing an inline evaluation\nwhere `children` is either a sequence of nodes or a single node.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/eval-node (n/list-node [(n/token-node 'inc)\n                               (n/spaces 1)\n                               (n/token-node 1)]))\n    n/string)\n;; => \"#=(inc 1)\"\n\n;; specifying a sequence allows for whitespace between the\n;; prefix and the form\n(-> (n/eval-node [(n/spaces 3)\n                  (n/list-node [(n/token-node 'inc)\n                                (n/spaces 1)\n                                (n/token-node 1)])])\n    n/string)\n;; => \"#=   (inc 1)\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "list-node",
    :file "rewrite_clj/node.cljc",
    :line 554,
    :arglists ([children]),
    :doc
    "Create a node representing a list with `children`.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/list-node [(n/token-node 1)\n                  (n/spaces 1)\n                  (n/token-node 2)\n                  (n/spaces 1)\n                  (n/token-node 3)])\n    n/string)\n;; => \"(1 2 3)\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "get",
    :file "rewrite_clj/zip.cljc",
    :line 675,
    :arglists ([zloc k]),
    :doc
    "Returns `zloc` located to map key node's sexpr value matching `k` else `nil`.\n\n`k` should be:\n- a key for maps\n- a zero-based index for sequences\n\nNOTE: `k` will be compared against resolved keywords in maps.\nSee docs for sexpr behavior on [namespaced elements](/doc/01-user-guide.adoc#namespaced-elements).",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "comma-separated",
    :file "rewrite_clj/node.cljc",
    :line 794,
    :arglists ([nodes]),
    :doc "Interleave `nodes` with `\", \"` nodes.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "spaces",
    :file "rewrite_clj/node.cljc",
    :line 819,
    :arglists ([n]),
    :doc "Create node representing `n` spaces.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "linebreak?",
    :file "rewrite_clj/zip.cljc",
    :line 850,
    :arglists ([zloc]),
    :doc
    "Returns true when the current node in `zloc` is a linebreak.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "sexpr-able?",
    :file "rewrite_clj/node.cljc",
    :line 167,
    :arglists ([node]),
    :doc
    "Return true if [[sexpr]] is supported for `node`'s element type.\n\nSee [related docs in user guide](/doc/01-user-guide.adoc#not-all-clojure-is-sexpr-able)",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "meta-node",
    :file "rewrite_clj/node.cljc",
    :line 339,
    :arglists ([children] [metadata data]),
    :doc
    "Create a node representing a form with metadata.\n\nWhen creating manually, you can specify `metadata` and `data` and spacing between the 2 elems will be included:\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/meta-node (n/keyword-node :foo)\n                 (n/vector-node [(n/token-node 1)]))\n    n/string)\n;; => \"^:foo [1]\"\n\n(-> (n/meta-node (n/map-node [:foo (n/spaces 1) 42])\n                 (n/vector-node [(n/token-node 1)]))\n    n/string)\n;; => \"^{:foo 42} [1]\"\n```\nWhen specifying a sequence of `children`, spacing is explicit:\n\n```Clojure\n(-> (n/meta-node [(n/keyword-node :foo)\n                  (n/spaces 1)\n                  (n/vector-node [(n/token-node 1)])])\n    n/string)\n;; => \"^:foo [1]\"\n```\nSee also: [[raw-meta-node]]",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "prepend-space",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 908,
    :deprecated "0.5.0",
    :arglists ([zloc n] [zloc]),
    :doc "DEPRECATED: renamed to [[insert-space-left]].\n",
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "replace*",
    :file "rewrite_clj/zip.cljc",
    :line 1031,
    :arglists ([zloc item]),
    :doc
    "Raw version of [[replace]].\n\nReturns zipper with node `item` replacing current node in `zloc`, without moving location.\n\nNOTE: This function does no coercion, does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "token-node",
    :file "rewrite_clj/node.cljc",
    :line 759,
    :arglists ([value] [value string-value]),
    :doc
    "Create node for an unspecified token of `value`.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/token-node 'sym) n/string)\n;; => \"sym\"\n\n(-> (n/token-node 42) n/string)\n;; => \"42\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "sexprs",
    :file "rewrite_clj/node.cljc",
    :line 174,
    :arglists ([nodes] [nodes opts]),
    :doc
    "Return forms for `nodes`. Nodes that do not represent s-expression are skipped.\n\nOptional `opts` can specify:\n- `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\n\nSee docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "splice-killing-backward",
    :file "rewrite_clj/paredit.cljc",
    :line 398,
    :arglists ([zloc]),
    :doc
    "Remove left siblings of current given node in S-Expression and unwrap remaining into enclosing S-expression\n\n- `(foo (let ((x 5)) |(sqrt n)) bar) => (foo (sqrt n) bar)`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "clj"}
   {:name "splice",
    :file "rewrite_clj/paredit.cljc",
    :line 383,
    :doc "See [[rewrite-clj.zip/splice]]\n",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "clj"}
   {:name "whitespace?",
    :file "rewrite_clj/zip.cljc",
    :line 845,
    :arglists ([zloc]),
    :doc
    "Returns true when the current the node in `zloc` is a Clojure whitespace (which includes the comma).\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "map-qualifier-node",
    :file "rewrite_clj/node.cljc",
    :line 405,
    :arglists ([auto-resolved? prefix]),
    :doc
    "Create a map qualifier node.\nThe map qualifier node is a child node of [[namespaced-map-node]].\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n;; qualified\n(-> (n/map-qualifier-node false \"my-prefix\")\n    n/string)\n;; => \":my-prefix\"\n\n;; auto-resolved to current ns\n(-> (n/map-qualifier-node true nil)\n    n/string)\n;; => \"::\"\n\n;; auto-resolve to namespace with alias\n(-> (n/map-qualifier-node true \"my-ns-alias\")\n    n/string)\n;; => \"::my-ns-alias\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "insert-right*",
    :file "rewrite_clj/zip.cljc",
    :line 1061,
    :arglists ([zloc item]),
    :doc
    "Raw version of [[insert-right]].\n\nReturns zipper with node `item` inserted as the right sibling of the current node in `zloc`,\n  without moving location.\n\nNOTE: This function does no coercion, does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "length",
    :file "rewrite_clj/node.cljc",
    :line 136,
    :arglists ([node]),
    :doc
    "Return number of characters for the string version of `node`.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "slurp-forward",
    :file "rewrite_clj/paredit.cljc",
    :line 233,
    :arglists ([zloc]),
    :doc
    "Pull in next right outer node (if none at first level, tries next etc) into\ncurrent S-expression\n\n- `[1 2 [|3] 4 5] => [1 2 [|3 4] 5]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "cljs"}
   {:name "node?",
    :file "rewrite_clj/node.cljc",
    :line 141,
    :arglists ([x]),
    :doc "Returns true if `x` is a rewrite-clj created node.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "find-next-token",
    :file "rewrite_clj/zip.cljc",
    :line 450,
    :arglists ([zloc p?] [zloc f p?]),
    :doc
    "Return `zloc` located to the next token node satisfying predicate `p?` else `nil`.\nSearch starts one movement `f` after the current node and continues via `f`.\n\n `f` defaults to [[right]]",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "subedit->",
    :file "rewrite_clj/zip.cljc",
    :line 743,
    :arglists ([zloc & body]),
    :doc
    "Like `->`, threads `zloc`, as an isolated sub-tree through forms, then zips\nup to, and locates at, the root of the modified sub-tree.\n\nSee [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).",
    :type :macro,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "prewalk",
    :file "rewrite_clj/zip.cljc",
    :line 759,
    :arglists ([zloc f] [zloc p? f]),
    :doc
    "Return zipper modified by an isolated depth-first pre-order traversal.\n\nPre-order traversal visits root before children.\nFor example, traversal order of `(1 (2 3 (4 5) 6 (7 8)) 9)` is:\n\n1. `(1 (2 3 (4 5) 6 (7 8)) 9)`\n2. `1`\n3. `(2 3 (4 5) 6 (7 8))`\n4. `2`\n5. `3`\n6. `(4 5)`\n7. `4`\n8. `5`\n9. `6`\n10. `(7 8)`\n11. `7`\n12. `8`\n13. `9`\n\nTraversal starts at the current node in `zloc` and continues to the end of the isolated sub-tree.\n\nFunction `f` is called on the zipper locations satisfying predicate `p?` and must return either\n- nil to indicate no changes\n- or a valid zipper\nWARNING: when function `f` changes the location in the zipper, normal traversal will be affected.\n\nWhen `p?` is not specified `f` is called on all locations.\n\nNote that by default a newly created zipper automatically navigates to the first non-whitespace\nnode. If you want to be sure to walk all forms in a zipper, you'll want to navigate one up prior to your walk:\n\n```Clojure\n(-> (zip/of-string \"my clojure forms\")\n    zip/up\n    (zip/prewalk ...))\n```\n\nSee [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "of-file",
    :file "rewrite_clj/zip.cljc",
    :line 933,
    :arglists ([f] [f opts]),
    :doc
    "Create and return zipper from all forms in Clojure/ClojureScript/EDN File `f`.\n\nOptional `opts` can specify:\n- `:track-position?` set to `true` to enable ones-based row/column tracking, see [docs on position tracking](/doc/01-user-guide.adoc#position-tracking).\n- `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "append-child",
    :file "rewrite_clj/zip.cljc",
    :line 502,
    :arglists ([zloc item]),
    :doc
    "Return zipper with `item` inserted as the last child of the current node in `zloc`, without moving.\nWill insert a space if necessary.\nIf `item` is not already a node, an attempt will be made to coerce it to one.\n\nUse [[append-child*]] to append without adding any whitespace.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "namespaced-map?",
    :file "rewrite_clj/zip.cljc",
    :line 625,
    :arglists ([zloc]),
    :doc
    "Returns true if the current node in `zloc` is a namespaced map.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "line-separated",
    :file "rewrite_clj/node.cljc",
    :line 799,
    :arglists ([nodes]),
    :doc "Interleave `nodes` with newline nodes.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "child-sexprs",
    :file "rewrite_clj/node.cljc",
    :line 117,
    :arglists ([node] [node opts]),
    :doc
    "Returns children for `node` converted to Clojure forms.\n\nOptional `opts` can specify:\n- `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "whitespace-nodes",
    :file "rewrite_clj/node.cljc",
    :line 844,
    :arglists ([s]),
    :doc
    "Convert string `s` of whitespace to whitespace/newline nodes.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "skip-whitespace",
    :file "rewrite_clj/zip.cljc",
    :line 866,
    :arglists ([zloc] [f zloc]),
    :doc
    "Return zipper with location moved to first non-whitespace/non-comment starting from current node in `zloc`\nand traversing by function `f`.\n\n`f` defaults to [[right]]",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "whitespace?",
    :file "rewrite_clj/node.cljc",
    :line 829,
    :arglists ([node]),
    :doc "Returns true if `node` represents Clojure whitespace.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:added "0.4.4",
    :name "child-sexprs",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 201,
    :arglists ([zloc]),
    :doc
    "Return s-expression (the Clojure forms) of children of current node in `zloc`.\n\nSee docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).",
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "map-qualifier-node",
    :file "rewrite_clj/node.cljc",
    :line 405,
    :arglists ([auto-resolved? prefix]),
    :doc
    "Create a map qualifier node.\nThe map qualifier node is a child node of [[namespaced-map-node]].\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n;; qualified\n(-> (n/map-qualifier-node false \"my-prefix\")\n    n/string)\n;; => \":my-prefix\"\n\n;; auto-resolved to current ns\n(-> (n/map-qualifier-node true nil)\n    n/string)\n;; => \"::\"\n\n;; auto-resolve to namespace with alias\n(-> (n/map-qualifier-node true \"my-ns-alias\")\n    n/string)\n;; => \"::my-ns-alias\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "get",
    :file "rewrite_clj/zip.cljc",
    :line 675,
    :arglists ([zloc k]),
    :doc
    "Returns `zloc` located to map key node's sexpr value matching `k` else `nil`.\n\n`k` should be:\n- a key for maps\n- a zero-based index for sequences\n\nNOTE: `k` will be compared against resolved keywords in maps.\nSee docs for sexpr behavior on [namespaced elements](/doc/01-user-guide.adoc#namespaced-elements).",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "map-keys",
    :file "rewrite_clj/zip.cljc",
    :line 647,
    :arglists ([f zloc]),
    :doc
    "Returns `zloc` with function `f` applied to all key nodes of the current node.\n Current node must be map node.\n\n`zloc` location is unchanged.\n\n`f` arg is zloc positioned at key node and should return:\n- an updated zloc with zloc positioned at key node\n- a falsey value to leave value node unchanged\n\nFolks typically use [[rewrite-clj.zip/edit]] for `f`.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "split",
    :file "rewrite_clj/paredit.cljc",
    :line 417,
    :arglists ([zloc]),
    :doc
    "Split current s-sexpression in two at given node `zloc`\n\n-  `[1 2 |3 4 5] => [1 2 3] [4 5]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "cljs"}
   {:name "barf-backward",
    :file "rewrite_clj/paredit.cljc",
    :line 337,
    :arglists ([zloc]),
    :doc
    "Push out the leftmost node of the current S-expression into outer left form.\n\n- `[1 2 [3 |4] 5] => [1 2 3 [|4] 5]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "cljs"}
   {:name "map",
    :file "rewrite_clj/zip.cljc",
    :line 630,
    :arglists ([f zloc]),
    :doc
    "Returns `zloc` with function `f` applied to all nodes of the current node.\nCurrent node must be a sequence node. Equivalent to [[rewrite-clj.zip/map-vals]] for maps.\n\n`zloc` location is unchanged.\n\n`f` arg is zloc positioned at\n- value nodes for maps\n- each element of a seq\nand is should return:\n- an updated zloc with zloc positioned at edited node\n- a falsey value to leave value node unchanged\n\nFolks typically use [[edit]] for `f`.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "leftmost*",
    :file "rewrite_clj/zip.cljc",
    :line 1012,
    :arglists ([zloc]),
    :doc
    "Raw version of [[leftmost]].\n\nReturns zipper with location at the leftmost sibling of the current node in `zloc`, or self.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "whitespace-or-comment?",
    :file "rewrite_clj/node.cljc",
    :line 241,
    :arglists ([node]),
    :doc
    "Check whether the given node represents whitespace or comment.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "prepend-space",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 908,
    :deprecated "0.5.0",
    :arglists ([zloc n] [zloc]),
    :doc "DEPRECATED: renamed to [[insert-space-left]].\n",
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "print-root",
    :file "rewrite_clj/zip.cljc",
    :line 298,
    :arglists ([zloc writer] [zloc]),
    :doc
    "Zip up and print `zloc` from root node.\n\nNOTE: Optional `writer` is currently ignored for ClojureScript.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "seq?",
    :file "rewrite_clj/zip.cljc",
    :line 600,
    :arglists ([zloc]),
    :doc "Returns true if current node in `zloc` is a sequence.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "prepend-newline",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 920,
    :deprecated "0.5.0",
    :arglists ([zloc n] [zloc]),
    :doc "DEPRECATED: renamed to [[insert-newline-left]].\n",
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "remove*",
    :file "rewrite_clj/zip.cljc",
    :line 1021,
    :arglists ([zloc]),
    :doc
    "Raw version of [[remove]].\n\nReturns zipper with current node in `zloc` removed, with location at node that would have preceded\n  it in a depth-first walk.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "position-span",
    :file "rewrite_clj/zip.cljc",
    :line 188,
    :arglists ([zloc]),
    :doc
    "Returns the ones-based `[[start-row start-col] [end-row end-col]]` of the current node in `zloc`.\n`end-col` is exclusive.\n\nThrows if `zloc` was not created with [position tracking](/doc/01-user-guide.adoc#position-tracking).",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "child-sexprs",
    :file "rewrite_clj/node.cljc",
    :line 117,
    :arglists ([node] [node opts]),
    :doc
    "Returns children for `node` converted to Clojure forms.\n\nOptional `opts` can specify:\n- `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "->root-string",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 285,
    :deprecated "0.4.0",
    :arglists ([zloc]),
    :doc "DEPRECATED. Renamed to [[root-string]].\n",
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "subzip",
    :file "rewrite_clj/zip.cljc",
    :line 718,
    :arglists ([zloc]),
    :doc
    "Create and return a zipper whose root is the current node in `zloc`.\n\nSee [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "edn*",
    :file "rewrite_clj/zip.cljc",
    :line 208,
    :arglists ([node] [node opts]),
    :doc
    "Create and return zipper from Clojure/ClojureScript/EDN `node` (likely parsed by [[rewrite-clj.parse]]).\n\nOptional `opts` can specify:\n- `:track-position?` set to `true` to enable ones-based row/column tracking, see [docs on position tracking](/doc/01-user-guide.adoc#position-tracking).\n- `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "leftmost?",
    :file "rewrite_clj/zip.cljc",
    :line 552,
    :arglists ([zloc]),
    :doc
    "Return true if at leftmost non-whitespace/non-comment sibling node in `zloc`.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "find-last-by-pos",
    :file "rewrite_clj/zip.cljc",
    :line 459,
    :arglists ([zloc pos] [zloc pos p?]),
    :doc
    "Return `zloc` located to the last node spanning position `pos` that satisfies predicate `p?` else `nil`.\n Search is depth-first from the current node.\n\nNOTE: Does not ignore whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "edit*",
    :file "rewrite_clj/zip.cljc",
    :line 1040,
    :arglists ([zloc f & args]),
    :doc
    "Raw version of [[edit]].\n\nReturns zipper with value of `(apply f current-node args)` replacing current node in `zloc`.\n\n   The result of `f` should be a rewrite-clj node.\n\nNOTE: This function does no coercion, does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "find-next-depth-first",
    :file "rewrite_clj/zip.cljc",
    :line 391,
    :arglists ([zloc p?]),
    :doc
    "Return `zloc` located to next node satisfying predicate `p?` else `nil`.\nSearch starts depth-first after the current node.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "length",
    :file "rewrite_clj/zip.cljc",
    :line 249,
    :arglists ([zloc]),
    :doc
    "Return length of printable [[string]] of current node in `zloc`.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "subedit->>",
    :file "rewrite_clj/zip.cljc",
    :line 751,
    :arglists ([zloc & body]),
    :doc
    "Like `->`. Threads `zloc`, as an isolated sub-tree through forms, then zips\n   up to, and locates at, the root of the modified sub-tree.\n\nSee [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).",
    :type :macro,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "seq?",
    :file "rewrite_clj/zip.cljc",
    :line 600,
    :arglists ([zloc]),
    :doc "Returns true if current node in `zloc` is a sequence.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "find-last-by-pos",
    :file "rewrite_clj/zip.cljc",
    :line 459,
    :arglists ([zloc pos] [zloc pos p?]),
    :doc
    "Return `zloc` located to the last node spanning position `pos` that satisfies predicate `p?` else `nil`.\n Search is depth-first from the current node.\n\nNOTE: Does not ignore whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:added "0.5.0",
    :name "insert-newline-right",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 901,
    :arglists ([zloc] [zloc n]),
    :doc
    "Return zipper with `n` newlines node inserted to the right of the current node in `zloc`, without moving location.\n`n` defaults to 1.",
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "regex-node",
    :file "rewrite_clj/node.cljc",
    :line 451,
    :arglists ([pattern-string]),
    :doc
    "Create node representing a regex with `pattern-string`.\nUse same escape rules for `pattern-string` as you would for `(re-pattern \"pattern-string\")`\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/regex-node \"my\\\\.lil.*regex\")\n    n/string)\n;; => \"#\\\"my\\\\.lil.*regex\\\"\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "subedit->>",
    :file "rewrite_clj/zip.cljc",
    :line 751,
    :arglists ([zloc & body]),
    :doc
    "Like `->`. Threads `zloc`, as an isolated sub-tree through forms, then zips\n   up to, and locates at, the root of the modified sub-tree.\n\nSee [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).",
    :type :macro,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "append-child",
    :file "rewrite_clj/zip.cljc",
    :line 502,
    :arglists ([zloc item]),
    :doc
    "Return zipper with `item` inserted as the last child of the current node in `zloc`, without moving.\nWill insert a space if necessary.\nIf `item` is not already a node, an attempt will be made to coerce it to one.\n\nUse [[append-child*]] to append without adding any whitespace.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:added "0.5.0",
    :name "insert-newline-left",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 894,
    :arglists ([zloc] [zloc n]),
    :doc
    "Return zipper with `n` newlines node inserted to the left of the current node in `zloc`, without moving location.\n`n` defaults to 1.",
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "append-newline",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 926,
    :deprecated "0.5.0",
    :arglists ([zloc n] [zloc]),
    :doc "DEPRECATED: renamed to [[insert-newline-right]].\n",
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "slurp-forward-fully",
    :file "rewrite_clj/paredit.cljc",
    :line 256,
    :arglists ([zloc]),
    :doc
    "Pull in all right outer-nodes into current S-expression, but only the ones at the same level\nas the the first one.\n\n- `[1 2 [|3] 4 5] => [1 2 [|3 4 5]]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "cljs"}
   {:name "sexpr-able?",
    :file "rewrite_clj/node.cljc",
    :line 167,
    :arglists ([node]),
    :doc
    "Return true if [[sexpr]] is supported for `node`'s element type.\n\nSee [related docs in user guide](/doc/01-user-guide.adoc#not-all-clojure-is-sexpr-able)",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "comma?",
    :file "rewrite_clj/node.cljc",
    :line 839,
    :arglists ([node]),
    :doc "Returns true if `node` represents one or more commas.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "string",
    :file "rewrite_clj/node.cljc",
    :line 195,
    :arglists ([node]),
    :doc "Return the string version of `node`.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "edn*",
    :file "rewrite_clj/zip.cljc",
    :line 208,
    :arglists ([node] [node opts]),
    :doc
    "Create and return zipper from Clojure/ClojureScript/EDN `node` (likely parsed by [[rewrite-clj.parse]]).\n\nOptional `opts` can specify:\n- `:track-position?` set to `true` to enable ones-based row/column tracking, see [docs on position tracking](/doc/01-user-guide.adoc#position-tracking).\n- `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "find-token",
    :file "rewrite_clj/zip.cljc",
    :line 441,
    :arglists ([zloc p?] [zloc f p?]),
    :doc
    "Return `zloc` located to the the first token node satisfying predicate `p?`.\nSearch starts at the current node and continues via movement function `f`.\n\n `f` defaults to [[right]]",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "append-space",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 914,
    :deprecated "0.5.0",
    :arglists ([zloc n] [zloc]),
    :doc "DEPRECATED: renamed to [[insert-space-right]].\n",
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "spaces",
    :file "rewrite_clj/node.cljc",
    :line 819,
    :arglists ([n]),
    :doc "Create node representing `n` spaces.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "quote-node",
    :file "rewrite_clj/node.cljc",
    :line 675,
    :arglists ([children]),
    :doc
    "Create node representing a single quoted form where `children`\nis either a sequence of nodes or a single node.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/quote-node (n/token-node 'sym))\n    (n/string))\n;; => \"'sym\"\n\n;; specifying a sequence allows for whitespace between the\n;; quote and the quoted\n(-> (n/quote-node [(n/spaces 10)\n                   (n/token-node 'sym1) ])\n    n/string)\n;; => \"'          sym1\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "rightmost",
    :file "rewrite_clj/zip.cljc",
    :line 547,
    :arglists ([zloc]),
    :doc
    "Return zipper with location moved to the rightmost non-whitespace/non-comment sibling of current node in `zloc`.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "skip-whitespace",
    :file "rewrite_clj/zip.cljc",
    :line 866,
    :arglists ([zloc] [f zloc]),
    :doc
    "Return zipper with location moved to first non-whitespace/non-comment starting from current node in `zloc`\nand traversing by function `f`.\n\n`f` defaults to [[right]]",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "left",
    :file "rewrite_clj/zip.cljc",
    :line 511,
    :arglists ([zloc]),
    :doc
    "Return zipper with location moved left to next non-whitespace/non-comment sibling of current node in `zloc`.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "integer-node",
    :file "rewrite_clj/node.cljc",
    :line 280,
    :arglists ([value] [value base]),
    :doc
    "Create node representing an integer `value` in `base`.\n\n`base` defaults to 10.\n\n ```Clojure\n (require '[rewrite-clj.node :as n])\n\n (-> (n/integer-node 42)\n     n/string)\n ;; => \"42\"\n\n (-> (n/integer-node 31 2)\n     n/string)\n ;; => \"2r11111\"\n ```\n\n Note: the parser does not currently parse to integer-nodes, but they fully supported for output.",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "map-context-apply",
    :file "rewrite_clj/node.cljc",
    :line 185,
    :arglists ([node map-qualifier]),
    :doc "Applies `map-qualifier` context to `node`\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "next*",
    :file "rewrite_clj/zip.cljc",
    :line 982,
    :arglists ([zloc]),
    :doc
    "Raw version of [[next]].\n\nReturns zipper with location at the next depth-first location in the hierarchy in `zloc`.\n  When reaching the end, returns a distinguished zipper detectable via [[end?]]. If already\n  at the end, stays there.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "kill-at-pos",
    :file "rewrite_clj/paredit.cljc",
    :line 125,
    :arglists ([zloc pos]),
    :doc
    "In string and comment aware kill\n\nPerform kill for given position `pos` Like [[kill]], but:\n\n- if inside string kills to end of string and stops there\n- If inside comment kills to end of line (not including linebreak)\n\n`pos` should provide `{:row :col }` which are relative to the start of the given form the zipper represents\n`zloc` must be positioned at a node previous (given depth first) to the node at given pos",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "cljs"}
   {:name "children",
    :file "rewrite_clj/node.cljc",
    :line 112,
    :arglists ([node]),
    :doc "Returns child nodes for `node`.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "split-at-pos",
    :file "rewrite_clj/paredit.cljc",
    :line 457,
    :arglists ([zloc pos]),
    :doc
    "In string aware split\n\nPerform split at given position `pos` Like split, but:\n\n- if inside string splits string into two strings\n\n`pos` should provide `{:row :col }` which are relative to the start of the given form the zipper represents\n`zloc` must be positioned at a node previous (given depth first) to the node at given pos",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "cljs"}
   {:name "kill",
    :file "rewrite_clj/paredit.cljc",
    :line 80,
    :arglists ([zloc]),
    :doc
    "Kill all sibling nodes to the right of the current node in `zloc`.\n\n- `[1 2| 3 4] => [1 2|]`",
    :type :var,
    :namespace "rewrite-clj.paredit",
    :platform "cljs"}
   {:name "rightmost?",
    :file "rewrite_clj/zip.cljc",
    :line 557,
    :arglists ([zloc]),
    :doc
    "Return true if at rightmost non-whitespace/non-comment sibling node in `zloc`.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "find",
    :file "rewrite_clj/zip.cljc",
    :line 367,
    :arglists ([zloc p?] [zloc f p?]),
    :doc
    "Return `zloc` located to the first node satisfying predicate `p?` else nil.\nSearch starts at the current node and continues via movement function `f`.\n\n`f` defaults to [[right]]",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "right*",
    :file "rewrite_clj/zip.cljc",
    :line 944,
    :arglists ([zloc]),
    :doc
    "Raw version of [[right]].\n\nReturns zipper with location at the right sibling of the current node in `zloc`, or nil.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "deref-node",
    :file "rewrite_clj/node.cljc",
    :line 465,
    :arglists ([children]),
    :doc
    "Create node representing the dereferencing of a form\nwhere `children` is either a sequence of nodes or a single node.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/deref-node (n/token-node 'my-var))\n    n/string)\n;; => \"@my-var\"\n\n;; specifying a sequence allows for whitespace between @ and form\n(-> (n/deref-node [(n/spaces 2)\n                   (n/token-node 'my-var)])\n    n/string)\n;; => \"@  my-var\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "find-token",
    :file "rewrite_clj/zip.cljc",
    :line 441,
    :arglists ([zloc p?] [zloc f p?]),
    :doc
    "Return `zloc` located to the the first token node satisfying predicate `p?`.\nSearch starts at the current node and continues via movement function `f`.\n\n `f` defaults to [[right]]",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "parse-string",
    :file "rewrite_clj/parser.cljc",
    :line 34,
    :arglists ([s]),
    :doc
    "Return a node for first source code element in string `s`.\n",
    :type :var,
    :namespace "rewrite-clj.parser",
    :platform "cljs"}
   {:name "whitespace-or-comment?",
    :file "rewrite_clj/zip.cljc",
    :line 855,
    :arglists ([zloc]),
    :doc
    "Returns true when current node in `zloc` is whitespace or a comment.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "forms-node",
    :file "rewrite_clj/node.cljc",
    :line 263,
    :arglists ([children]),
    :doc
    "Create top-level node wrapping multiple `children`.\nThe forms node is equivalent to an implicit `do` at the top-level.\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/forms-node [(n/token-node 1)\n                   (n/spaces 1)\n                   (n/token-node 2)])\n    n/string)\n;; => \"1 2\"\n```\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "clj"}
   {:name "set?",
    :file "rewrite_clj/zip.cljc",
    :line 615,
    :arglists ([zloc]),
    :doc "Returns true if current node in `zloc` is a set.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:added "0.5.0",
    :name "insert-space-left",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 880,
    :arglists ([zloc] [zloc n]),
    :doc
    "Return zipper with `n` space whitespace node inserted to the left of the current node in `zloc`, without moving location.\n`n` defaults to 1.",
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "position",
    :file "rewrite_clj/zip.cljc",
    :line 181,
    :arglists ([zloc]),
    :doc
    "Returns the ones-based `[row col]` of the start of the current node in `zloc`.\n\nThrows if `zloc` was not created with [position tracking](/doc/01-user-guide.adoc#position-tracking).",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "whitespace-node",
    :file "rewrite_clj/node.cljc",
    :line 824,
    :arglists ([s]),
    :doc
    "Create whitespace node of string `s`, where `s` is one or more space characters.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:added "0.4.0",
    :name "root-string",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 280,
    :arglists ([zloc]),
    :doc "Return string representing the zipped-up `zloc` zipper.\n",
    :namespace "rewrite-clj.zip",
    :platform "cljs"}
   {:name "list?",
    :file "rewrite_clj/zip.cljc",
    :line 605,
    :arglists ([zloc]),
    :doc "Returns true if current node in `zloc` is a list.\n",
    :type :var,
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:added "0.4.0",
    :name "root-string",
    :file "rewrite_clj/zip.cljc",
    :type :var,
    :line 280,
    :arglists ([zloc]),
    :doc "Return string representing the zipped-up `zloc` zipper.\n",
    :namespace "rewrite-clj.zip",
    :platform "clj"}
   {:name "linebreak?",
    :file "rewrite_clj/node.cljc",
    :line 804,
    :arglists ([node]),
    :doc "Returns true if `node` represents one or more linebreaks.\n",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}
   {:name "comment-node",
    :file "rewrite_clj/node.cljc",
    :line 212,
    :arglists ([s] [prefix s]),
    :doc
    "Create node representing a comment with text `s`.\n\nYou may optionally specify a `prefix` of `\";\"` or `\"#!\"`, defaults is `\";\"`.\n\nArgument `s`:\n- must not include the `prefix`\n- usually includes the trailing newline character, otherwise subsequent nodes will be on the comment line\n\n```Clojure\n(require '[rewrite-clj.node :as n])\n\n(-> (n/comment-node \"; my comment\\n\")\n    n/string)\n;; => \";; my comment\\n\"\n\n(-> (n/comment-node \"#!\" \"/usr/bin/env bb\\n\")\n    n/string)\n;; => \"#!/usr/bin/env bb\\n\"\n```",
    :type :var,
    :namespace "rewrite-clj.node",
    :platform "cljs"}},
 :latest "1.0.767-alpha",
 :version-entity
 {:group-id "rewrite-clj",
  :artifact-id "rewrite-clj",
  :version "1.0.767-alpha"}}
